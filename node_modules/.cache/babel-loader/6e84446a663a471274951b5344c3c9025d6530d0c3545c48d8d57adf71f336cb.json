{"ast":null,"code":"import { decode } from \"cbor\";\nimport { Buffer } from 'buffer';\nimport { base64ToBase64URL } from './base64ToBase64URL';\nimport { aaguidToString } from './aaguidToString';\nimport { coseKeyTypeToString } from './coseKeyTypeToString';\nimport { coseAlgToString } from './coseAlgToString';\nvar COSEKEYS = /*#__PURE__*/function (COSEKEYS) {\n  COSEKEYS[COSEKEYS[\"kty\"] = 1] = \"kty\";\n  COSEKEYS[COSEKEYS[\"alg\"] = 3] = \"alg\";\n  COSEKEYS[COSEKEYS[\"crv\"] = -1] = \"crv\";\n  COSEKEYS[COSEKEYS[\"x\"] = -2] = \"x\";\n  COSEKEYS[COSEKEYS[\"y\"] = -3] = \"y\";\n  COSEKEYS[COSEKEYS[\"mod\"] = -1] = \"mod\";\n  COSEKEYS[COSEKEYS[\"exp\"] = -2] = \"exp\";\n  return COSEKEYS;\n}(COSEKEYS || {});\nexport function parseAuthData(authData) {\n  let buffer = Buffer.from(authData);\n  // const cbor = require('cbor');\n\n  const rpIdHash = buffer.slice(0, 32);\n  buffer = buffer.slice(32);\n  const flagsBuf = buffer.slice(0, 1);\n  buffer = buffer.slice(1);\n  const flagsInt = flagsBuf[0];\n  const flags = {\n    userPresent: !!(flagsInt & 1 << 0),\n    // User Presence\n    userVerified: !!(flagsInt & 1 << 2),\n    // User Verified\n    backupEligible: !!(flagsInt & 1 << 3),\n    // Backup Eligibility\n    backupStatus: !!(flagsInt & 1 << 4),\n    // Backup State\n    attestedData: !!(flagsInt & 1 << 6),\n    // Attested Credential Data Present\n    extensionData: !!(flagsInt & 1 << 7) // Extension Data Present\n  };\n\n  const counterBuf = buffer.slice(0, 4);\n  buffer = buffer.slice(4);\n  const counter = counterBuf.readUInt32BE(0);\n  let aaguid = undefined;\n  let credentialID = undefined;\n  let credentialPublicKey = undefined;\n  let parsedCredentialPublicKey = undefined;\n  if (flags.attestedData) {\n    aaguid = buffer.slice(0, 16);\n    buffer = buffer.slice(16);\n    const credIDLenBuf = buffer.slice(0, 2);\n    buffer = buffer.slice(2);\n    const credIDLen = credIDLenBuf.readUInt16BE(0);\n    const credentialIDBuffer = buffer.slice(0, credIDLen);\n    buffer = buffer.slice(credIDLen);\n\n    // Base64 to Base64URL\n    credentialID = base64ToBase64URL(credentialIDBuffer.toString('base64'));\n    credentialPublicKey = base64ToBase64URL(buffer.toString('base64'));\n    console.log(buffer);\n    console.log(buffer.toString('base64'));\n    const pubKey = decode(buffer.toString('base64'), 'base64');\n    console.log(pubKey);\n\n    // TODO: Handle this differently if this is an RSA key\n    parsedCredentialPublicKey = {\n      keyType: pubKey === null || pubKey === void 0 ? void 0 : pubKey[1]\n    };\n    if (pubKey) {\n      const kty = pubKey.get(COSEKEYS.kty);\n      parsedCredentialPublicKey.keyType = coseKeyTypeToString(kty);\n      parsedCredentialPublicKey.algorithm = coseAlgToString(pubKey.get(COSEKEYS.alg));\n      if (kty === 3) {\n        // RSA\n        parsedCredentialPublicKey.modulus = base64ToBase64URL(Buffer.from(pubKey.get(COSEKEYS.mod)).toString('base64'));\n        parsedCredentialPublicKey.exponent = parseInt(Buffer.from(pubKey.get(COSEKEYS.exp)).toString('hex'), 16);\n      } else {\n        // Everything else, including EC2 and OKP\n        parsedCredentialPublicKey.curve = pubKey.get(COSEKEYS.crv);\n        parsedCredentialPublicKey.x = base64ToBase64URL(Buffer.from(pubKey.get(COSEKEYS.x)).toString('base64'));\n        // y isn't present in OKP certs\n        if (pubKey.get(COSEKEYS.y)) {\n          parsedCredentialPublicKey.y = base64ToBase64URL(Buffer.from(pubKey.get(COSEKEYS.y)).toString('base64'));\n        }\n      }\n    }\n  }\n  const toReturn = {\n    rpIdHash: base64ToBase64URL(rpIdHash.toString('base64')),\n    flags,\n    flagsMask: `0x${Buffer.alloc(1).fill(flagsBuf).toString('hex')}`,\n    counter\n  };\n  if (aaguid) {\n    toReturn.aaguid = aaguidToString(aaguid);\n  }\n  if (credentialID) {\n    toReturn.credentialID = credentialID;\n  }\n  if (credentialPublicKey) {\n    toReturn.credentialPublicKey = credentialPublicKey;\n    toReturn.parsedCredentialPublicKey = parsedCredentialPublicKey;\n  }\n  return toReturn;\n}","map":{"version":3,"names":["decode","Buffer","base64ToBase64URL","aaguidToString","coseKeyTypeToString","coseAlgToString","COSEKEYS","parseAuthData","authData","buffer","from","rpIdHash","slice","flagsBuf","flagsInt","flags","userPresent","userVerified","backupEligible","backupStatus","attestedData","extensionData","counterBuf","counter","readUInt32BE","aaguid","undefined","credentialID","credentialPublicKey","parsedCredentialPublicKey","credIDLenBuf","credIDLen","readUInt16BE","credentialIDBuffer","toString","console","log","pubKey","keyType","kty","get","algorithm","alg","modulus","mod","exponent","parseInt","exp","curve","crv","x","y","toReturn","flagsMask","alloc","fill"],"sources":["/Users/peterchen/Dropbox/Hexlink/pwa-demo/src/utils/passkey/shared/parseAuthData.ts"],"sourcesContent":["import { decode } from \"cbor\";\nimport { Buffer } from 'buffer';\nimport { base64ToBase64URL } from './base64ToBase64URL';\nimport { aaguidToString } from './aaguidToString';\nimport { coseKeyTypeToString } from './coseKeyTypeToString';\nimport { coseAlgToString } from './coseAlgToString';\n\nenum COSEKEYS {\n  kty = 1,\n  alg = 3,\n  crv = -1,\n  x = -2,\n  y = -3,\n  // RSA\n  mod = -1,\n  exp = -2,\n}\n\nexport function parseAuthData(authData: ArrayBuffer): AuthenticatorData {\n  let buffer = Buffer.from(authData);\n  // const cbor = require('cbor');\n\n  const rpIdHash = buffer.slice(0, 32);\n  buffer = buffer.slice(32);\n\n  const flagsBuf = buffer.slice(0, 1);\n  buffer = buffer.slice(1);\n\n  const flagsInt: number = flagsBuf[0];\n\n  const flags = {\n    userPresent: !!(flagsInt & (1 << 0)), // User Presence\n    userVerified: !!(flagsInt & (1 << 2)), // User Verified\n    backupEligible: !!(flagsInt & (1 << 3)), // Backup Eligibility\n    backupStatus: !!(flagsInt & (1 << 4)), // Backup State\n    attestedData: !!(flagsInt & (1 << 6)), // Attested Credential Data Present\n    extensionData: !!(flagsInt & (1 << 7)), // Extension Data Present\n  };\n\n  const counterBuf = buffer.slice(0, 4);\n  buffer = buffer.slice(4);\n\n  const counter = counterBuf.readUInt32BE(0);\n\n  let aaguid: Buffer | undefined = undefined;\n  let credentialID: string | undefined = undefined;\n  let credentialPublicKey: string | undefined = undefined;\n  let parsedCredentialPublicKey: ParsedCredentialPublicKey | undefined = undefined;\n\n  if (flags.attestedData) {\n    aaguid = buffer.slice(0, 16);\n    buffer = buffer.slice(16);\n\n    const credIDLenBuf = buffer.slice(0, 2);\n    buffer = buffer.slice(2);\n\n    const credIDLen = credIDLenBuf.readUInt16BE(0);\n    const credentialIDBuffer = buffer.slice(0, credIDLen);\n    buffer = buffer.slice(credIDLen);\n\n    // Base64 to Base64URL\n    credentialID = base64ToBase64URL(credentialIDBuffer.toString('base64'));\n    credentialPublicKey = base64ToBase64URL(buffer.toString('base64'));\n    console.log(buffer);\n    console.log(buffer.toString('base64'));\n\n    const pubKey = decode(buffer.toString('base64'), 'base64');\n    console.log(pubKey);\n\n    // TODO: Handle this differently if this is an RSA key\n    parsedCredentialPublicKey = {\n      keyType: pubKey?.[1],\n    };\n\n    if (pubKey) {\n      const kty = pubKey.get(COSEKEYS.kty);\n\n      parsedCredentialPublicKey.keyType = coseKeyTypeToString(kty);\n      parsedCredentialPublicKey.algorithm = coseAlgToString(pubKey.get(COSEKEYS.alg));\n\n      if (kty === 3) {\n        // RSA\n        parsedCredentialPublicKey.modulus = base64ToBase64URL(Buffer.from(pubKey.get(COSEKEYS.mod)).toString('base64'));\n        parsedCredentialPublicKey.exponent = parseInt(Buffer.from(pubKey.get(COSEKEYS.exp)).toString('hex'), 16);\n      } else {\n        // Everything else, including EC2 and OKP\n        parsedCredentialPublicKey.curve = pubKey.get(COSEKEYS.crv);\n\n        parsedCredentialPublicKey.x = base64ToBase64URL(Buffer.from(pubKey.get(COSEKEYS.x)).toString('base64'));\n        // y isn't present in OKP certs\n        if (pubKey.get(COSEKEYS.y)) {\n          parsedCredentialPublicKey.y = base64ToBase64URL(Buffer.from(pubKey.get(COSEKEYS.y)).toString('base64'));\n        }\n      }\n    }\n  }\n\n  const toReturn: AuthenticatorData = {\n    rpIdHash: base64ToBase64URL(rpIdHash.toString('base64')),\n    flags,\n    flagsMask: `0x${Buffer.alloc(1).fill(flagsBuf).toString('hex')}`,\n    counter,\n  };\n\n  if (aaguid) {\n    toReturn.aaguid = aaguidToString(aaguid);\n  }\n\n  if (credentialID) {\n    toReturn.credentialID = credentialID;\n  }\n\n  if (credentialPublicKey) {\n    toReturn.credentialPublicKey = credentialPublicKey;\n    toReturn.parsedCredentialPublicKey = parsedCredentialPublicKey;\n  }\n\n  return toReturn;\n}\n\nexport type AuthenticatorData = {\n  rpIdHash: string;\n  flags: {\n    userPresent: boolean;\n    userVerified: boolean;\n    attestedData: boolean;\n    extensionData: boolean;\n  };\n  flagsMask: string;\n  counter: number;\n  aaguid?: string;\n  credentialID?: string;\n  credentialPublicKey?: string;\n  parsedCredentialPublicKey?: ParsedCredentialPublicKey;\n  // extensionsDataBuffer?: Buffer;\n};\n\ntype ParsedCredentialPublicKey = {\n  keyType?: string;\n  algorithm?: string;\n  curve?: number | string;\n  x?: string;\n  y?: string;\n  modulus?: string;\n  exponent?: number;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}