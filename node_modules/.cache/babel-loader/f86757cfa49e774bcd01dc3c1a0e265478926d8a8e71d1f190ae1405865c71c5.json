{"ast":null,"code":"/*!\n * MIT License\n * \n * Copyright (c) 2017-2022 Peculiar Ventures, LLC\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n * \n */\n\n'use strict';\n\nconst ARRAY_BUFFER_NAME = \"[object ArrayBuffer]\";\nclass BufferSourceConverter {\n  static isArrayBuffer(data) {\n    return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;\n  }\n  static toArrayBuffer(data) {\n    if (this.isArrayBuffer(data)) {\n      return data;\n    }\n    if (data.byteLength === data.buffer.byteLength) {\n      return data.buffer;\n    }\n    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n      return data.buffer;\n    }\n    return this.toUint8Array(data.buffer).slice(data.byteOffset, data.byteOffset + data.byteLength).buffer;\n  }\n  static toUint8Array(data) {\n    return this.toView(data, Uint8Array);\n  }\n  static toView(data, type) {\n    if (data.constructor === type) {\n      return data;\n    }\n    if (this.isArrayBuffer(data)) {\n      return new type(data);\n    }\n    if (this.isArrayBufferView(data)) {\n      return new type(data.buffer, data.byteOffset, data.byteLength);\n    }\n    throw new TypeError(\"The provided value is not of type '(ArrayBuffer or ArrayBufferView)'\");\n  }\n  static isBufferSource(data) {\n    return this.isArrayBufferView(data) || this.isArrayBuffer(data);\n  }\n  static isArrayBufferView(data) {\n    return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);\n  }\n  static isEqual(a, b) {\n    const aView = BufferSourceConverter.toUint8Array(a);\n    const bView = BufferSourceConverter.toUint8Array(b);\n    if (aView.length !== bView.byteLength) {\n      return false;\n    }\n    for (let i = 0; i < aView.length; i++) {\n      if (aView[i] !== bView[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  static concat(...args) {\n    let buffers;\n    if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {\n      buffers = args[0];\n    } else if (Array.isArray(args[0]) && args[1] instanceof Function) {\n      buffers = args[0];\n    } else {\n      if (args[args.length - 1] instanceof Function) {\n        buffers = args.slice(0, args.length - 1);\n      } else {\n        buffers = args;\n      }\n    }\n    let size = 0;\n    for (const buffer of buffers) {\n      size += buffer.byteLength;\n    }\n    const res = new Uint8Array(size);\n    let offset = 0;\n    for (const buffer of buffers) {\n      const view = this.toUint8Array(buffer);\n      res.set(view, offset);\n      offset += view.length;\n    }\n    if (args[args.length - 1] instanceof Function) {\n      return this.toView(res, args[args.length - 1]);\n    }\n    return res.buffer;\n  }\n}\nconst STRING_TYPE = \"string\";\nconst HEX_REGEX = /^[0-9a-f]+$/i;\nconst BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;\nconst BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;\nclass Utf8Converter {\n  static fromString(text) {\n    const s = unescape(encodeURIComponent(text));\n    const uintArray = new Uint8Array(s.length);\n    for (let i = 0; i < s.length; i++) {\n      uintArray[i] = s.charCodeAt(i);\n    }\n    return uintArray.buffer;\n  }\n  static toString(buffer) {\n    const buf = BufferSourceConverter.toUint8Array(buffer);\n    let encodedString = \"\";\n    for (let i = 0; i < buf.length; i++) {\n      encodedString += String.fromCharCode(buf[i]);\n    }\n    const decodedString = decodeURIComponent(escape(encodedString));\n    return decodedString;\n  }\n}\nclass Utf16Converter {\n  static toString(buffer, littleEndian = false) {\n    const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);\n    const dataView = new DataView(arrayBuffer);\n    let res = \"\";\n    for (let i = 0; i < arrayBuffer.byteLength; i += 2) {\n      const code = dataView.getUint16(i, littleEndian);\n      res += String.fromCharCode(code);\n    }\n    return res;\n  }\n  static fromString(text, littleEndian = false) {\n    const res = new ArrayBuffer(text.length * 2);\n    const dataView = new DataView(res);\n    for (let i = 0; i < text.length; i++) {\n      dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);\n    }\n    return res;\n  }\n}\nclass Convert {\n  static isHex(data) {\n    return typeof data === STRING_TYPE && HEX_REGEX.test(data);\n  }\n  static isBase64(data) {\n    return typeof data === STRING_TYPE && BASE64_REGEX.test(data);\n  }\n  static isBase64Url(data) {\n    return typeof data === STRING_TYPE && BASE64URL_REGEX.test(data);\n  }\n  static ToString(buffer, enc = \"utf8\") {\n    const buf = BufferSourceConverter.toUint8Array(buffer);\n    switch (enc.toLowerCase()) {\n      case \"utf8\":\n        return this.ToUtf8String(buf);\n      case \"binary\":\n        return this.ToBinary(buf);\n      case \"hex\":\n        return this.ToHex(buf);\n      case \"base64\":\n        return this.ToBase64(buf);\n      case \"base64url\":\n        return this.ToBase64Url(buf);\n      case \"utf16le\":\n        return Utf16Converter.toString(buf, true);\n      case \"utf16\":\n      case \"utf16be\":\n        return Utf16Converter.toString(buf);\n      default:\n        throw new Error(`Unknown type of encoding '${enc}'`);\n    }\n  }\n  static FromString(str, enc = \"utf8\") {\n    if (!str) {\n      return new ArrayBuffer(0);\n    }\n    switch (enc.toLowerCase()) {\n      case \"utf8\":\n        return this.FromUtf8String(str);\n      case \"binary\":\n        return this.FromBinary(str);\n      case \"hex\":\n        return this.FromHex(str);\n      case \"base64\":\n        return this.FromBase64(str);\n      case \"base64url\":\n        return this.FromBase64Url(str);\n      case \"utf16le\":\n        return Utf16Converter.fromString(str, true);\n      case \"utf16\":\n      case \"utf16be\":\n        return Utf16Converter.fromString(str);\n      default:\n        throw new Error(`Unknown type of encoding '${enc}'`);\n    }\n  }\n  static ToBase64(buffer) {\n    const buf = BufferSourceConverter.toUint8Array(buffer);\n    if (typeof btoa !== \"undefined\") {\n      const binary = this.ToString(buf, \"binary\");\n      return btoa(binary);\n    } else {\n      return Buffer.from(buf).toString(\"base64\");\n    }\n  }\n  static FromBase64(base64) {\n    const formatted = this.formatString(base64);\n    if (!formatted) {\n      return new ArrayBuffer(0);\n    }\n    if (!Convert.isBase64(formatted)) {\n      throw new TypeError(\"Argument 'base64Text' is not Base64 encoded\");\n    }\n    if (typeof atob !== \"undefined\") {\n      return this.FromBinary(atob(formatted));\n    } else {\n      return new Uint8Array(Buffer.from(formatted, \"base64\")).buffer;\n    }\n  }\n  static FromBase64Url(base64url) {\n    const formatted = this.formatString(base64url);\n    if (!formatted) {\n      return new ArrayBuffer(0);\n    }\n    if (!Convert.isBase64Url(formatted)) {\n      throw new TypeError(\"Argument 'base64url' is not Base64Url encoded\");\n    }\n    return this.FromBase64(this.Base64Padding(formatted.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\")));\n  }\n  static ToBase64Url(data) {\n    return this.ToBase64(data).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/\\=/g, \"\");\n  }\n  static FromUtf8String(text, encoding = Convert.DEFAULT_UTF8_ENCODING) {\n    switch (encoding) {\n      case \"ascii\":\n        return this.FromBinary(text);\n      case \"utf8\":\n        return Utf8Converter.fromString(text);\n      case \"utf16\":\n      case \"utf16be\":\n        return Utf16Converter.fromString(text);\n      case \"utf16le\":\n      case \"usc2\":\n        return Utf16Converter.fromString(text, true);\n      default:\n        throw new Error(`Unknown type of encoding '${encoding}'`);\n    }\n  }\n  static ToUtf8String(buffer, encoding = Convert.DEFAULT_UTF8_ENCODING) {\n    switch (encoding) {\n      case \"ascii\":\n        return this.ToBinary(buffer);\n      case \"utf8\":\n        return Utf8Converter.toString(buffer);\n      case \"utf16\":\n      case \"utf16be\":\n        return Utf16Converter.toString(buffer);\n      case \"utf16le\":\n      case \"usc2\":\n        return Utf16Converter.toString(buffer, true);\n      default:\n        throw new Error(`Unknown type of encoding '${encoding}'`);\n    }\n  }\n  static FromBinary(text) {\n    const stringLength = text.length;\n    const resultView = new Uint8Array(stringLength);\n    for (let i = 0; i < stringLength; i++) {\n      resultView[i] = text.charCodeAt(i);\n    }\n    return resultView.buffer;\n  }\n  static ToBinary(buffer) {\n    const buf = BufferSourceConverter.toUint8Array(buffer);\n    let res = \"\";\n    for (let i = 0; i < buf.length; i++) {\n      res += String.fromCharCode(buf[i]);\n    }\n    return res;\n  }\n  static ToHex(buffer) {\n    const buf = BufferSourceConverter.toUint8Array(buffer);\n    let result = \"\";\n    const len = buf.length;\n    for (let i = 0; i < len; i++) {\n      const byte = buf[i];\n      if (byte < 16) {\n        result += \"0\";\n      }\n      result += byte.toString(16);\n    }\n    return result;\n  }\n  static FromHex(hexString) {\n    let formatted = this.formatString(hexString);\n    if (!formatted) {\n      return new ArrayBuffer(0);\n    }\n    if (!Convert.isHex(formatted)) {\n      throw new TypeError(\"Argument 'hexString' is not HEX encoded\");\n    }\n    if (formatted.length % 2) {\n      formatted = `0${formatted}`;\n    }\n    const res = new Uint8Array(formatted.length / 2);\n    for (let i = 0; i < formatted.length; i = i + 2) {\n      const c = formatted.slice(i, i + 2);\n      res[i / 2] = parseInt(c, 16);\n    }\n    return res.buffer;\n  }\n  static ToUtf16String(buffer, littleEndian = false) {\n    return Utf16Converter.toString(buffer, littleEndian);\n  }\n  static FromUtf16String(text, littleEndian = false) {\n    return Utf16Converter.fromString(text, littleEndian);\n  }\n  static Base64Padding(base64) {\n    const padCount = 4 - base64.length % 4;\n    if (padCount < 4) {\n      for (let i = 0; i < padCount; i++) {\n        base64 += \"=\";\n      }\n    }\n    return base64;\n  }\n  static formatString(data) {\n    return (data === null || data === void 0 ? void 0 : data.replace(/[\\n\\r\\t ]/g, \"\")) || \"\";\n  }\n}\nConvert.DEFAULT_UTF8_ENCODING = \"utf8\";\nfunction assign(target, ...sources) {\n  const res = arguments[0];\n  for (let i = 1; i < arguments.length; i++) {\n    const obj = arguments[i];\n    for (const prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\nfunction combine(...buf) {\n  const totalByteLength = buf.map(item => item.byteLength).reduce((prev, cur) => prev + cur);\n  const res = new Uint8Array(totalByteLength);\n  let currentPos = 0;\n  buf.map(item => new Uint8Array(item)).forEach(arr => {\n    for (const item2 of arr) {\n      res[currentPos++] = item2;\n    }\n  });\n  return res.buffer;\n}\nfunction isEqual(bytes1, bytes2) {\n  if (!(bytes1 && bytes2)) {\n    return false;\n  }\n  if (bytes1.byteLength !== bytes2.byteLength) {\n    return false;\n  }\n  const b1 = new Uint8Array(bytes1);\n  const b2 = new Uint8Array(bytes2);\n  for (let i = 0; i < bytes1.byteLength; i++) {\n    if (b1[i] !== b2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nexports.BufferSourceConverter = BufferSourceConverter;\nexports.Convert = Convert;\nexports.assign = assign;\nexports.combine = combine;\nexports.isEqual = isEqual;","map":{"version":3,"names":["ARRAY_BUFFER_NAME","BufferSourceConverter","isArrayBuffer","data","Object","prototype","toString","call","toArrayBuffer","byteLength","buffer","byteOffset","toUint8Array","slice","toView","Uint8Array","type","constructor","isArrayBufferView","TypeError","isBufferSource","ArrayBuffer","isView","isEqual","a","b","aView","bView","length","i","concat","args","buffers","Array","isArray","Function","size","res","offset","view","set","STRING_TYPE","HEX_REGEX","BASE64_REGEX","BASE64URL_REGEX","Utf8Converter","fromString","text","s","unescape","encodeURIComponent","uintArray","charCodeAt","buf","encodedString","String","fromCharCode","decodedString","decodeURIComponent","escape","Utf16Converter","littleEndian","arrayBuffer","dataView","DataView","code","getUint16","setUint16","Convert","isHex","test","isBase64","isBase64Url","ToString","enc","toLowerCase","ToUtf8String","ToBinary","ToHex","ToBase64","ToBase64Url","Error","FromString","str","FromUtf8String","FromBinary","FromHex","FromBase64","FromBase64Url","btoa","binary","Buffer","from","base64","formatted","formatString","atob","base64url","Base64Padding","replace","encoding","DEFAULT_UTF8_ENCODING","stringLength","resultView","result","len","byte","hexString","c","parseInt","ToUtf16String","FromUtf16String","padCount","assign","target","sources","arguments","obj","prop","combine","totalByteLength","map","item","reduce","prev","cur","currentPos","forEach","arr","item2","bytes1","bytes2","b1","b2","exports"],"sources":["/Users/peterchen/Dropbox/Hexlink/pwa-demo/node_modules/pvtsutils/build/index.js"],"sourcesContent":["/*!\n * MIT License\n * \n * Copyright (c) 2017-2022 Peculiar Ventures, LLC\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n * \n */\n\n'use strict';\n\nconst ARRAY_BUFFER_NAME = \"[object ArrayBuffer]\";\nclass BufferSourceConverter {\n    static isArrayBuffer(data) {\n        return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;\n    }\n    static toArrayBuffer(data) {\n        if (this.isArrayBuffer(data)) {\n            return data;\n        }\n        if (data.byteLength === data.buffer.byteLength) {\n            return data.buffer;\n        }\n        if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n            return data.buffer;\n        }\n        return this.toUint8Array(data.buffer)\n            .slice(data.byteOffset, data.byteOffset + data.byteLength)\n            .buffer;\n    }\n    static toUint8Array(data) {\n        return this.toView(data, Uint8Array);\n    }\n    static toView(data, type) {\n        if (data.constructor === type) {\n            return data;\n        }\n        if (this.isArrayBuffer(data)) {\n            return new type(data);\n        }\n        if (this.isArrayBufferView(data)) {\n            return new type(data.buffer, data.byteOffset, data.byteLength);\n        }\n        throw new TypeError(\"The provided value is not of type '(ArrayBuffer or ArrayBufferView)'\");\n    }\n    static isBufferSource(data) {\n        return this.isArrayBufferView(data)\n            || this.isArrayBuffer(data);\n    }\n    static isArrayBufferView(data) {\n        return ArrayBuffer.isView(data)\n            || (data && this.isArrayBuffer(data.buffer));\n    }\n    static isEqual(a, b) {\n        const aView = BufferSourceConverter.toUint8Array(a);\n        const bView = BufferSourceConverter.toUint8Array(b);\n        if (aView.length !== bView.byteLength) {\n            return false;\n        }\n        for (let i = 0; i < aView.length; i++) {\n            if (aView[i] !== bView[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static concat(...args) {\n        let buffers;\n        if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {\n            buffers = args[0];\n        }\n        else if (Array.isArray(args[0]) && args[1] instanceof Function) {\n            buffers = args[0];\n        }\n        else {\n            if (args[args.length - 1] instanceof Function) {\n                buffers = args.slice(0, args.length - 1);\n            }\n            else {\n                buffers = args;\n            }\n        }\n        let size = 0;\n        for (const buffer of buffers) {\n            size += buffer.byteLength;\n        }\n        const res = new Uint8Array(size);\n        let offset = 0;\n        for (const buffer of buffers) {\n            const view = this.toUint8Array(buffer);\n            res.set(view, offset);\n            offset += view.length;\n        }\n        if (args[args.length - 1] instanceof Function) {\n            return this.toView(res, args[args.length - 1]);\n        }\n        return res.buffer;\n    }\n}\n\nconst STRING_TYPE = \"string\";\nconst HEX_REGEX = /^[0-9a-f]+$/i;\nconst BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;\nconst BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;\nclass Utf8Converter {\n    static fromString(text) {\n        const s = unescape(encodeURIComponent(text));\n        const uintArray = new Uint8Array(s.length);\n        for (let i = 0; i < s.length; i++) {\n            uintArray[i] = s.charCodeAt(i);\n        }\n        return uintArray.buffer;\n    }\n    static toString(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        let encodedString = \"\";\n        for (let i = 0; i < buf.length; i++) {\n            encodedString += String.fromCharCode(buf[i]);\n        }\n        const decodedString = decodeURIComponent(escape(encodedString));\n        return decodedString;\n    }\n}\nclass Utf16Converter {\n    static toString(buffer, littleEndian = false) {\n        const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);\n        const dataView = new DataView(arrayBuffer);\n        let res = \"\";\n        for (let i = 0; i < arrayBuffer.byteLength; i += 2) {\n            const code = dataView.getUint16(i, littleEndian);\n            res += String.fromCharCode(code);\n        }\n        return res;\n    }\n    static fromString(text, littleEndian = false) {\n        const res = new ArrayBuffer(text.length * 2);\n        const dataView = new DataView(res);\n        for (let i = 0; i < text.length; i++) {\n            dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);\n        }\n        return res;\n    }\n}\nclass Convert {\n    static isHex(data) {\n        return typeof data === STRING_TYPE\n            && HEX_REGEX.test(data);\n    }\n    static isBase64(data) {\n        return typeof data === STRING_TYPE\n            && BASE64_REGEX.test(data);\n    }\n    static isBase64Url(data) {\n        return typeof data === STRING_TYPE\n            && BASE64URL_REGEX.test(data);\n    }\n    static ToString(buffer, enc = \"utf8\") {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        switch (enc.toLowerCase()) {\n            case \"utf8\":\n                return this.ToUtf8String(buf);\n            case \"binary\":\n                return this.ToBinary(buf);\n            case \"hex\":\n                return this.ToHex(buf);\n            case \"base64\":\n                return this.ToBase64(buf);\n            case \"base64url\":\n                return this.ToBase64Url(buf);\n            case \"utf16le\":\n                return Utf16Converter.toString(buf, true);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.toString(buf);\n            default:\n                throw new Error(`Unknown type of encoding '${enc}'`);\n        }\n    }\n    static FromString(str, enc = \"utf8\") {\n        if (!str) {\n            return new ArrayBuffer(0);\n        }\n        switch (enc.toLowerCase()) {\n            case \"utf8\":\n                return this.FromUtf8String(str);\n            case \"binary\":\n                return this.FromBinary(str);\n            case \"hex\":\n                return this.FromHex(str);\n            case \"base64\":\n                return this.FromBase64(str);\n            case \"base64url\":\n                return this.FromBase64Url(str);\n            case \"utf16le\":\n                return Utf16Converter.fromString(str, true);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.fromString(str);\n            default:\n                throw new Error(`Unknown type of encoding '${enc}'`);\n        }\n    }\n    static ToBase64(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        if (typeof btoa !== \"undefined\") {\n            const binary = this.ToString(buf, \"binary\");\n            return btoa(binary);\n        }\n        else {\n            return Buffer.from(buf).toString(\"base64\");\n        }\n    }\n    static FromBase64(base64) {\n        const formatted = this.formatString(base64);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isBase64(formatted)) {\n            throw new TypeError(\"Argument 'base64Text' is not Base64 encoded\");\n        }\n        if (typeof atob !== \"undefined\") {\n            return this.FromBinary(atob(formatted));\n        }\n        else {\n            return new Uint8Array(Buffer.from(formatted, \"base64\")).buffer;\n        }\n    }\n    static FromBase64Url(base64url) {\n        const formatted = this.formatString(base64url);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isBase64Url(formatted)) {\n            throw new TypeError(\"Argument 'base64url' is not Base64Url encoded\");\n        }\n        return this.FromBase64(this.Base64Padding(formatted.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\")));\n    }\n    static ToBase64Url(data) {\n        return this.ToBase64(data).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/\\=/g, \"\");\n    }\n    static FromUtf8String(text, encoding = Convert.DEFAULT_UTF8_ENCODING) {\n        switch (encoding) {\n            case \"ascii\":\n                return this.FromBinary(text);\n            case \"utf8\":\n                return Utf8Converter.fromString(text);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.fromString(text);\n            case \"utf16le\":\n            case \"usc2\":\n                return Utf16Converter.fromString(text, true);\n            default:\n                throw new Error(`Unknown type of encoding '${encoding}'`);\n        }\n    }\n    static ToUtf8String(buffer, encoding = Convert.DEFAULT_UTF8_ENCODING) {\n        switch (encoding) {\n            case \"ascii\":\n                return this.ToBinary(buffer);\n            case \"utf8\":\n                return Utf8Converter.toString(buffer);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.toString(buffer);\n            case \"utf16le\":\n            case \"usc2\":\n                return Utf16Converter.toString(buffer, true);\n            default:\n                throw new Error(`Unknown type of encoding '${encoding}'`);\n        }\n    }\n    static FromBinary(text) {\n        const stringLength = text.length;\n        const resultView = new Uint8Array(stringLength);\n        for (let i = 0; i < stringLength; i++) {\n            resultView[i] = text.charCodeAt(i);\n        }\n        return resultView.buffer;\n    }\n    static ToBinary(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        let res = \"\";\n        for (let i = 0; i < buf.length; i++) {\n            res += String.fromCharCode(buf[i]);\n        }\n        return res;\n    }\n    static ToHex(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        let result = \"\";\n        const len = buf.length;\n        for (let i = 0; i < len; i++) {\n            const byte = buf[i];\n            if (byte < 16) {\n                result += \"0\";\n            }\n            result += byte.toString(16);\n        }\n        return result;\n    }\n    static FromHex(hexString) {\n        let formatted = this.formatString(hexString);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isHex(formatted)) {\n            throw new TypeError(\"Argument 'hexString' is not HEX encoded\");\n        }\n        if (formatted.length % 2) {\n            formatted = `0${formatted}`;\n        }\n        const res = new Uint8Array(formatted.length / 2);\n        for (let i = 0; i < formatted.length; i = i + 2) {\n            const c = formatted.slice(i, i + 2);\n            res[i / 2] = parseInt(c, 16);\n        }\n        return res.buffer;\n    }\n    static ToUtf16String(buffer, littleEndian = false) {\n        return Utf16Converter.toString(buffer, littleEndian);\n    }\n    static FromUtf16String(text, littleEndian = false) {\n        return Utf16Converter.fromString(text, littleEndian);\n    }\n    static Base64Padding(base64) {\n        const padCount = 4 - (base64.length % 4);\n        if (padCount < 4) {\n            for (let i = 0; i < padCount; i++) {\n                base64 += \"=\";\n            }\n        }\n        return base64;\n    }\n    static formatString(data) {\n        return (data === null || data === void 0 ? void 0 : data.replace(/[\\n\\r\\t ]/g, \"\")) || \"\";\n    }\n}\nConvert.DEFAULT_UTF8_ENCODING = \"utf8\";\n\nfunction assign(target, ...sources) {\n    const res = arguments[0];\n    for (let i = 1; i < arguments.length; i++) {\n        const obj = arguments[i];\n        for (const prop in obj) {\n            res[prop] = obj[prop];\n        }\n    }\n    return res;\n}\nfunction combine(...buf) {\n    const totalByteLength = buf.map((item) => item.byteLength).reduce((prev, cur) => prev + cur);\n    const res = new Uint8Array(totalByteLength);\n    let currentPos = 0;\n    buf.map((item) => new Uint8Array(item)).forEach((arr) => {\n        for (const item2 of arr) {\n            res[currentPos++] = item2;\n        }\n    });\n    return res.buffer;\n}\nfunction isEqual(bytes1, bytes2) {\n    if (!(bytes1 && bytes2)) {\n        return false;\n    }\n    if (bytes1.byteLength !== bytes2.byteLength) {\n        return false;\n    }\n    const b1 = new Uint8Array(bytes1);\n    const b2 = new Uint8Array(bytes2);\n    for (let i = 0; i < bytes1.byteLength; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexports.BufferSourceConverter = BufferSourceConverter;\nexports.Convert = Convert;\nexports.assign = assign;\nexports.combine = combine;\nexports.isEqual = isEqual;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}