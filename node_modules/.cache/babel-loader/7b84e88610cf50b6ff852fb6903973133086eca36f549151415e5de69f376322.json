{"ast":null,"code":"'use strict';\n\n/**\n * Record objects that pass by in a stream.  If the same object is used more\n * than once, it can be value-shared using shared values.\n *\n * @see {@link http://cbor.schmorp.de/value-sharing}\n */\nclass ObjectRecorder {\n  constructor() {\n    this.clear();\n  }\n\n  /**\n   * Clear all of the objects that have been seen.  Revert to recording mode.\n   */\n  clear() {\n    this.map = new WeakMap();\n    this.count = 0;\n    this.recording = true;\n  }\n\n  /**\n   * Stop recording.\n   */\n  stop() {\n    this.recording = false;\n  }\n\n  /**\n   * Determine if wrapping a tag 28 or 29 around an object that has been\n   * reused is appropriate.  This method stores state for which objects have\n   * been seen.\n   *\n   * @param {object} obj Any object about to be serialized.\n   * @returns {number} If recording: -1 for first use, index for second use.\n   *   If not recording, -1 for never-duplicated, -2 for first use, index for\n   *   subsequent uses.\n   * @throws {Error} Recording does not match playback.\n   */\n  check(obj) {\n    const val = this.map.get(obj);\n    if (val) {\n      if (val.length > 1) {\n        if (val[0] || this.recording) {\n          return val[1];\n        }\n        val[0] = true;\n        return ObjectRecorder.FIRST;\n      }\n      if (!this.recording) {\n        return ObjectRecorder.NEVER;\n      }\n      val.push(this.count++);\n      // Second use while recording\n      return val[1];\n    }\n    if (!this.recording) {\n      throw new Error('New object detected when not recording');\n    }\n    this.map.set(obj, [false]);\n    // First use while recording\n    return ObjectRecorder.NEVER;\n  }\n}\nObjectRecorder.NEVER = -1;\nObjectRecorder.FIRST = -2;\nmodule.exports = ObjectRecorder;","map":{"version":3,"names":["ObjectRecorder","constructor","clear","map","WeakMap","count","recording","stop","check","obj","val","get","length","FIRST","NEVER","push","Error","set","module","exports"],"sources":["/Users/peterchen/Dropbox/Hexlink/pwa-demo/node_modules/cbor/lib/objectRecorder.js"],"sourcesContent":["'use strict'\n\n/**\n * Record objects that pass by in a stream.  If the same object is used more\n * than once, it can be value-shared using shared values.\n *\n * @see {@link http://cbor.schmorp.de/value-sharing}\n */\nclass ObjectRecorder {\n  constructor() {\n    this.clear()\n  }\n\n  /**\n   * Clear all of the objects that have been seen.  Revert to recording mode.\n   */\n  clear() {\n    this.map = new WeakMap()\n    this.count = 0\n    this.recording = true\n  }\n\n  /**\n   * Stop recording.\n   */\n  stop() {\n    this.recording = false\n  }\n\n  /**\n   * Determine if wrapping a tag 28 or 29 around an object that has been\n   * reused is appropriate.  This method stores state for which objects have\n   * been seen.\n   *\n   * @param {object} obj Any object about to be serialized.\n   * @returns {number} If recording: -1 for first use, index for second use.\n   *   If not recording, -1 for never-duplicated, -2 for first use, index for\n   *   subsequent uses.\n   * @throws {Error} Recording does not match playback.\n   */\n  check(obj) {\n    const val = this.map.get(obj)\n    if (val) {\n      if (val.length > 1) {\n        if (val[0] || this.recording) {\n          return val[1]\n        }\n\n        val[0] = true\n        return ObjectRecorder.FIRST\n      }\n      if (!this.recording) {\n        return ObjectRecorder.NEVER\n      }\n      val.push(this.count++)\n      // Second use while recording\n      return val[1]\n    }\n    if (!this.recording) {\n      throw new Error('New object detected when not recording')\n    }\n    this.map.set(obj, [false])\n    // First use while recording\n    return ObjectRecorder.NEVER\n  }\n}\n\nObjectRecorder.NEVER = -1\nObjectRecorder.FIRST = -2\n\nmodule.exports = ObjectRecorder\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,cAAc,CAAC;EACnBC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,KAAK,CAAC,CAAC;EACd;;EAEA;AACF;AACA;EACEA,KAAKA,CAAA,EAAG;IACN,IAAI,CAACC,GAAG,GAAG,IAAIC,OAAO,CAAC,CAAC;IACxB,IAAI,CAACC,KAAK,GAAG,CAAC;IACd,IAAI,CAACC,SAAS,GAAG,IAAI;EACvB;;EAEA;AACF;AACA;EACEC,IAAIA,CAAA,EAAG;IACL,IAAI,CAACD,SAAS,GAAG,KAAK;EACxB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEE,KAAKA,CAACC,GAAG,EAAE;IACT,MAAMC,GAAG,GAAG,IAAI,CAACP,GAAG,CAACQ,GAAG,CAACF,GAAG,CAAC;IAC7B,IAAIC,GAAG,EAAE;MACP,IAAIA,GAAG,CAACE,MAAM,GAAG,CAAC,EAAE;QAClB,IAAIF,GAAG,CAAC,CAAC,CAAC,IAAI,IAAI,CAACJ,SAAS,EAAE;UAC5B,OAAOI,GAAG,CAAC,CAAC,CAAC;QACf;QAEAA,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI;QACb,OAAOV,cAAc,CAACa,KAAK;MAC7B;MACA,IAAI,CAAC,IAAI,CAACP,SAAS,EAAE;QACnB,OAAON,cAAc,CAACc,KAAK;MAC7B;MACAJ,GAAG,CAACK,IAAI,CAAC,IAAI,CAACV,KAAK,EAAE,CAAC;MACtB;MACA,OAAOK,GAAG,CAAC,CAAC,CAAC;IACf;IACA,IAAI,CAAC,IAAI,CAACJ,SAAS,EAAE;MACnB,MAAM,IAAIU,KAAK,CAAC,wCAAwC,CAAC;IAC3D;IACA,IAAI,CAACb,GAAG,CAACc,GAAG,CAACR,GAAG,EAAE,CAAC,KAAK,CAAC,CAAC;IAC1B;IACA,OAAOT,cAAc,CAACc,KAAK;EAC7B;AACF;AAEAd,cAAc,CAACc,KAAK,GAAG,CAAC,CAAC;AACzBd,cAAc,CAACa,KAAK,GAAG,CAAC,CAAC;AAEzBK,MAAM,CAACC,OAAO,GAAGnB,cAAc"},"metadata":{},"sourceType":"script","externalDependencies":[]}