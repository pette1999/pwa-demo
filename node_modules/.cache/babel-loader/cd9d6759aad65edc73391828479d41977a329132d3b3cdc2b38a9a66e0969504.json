{"ast":null,"code":"'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\nconst INTERNAL_JSON = Symbol('INTERNAL_JSON');\nfunction setBuffersToJSON(obj, fn) {\n  // The data item tagged can be a byte string or any other data item.  In the\n  // latter case, the tag applies to all of the byte string data items\n  // contained in the data item, except for those contained in a nested data\n  // item tagged with an expected conversion.\n  if (utils.isBufferish(obj)) {\n    obj.toJSON = fn;\n  } else if (Array.isArray(obj)) {\n    for (const v of obj) {\n      setBuffersToJSON(v, fn);\n    }\n  } else if (obj && typeof obj === 'object') {\n    // FFS, complexity in the protocol.\n\n    // There's some circular dependency in here.\n    // eslint-disable-next-line no-use-before-define\n    if (!(obj instanceof Tagged) || obj.tag < 21 || obj.tag > 23) {\n      for (const v of Object.values(obj)) {\n        setBuffersToJSON(v, fn);\n      }\n    }\n  }\n}\nfunction b64this() {\n  // eslint-disable-next-line no-invalid-this\n  return utils.base64(this);\n}\nfunction b64urlThis() {\n  // eslint-disable-next-line no-invalid-this\n  return utils.base64url(this);\n}\nfunction hexThis() {\n  // eslint-disable-next-line no-invalid-this\n  return this.toString('hex');\n}\nfunction swapEndian(ab, size, byteOffset, byteLength) {\n  const dv = new DataView(ab);\n  const [getter, setter] = {\n    2: [dv.getUint16, dv.setUint16],\n    4: [dv.getUint32, dv.setUint32],\n    8: [dv.getBigUint64, dv.setBigUint64]\n  }[size];\n  const end = byteOffset + byteLength;\n  for (let offset = byteOffset; offset < end; offset += size) {\n    setter.call(dv, offset, getter.call(dv, offset, true));\n  }\n}\n\n/**\n * Convert a tagged value to a more interesting JavaScript type.  Errors\n * thrown in this function will be captured into the \"err\" property of the\n * original Tagged instance.\n *\n * @callback TagFunction\n * @param {any} value The value inside the tag.\n * @param {Tagged} tag The enclosing Tagged instance; useful if you want to\n *   modify it and return it.  Also available as \"this\".\n * @returns {any} The transformed value.\n */\n\n/* eslint-disable jsdoc/check-types */\n/**\n * A mapping from tag number to a tag decoding function.\n *\n * @typedef {Object.<string, TagFunction>} TagMap\n */\n/* eslint-enable jsdoc/check-types */\n\n/**\n * @type {TagMap}\n * @private\n */\nconst TAGS = {\n  // Standard date/time string; see Section 3.4.1\n  0: v => new Date(v),\n  // Epoch-based date/time; see Section 3.4.2\n  1: v => new Date(v * 1000),\n  // Positive bignum; see Section 3.4.3\n  2: v => utils.bufferToBigInt(v),\n  // Negative bignum; see Section 3.4.3\n  3: v => constants.BI.MINUS_ONE - utils.bufferToBigInt(v),\n  // Expected conversion to base64url encoding; see Section 3.4.5.2\n  21: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = b64urlThis;\n    } else {\n      setBuffersToJSON(v, b64urlThis);\n    }\n    return tag;\n  },\n  // Expected conversion to base64 encoding; see Section 3.4.5.2\n  22: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = b64this;\n    } else {\n      setBuffersToJSON(v, b64this);\n    }\n    return tag;\n  },\n  // Expected conversion to base16 encoding; see Section Section 3.4.5.2\n  23: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = hexThis;\n    } else {\n      setBuffersToJSON(v, hexThis);\n    }\n    return tag;\n  },\n  // URI; see Section 3.4.5.3\n  32: v => new URL(v),\n  // Base64url; see Section 3.4.5.3\n  33: (v, tag) => {\n    // If any of the following apply:\n    // -  the encoded text string contains non-alphabet characters or\n    //    only 1 alphabet character in the last block of 4 (where\n    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33\n    //    and Section 4 of [RFC4648] for tag number 34), or\n    if (!v.match(/^[a-zA-Z0-9_-]+$/)) {\n      throw new Error('Invalid base64url characters');\n    }\n    const last = v.length % 4;\n    if (last === 1) {\n      throw new Error('Invalid base64url length');\n    }\n    // -  the padding bits in a 2- or 3-character block are not 0, or\n    if (last === 2) {\n      // The last 4 bits of the last character need to be zero.\n      if ('AQgw'.indexOf(v[v.length - 1]) === -1) {\n        throw new Error('Invalid base64 padding');\n      }\n    } else if (last === 3) {\n      // The last 2 bits of the last character need to be zero.\n      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 1]) === -1) {\n        throw new Error('Invalid base64 padding');\n      }\n    }\n\n    //    Or\n    // -  the base64url encoding has padding characters,\n    // (caught above)\n\n    // the string is invalid.\n    return tag;\n  },\n  // Base64; see Section 3.4.5.3\n  34: (v, tag) => {\n    // If any of the following apply:\n    // -  the encoded text string contains non-alphabet characters or\n    //    only 1 alphabet character in the last block of 4 (where\n    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33\n    //    and Section 4 of [RFC4648] for tag number 34), or\n    const m = v.match(/^[a-zA-Z0-9+/]+(?<padding>={0,2})$/);\n    if (!m) {\n      throw new Error('Invalid base64 characters');\n    }\n    if (v.length % 4 !== 0) {\n      throw new Error('Invalid base64 length');\n    }\n    // -  the padding bits in a 2- or 3-character block are not 0, or\n    if (m.groups.padding === '=') {\n      // The last 4 bits of the last character need to be zero.\n      if ('AQgw'.indexOf(v[v.length - 2]) === -1) {\n        throw new Error('Invalid base64 padding');\n      }\n    } else if (m.groups.padding === '==') {\n      // The last 2 bits of the last character need to be zero.\n      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 3]) === -1) {\n        throw new Error('Invalid base64 padding');\n      }\n    }\n\n    // -  the base64 encoding has the wrong number of padding characters,\n    // (caught above)\n    // the string is invalid.\n    return tag;\n  },\n  // Regular expression; see Section 2.4.4.3\n  35: v => new RegExp(v),\n  // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n  258: v => new Set(v)\n};\nconst TYPED_ARRAY_TAGS = {\n  64: Uint8Array,\n  65: Uint16Array,\n  66: Uint32Array,\n  // 67: BigUint64Array,  Safari doesn't implement\n  68: Uint8ClampedArray,\n  69: Uint16Array,\n  70: Uint32Array,\n  // 71: BigUint64Array,  Safari doesn't implement\n  72: Int8Array,\n  73: Int16Array,\n  74: Int32Array,\n  // 75: BigInt64Array,  Safari doesn't implement\n  // 76: reserved\n  77: Int16Array,\n  78: Int32Array,\n  // 79: BigInt64Array,  Safari doesn't implement\n  // 80: not implemented, float16 array\n  81: Float32Array,\n  82: Float64Array,\n  // 83: not implemented, float128 array\n  // 84: not implemented, float16 array\n  85: Float32Array,\n  86: Float64Array\n  // 87: not implemented, float128 array\n};\n\n// Safari\nif (typeof BigUint64Array !== 'undefined') {\n  TYPED_ARRAY_TAGS[67] = BigUint64Array;\n  TYPED_ARRAY_TAGS[71] = BigUint64Array;\n}\nif (typeof BigInt64Array !== 'undefined') {\n  TYPED_ARRAY_TAGS[75] = BigInt64Array;\n  TYPED_ARRAY_TAGS[79] = BigInt64Array;\n}\nfunction _toTypedArray(val, tagged) {\n  if (!utils.isBufferish(val)) {\n    throw new TypeError('val not a buffer');\n  }\n  const {\n    tag\n  } = tagged;\n  // See https://tools.ietf.org/html/rfc8746\n  const TypedClass = TYPED_ARRAY_TAGS[tag];\n  if (!TypedClass) {\n    throw new Error(`Invalid typed array tag: ${tag}`);\n  }\n  const little = tag & 0b00000100;\n  const float = (tag & 0b00010000) >> 4;\n  const sz = 2 ** (float + (tag & 0b00000011));\n  if (!little !== utils.isBigEndian() && sz > 1) {\n    swapEndian(val.buffer, sz, val.byteOffset, val.byteLength);\n  }\n  const ab = val.buffer.slice(val.byteOffset, val.byteOffset + val.byteLength);\n  return new TypedClass(ab);\n}\nfor (const n of Object.keys(TYPED_ARRAY_TAGS)) {\n  TAGS[n] = _toTypedArray;\n}\n\n/**\n * @type {TagMap}\n * @private\n */\nlet current_TAGS = {};\n\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\nclass Tagged {\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {number} tag The number of the tag.\n   * @param {any} value The value inside the tag.\n   * @param {Error} [err] The error that was thrown parsing the tag, or null.\n   */\n  constructor(tag, value, err) {\n    this.tag = tag;\n    this.value = value;\n    this.err = err;\n    if (typeof this.tag !== 'number') {\n      throw new Error(`Invalid tag type (${typeof this.tag})`);\n    }\n    if (this.tag < 0 || (this.tag | 0) !== this.tag) {\n      throw new Error(`Tag must be a positive integer: ${this.tag}`);\n    }\n  }\n  toJSON() {\n    if (this[INTERNAL_JSON]) {\n      return this[INTERNAL_JSON].call(this.value);\n    }\n    const ret = {\n      tag: this.tag,\n      value: this.value\n    };\n    if (this.err) {\n      ret.err = this.err;\n    }\n    return ret;\n  }\n\n  /**\n   * Convert to a String.\n   *\n   * @returns {string} String of the form '1(2)'.\n   */\n  toString() {\n    return `${this.tag}(${JSON.stringify(this.value)})`;\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    gen._pushTag(this.tag);\n    return gen.pushAny(this.value);\n  }\n\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {object} converters Keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} The converted item.\n   */\n  convert(converters) {\n    let f = converters == null ? undefined : converters[this.tag];\n    if (f === null) {\n      // === is intentional. null has semantic meaning as above\n      return this;\n    }\n    if (typeof f !== 'function') {\n      f = Tagged.TAGS[this.tag];\n      if (typeof f !== 'function') {\n        return this;\n      }\n    }\n    try {\n      return f.call(this, this.value, this);\n    } catch (error) {\n      if (error && error.message && error.message.length > 0) {\n        this.err = error.message;\n      } else {\n        this.err = error;\n      }\n      return this;\n    }\n  }\n\n  /**\n   * The current set of supported tags.  May be modified by plugins.\n   *\n   * @type {TagMap}\n   * @static\n   */\n  static get TAGS() {\n    return current_TAGS;\n  }\n  static set TAGS(val) {\n    current_TAGS = val;\n  }\n\n  /**\n   * Reset the supported tags to the original set, before any plugins modified\n   * the list.\n   */\n  static reset() {\n    Tagged.TAGS = {\n      ...TAGS\n    };\n  }\n}\nTagged.INTERNAL_JSON = INTERNAL_JSON;\nTagged.reset();\nmodule.exports = Tagged;","map":{"version":3,"names":["constants","require","utils","INTERNAL_JSON","Symbol","setBuffersToJSON","obj","fn","isBufferish","toJSON","Array","isArray","v","Tagged","tag","Object","values","b64this","base64","b64urlThis","base64url","hexThis","toString","swapEndian","ab","size","byteOffset","byteLength","dv","DataView","getter","setter","getUint16","setUint16","getUint32","setUint32","getBigUint64","setBigUint64","end","offset","call","TAGS","Date","bufferToBigInt","BI","MINUS_ONE","URL","match","Error","last","length","indexOf","m","groups","padding","RegExp","Set","TYPED_ARRAY_TAGS","Uint8Array","Uint16Array","Uint32Array","Uint8ClampedArray","Int8Array","Int16Array","Int32Array","Float32Array","Float64Array","BigUint64Array","BigInt64Array","_toTypedArray","val","tagged","TypeError","TypedClass","little","float","sz","isBigEndian","buffer","slice","n","keys","current_TAGS","constructor","value","err","ret","JSON","stringify","encodeCBOR","gen","_pushTag","pushAny","convert","converters","f","undefined","error","message","reset","module","exports"],"sources":["/Users/peterchen/Dropbox/Hexlink/pwa-demo/node_modules/cbor/lib/tagged.js"],"sourcesContent":["'use strict'\n\nconst constants = require('./constants')\nconst utils = require('./utils')\nconst INTERNAL_JSON = Symbol('INTERNAL_JSON')\n\nfunction setBuffersToJSON(obj, fn) {\n  // The data item tagged can be a byte string or any other data item.  In the\n  // latter case, the tag applies to all of the byte string data items\n  // contained in the data item, except for those contained in a nested data\n  // item tagged with an expected conversion.\n  if (utils.isBufferish(obj)) {\n    obj.toJSON = fn\n  } else if (Array.isArray(obj)) {\n    for (const v of obj) {\n      setBuffersToJSON(v, fn)\n    }\n  } else if (obj && (typeof obj === 'object')) {\n    // FFS, complexity in the protocol.\n\n    // There's some circular dependency in here.\n    // eslint-disable-next-line no-use-before-define\n    if (!(obj instanceof Tagged) || (obj.tag < 21) || (obj.tag > 23)) {\n      for (const v of Object.values(obj)) {\n        setBuffersToJSON(v, fn)\n      }\n    }\n  }\n}\n\nfunction b64this() {\n  // eslint-disable-next-line no-invalid-this\n  return utils.base64(this)\n}\n\nfunction b64urlThis() {\n  // eslint-disable-next-line no-invalid-this\n  return utils.base64url(this)\n}\n\nfunction hexThis() {\n  // eslint-disable-next-line no-invalid-this\n  return this.toString('hex')\n}\n\nfunction swapEndian(ab, size, byteOffset, byteLength) {\n  const dv = new DataView(ab)\n  const [getter, setter] = {\n    2: [dv.getUint16, dv.setUint16],\n    4: [dv.getUint32, dv.setUint32],\n    8: [dv.getBigUint64, dv.setBigUint64],\n  }[size]\n\n  const end = byteOffset + byteLength\n  for (let offset = byteOffset; offset < end; offset += size) {\n    setter.call(dv, offset, getter.call(dv, offset, true))\n  }\n}\n\n/**\n * Convert a tagged value to a more interesting JavaScript type.  Errors\n * thrown in this function will be captured into the \"err\" property of the\n * original Tagged instance.\n *\n * @callback TagFunction\n * @param {any} value The value inside the tag.\n * @param {Tagged} tag The enclosing Tagged instance; useful if you want to\n *   modify it and return it.  Also available as \"this\".\n * @returns {any} The transformed value.\n */\n\n/* eslint-disable jsdoc/check-types */\n/**\n * A mapping from tag number to a tag decoding function.\n *\n * @typedef {Object.<string, TagFunction>} TagMap\n */\n/* eslint-enable jsdoc/check-types */\n\n/**\n * @type {TagMap}\n * @private\n */\nconst TAGS = {\n  // Standard date/time string; see Section 3.4.1\n  0: v => new Date(v),\n  // Epoch-based date/time; see Section 3.4.2\n  1: v => new Date(v * 1000),\n  // Positive bignum; see Section 3.4.3\n  2: v => utils.bufferToBigInt(v),\n  // Negative bignum; see Section 3.4.3\n  3: v => constants.BI.MINUS_ONE - utils.bufferToBigInt(v),\n  // Expected conversion to base64url encoding; see Section 3.4.5.2\n  21: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = b64urlThis\n    } else {\n      setBuffersToJSON(v, b64urlThis)\n    }\n    return tag\n  },\n  // Expected conversion to base64 encoding; see Section 3.4.5.2\n  22: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = b64this\n    } else {\n      setBuffersToJSON(v, b64this)\n    }\n    return tag\n  },\n  // Expected conversion to base16 encoding; see Section Section 3.4.5.2\n  23: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = hexThis\n    } else {\n      setBuffersToJSON(v, hexThis)\n    }\n    return tag\n  },\n  // URI; see Section 3.4.5.3\n  32: v => new URL(v),\n  // Base64url; see Section 3.4.5.3\n  33: (v, tag) => {\n    // If any of the following apply:\n    // -  the encoded text string contains non-alphabet characters or\n    //    only 1 alphabet character in the last block of 4 (where\n    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33\n    //    and Section 4 of [RFC4648] for tag number 34), or\n    if (!v.match(/^[a-zA-Z0-9_-]+$/)) {\n      throw new Error('Invalid base64url characters')\n    }\n    const last = v.length % 4\n    if (last === 1) {\n      throw new Error('Invalid base64url length')\n    }\n    // -  the padding bits in a 2- or 3-character block are not 0, or\n    if (last === 2) {\n      // The last 4 bits of the last character need to be zero.\n      if ('AQgw'.indexOf(v[v.length - 1]) === -1) {\n        throw new Error('Invalid base64 padding')\n      }\n    } else if (last === 3) {\n      // The last 2 bits of the last character need to be zero.\n      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 1]) === -1) {\n        throw new Error('Invalid base64 padding')\n      }\n    }\n\n    //    Or\n    // -  the base64url encoding has padding characters,\n    // (caught above)\n\n    // the string is invalid.\n    return tag\n  },\n  // Base64; see Section 3.4.5.3\n  34: (v, tag) => {\n    // If any of the following apply:\n    // -  the encoded text string contains non-alphabet characters or\n    //    only 1 alphabet character in the last block of 4 (where\n    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33\n    //    and Section 4 of [RFC4648] for tag number 34), or\n    const m = v.match(/^[a-zA-Z0-9+/]+(?<padding>={0,2})$/)\n    if (!m) {\n      throw new Error('Invalid base64 characters')\n    }\n    if ((v.length % 4) !== 0) {\n      throw new Error('Invalid base64 length')\n    }\n    // -  the padding bits in a 2- or 3-character block are not 0, or\n    if (m.groups.padding === '=') {\n      // The last 4 bits of the last character need to be zero.\n      if ('AQgw'.indexOf(v[v.length - 2]) === -1) {\n        throw new Error('Invalid base64 padding')\n      }\n    } else if (m.groups.padding === '==') {\n      // The last 2 bits of the last character need to be zero.\n      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 3]) === -1) {\n        throw new Error('Invalid base64 padding')\n      }\n    }\n\n    // -  the base64 encoding has the wrong number of padding characters,\n    // (caught above)\n    // the string is invalid.\n    return tag\n  },\n  // Regular expression; see Section 2.4.4.3\n  35: v => new RegExp(v),\n  // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n  258: v => new Set(v),\n}\n\nconst TYPED_ARRAY_TAGS = {\n  64: Uint8Array,\n  65: Uint16Array,\n  66: Uint32Array,\n  // 67: BigUint64Array,  Safari doesn't implement\n  68: Uint8ClampedArray,\n  69: Uint16Array,\n  70: Uint32Array,\n  // 71: BigUint64Array,  Safari doesn't implement\n  72: Int8Array,\n  73: Int16Array,\n  74: Int32Array,\n  // 75: BigInt64Array,  Safari doesn't implement\n  // 76: reserved\n  77: Int16Array,\n  78: Int32Array,\n  // 79: BigInt64Array,  Safari doesn't implement\n  // 80: not implemented, float16 array\n  81: Float32Array,\n  82: Float64Array,\n  // 83: not implemented, float128 array\n  // 84: not implemented, float16 array\n  85: Float32Array,\n  86: Float64Array,\n  // 87: not implemented, float128 array\n}\n\n// Safari\nif (typeof BigUint64Array !== 'undefined') {\n  TYPED_ARRAY_TAGS[67] = BigUint64Array\n  TYPED_ARRAY_TAGS[71] = BigUint64Array\n}\nif (typeof BigInt64Array !== 'undefined') {\n  TYPED_ARRAY_TAGS[75] = BigInt64Array\n  TYPED_ARRAY_TAGS[79] = BigInt64Array\n}\n\nfunction _toTypedArray(val, tagged) {\n  if (!utils.isBufferish(val)) {\n    throw new TypeError('val not a buffer')\n  }\n  const {tag} = tagged\n  // See https://tools.ietf.org/html/rfc8746\n  const TypedClass = TYPED_ARRAY_TAGS[tag]\n  if (!TypedClass) {\n    throw new Error(`Invalid typed array tag: ${tag}`)\n  }\n  const little = tag & 0b00000100\n  const float = (tag & 0b00010000) >> 4\n  const sz = 2 ** (float + (tag & 0b00000011))\n\n  if ((!little !== utils.isBigEndian()) && (sz > 1)) {\n    swapEndian(val.buffer, sz, val.byteOffset, val.byteLength)\n  }\n\n  const ab = val.buffer.slice(val.byteOffset, val.byteOffset + val.byteLength)\n  return new TypedClass(ab)\n}\n\nfor (const n of Object.keys(TYPED_ARRAY_TAGS)) {\n  TAGS[n] = _toTypedArray\n}\n\n/**\n * @type {TagMap}\n * @private\n */\nlet current_TAGS = {}\n\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\nclass Tagged {\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {number} tag The number of the tag.\n   * @param {any} value The value inside the tag.\n   * @param {Error} [err] The error that was thrown parsing the tag, or null.\n   */\n  constructor(tag, value, err) {\n    this.tag = tag\n    this.value = value\n    this.err = err\n    if (typeof this.tag !== 'number') {\n      throw new Error(`Invalid tag type (${typeof this.tag})`)\n    }\n    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {\n      throw new Error(`Tag must be a positive integer: ${this.tag}`)\n    }\n  }\n\n  toJSON() {\n    if (this[INTERNAL_JSON]) {\n      return this[INTERNAL_JSON].call(this.value)\n    }\n    const ret = {\n      tag: this.tag,\n      value: this.value,\n    }\n    if (this.err) {\n      ret.err = this.err\n    }\n    return ret\n  }\n\n  /**\n   * Convert to a String.\n   *\n   * @returns {string} String of the form '1(2)'.\n   */\n  toString() {\n    return `${this.tag}(${JSON.stringify(this.value)})`\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    gen._pushTag(this.tag)\n    return gen.pushAny(this.value)\n  }\n\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {object} converters Keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} The converted item.\n   */\n  convert(converters) {\n    let f = (converters == null) ? undefined : converters[this.tag]\n    if (f === null) { // === is intentional. null has semantic meaning as above\n      return this\n    }\n    if (typeof f !== 'function') {\n      f = Tagged.TAGS[this.tag]\n      if (typeof f !== 'function') {\n        return this\n      }\n    }\n    try {\n      return f.call(this, this.value, this)\n    } catch (error) {\n      if (error && error.message && (error.message.length > 0)) {\n        this.err = error.message\n      } else {\n        this.err = error\n      }\n      return this\n    }\n  }\n\n  /**\n   * The current set of supported tags.  May be modified by plugins.\n   *\n   * @type {TagMap}\n   * @static\n   */\n  static get TAGS() {\n    return current_TAGS\n  }\n\n  static set TAGS(val) {\n    current_TAGS = val\n  }\n\n  /**\n   * Reset the supported tags to the original set, before any plugins modified\n   * the list.\n   */\n  static reset() {\n    Tagged.TAGS = {...TAGS}\n  }\n}\nTagged.INTERNAL_JSON = INTERNAL_JSON\nTagged.reset()\nmodule.exports = Tagged\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}