{"ast":null,"code":"import { decode } from \"utils/passkey/shared/cbor\";\nimport { Buffer } from 'buffer';\nimport { base64ToBase64URL } from './base64ToBase64URL';\nimport { aaguidToString } from './aaguidToString';\nimport { coseKeyTypeToString } from './coseKeyTypeToString';\nimport { coseAlgToString } from './coseAlgToString';\nvar COSEKEYS = /*#__PURE__*/function (COSEKEYS) {\n  COSEKEYS[COSEKEYS[\"kty\"] = 1] = \"kty\";\n  COSEKEYS[COSEKEYS[\"alg\"] = 3] = \"alg\";\n  COSEKEYS[COSEKEYS[\"crv\"] = -1] = \"crv\";\n  COSEKEYS[COSEKEYS[\"x\"] = -2] = \"x\";\n  COSEKEYS[COSEKEYS[\"y\"] = -3] = \"y\";\n  COSEKEYS[COSEKEYS[\"mod\"] = -1] = \"mod\";\n  COSEKEYS[COSEKEYS[\"exp\"] = -2] = \"exp\";\n  return COSEKEYS;\n}(COSEKEYS || {});\nfunction toArrayBuffer(buffer) {\n  var ab = new ArrayBuffer(buffer.length);\n  var view = new Uint8Array(ab);\n  for (var i = 0; i < buffer.length; ++i) {\n    view[i] = buffer[i];\n  }\n  return ab;\n}\nexport function parseAuthData(authData) {\n  let buffer = Buffer.from(authData);\n  // const cbor = require('cbor');\n\n  const rpIdHash = buffer.slice(0, 32);\n  buffer = buffer.slice(32);\n  const flagsBuf = buffer.slice(0, 1);\n  buffer = buffer.slice(1);\n  const flagsInt = flagsBuf[0];\n  const flags = {\n    userPresent: !!(flagsInt & 1 << 0),\n    // User Presence\n    userVerified: !!(flagsInt & 1 << 2),\n    // User Verified\n    backupEligible: !!(flagsInt & 1 << 3),\n    // Backup Eligibility\n    backupStatus: !!(flagsInt & 1 << 4),\n    // Backup State\n    attestedData: !!(flagsInt & 1 << 6),\n    // Attested Credential Data Present\n    extensionData: !!(flagsInt & 1 << 7) // Extension Data Present\n  };\n\n  const counterBuf = buffer.slice(0, 4);\n  buffer = buffer.slice(4);\n  const counter = counterBuf.readUInt32BE(0);\n  let aaguid = undefined;\n  let credentialID = undefined;\n  let credentialPublicKey = undefined;\n  let parsedCredentialPublicKey = undefined;\n  if (flags.attestedData) {\n    aaguid = buffer.slice(0, 16);\n    buffer = buffer.slice(16);\n    const credIDLenBuf = buffer.slice(0, 2);\n    buffer = buffer.slice(2);\n    const credIDLen = credIDLenBuf.readUInt16BE(0);\n    const credentialIDBuffer = buffer.slice(0, credIDLen);\n    buffer = buffer.slice(credIDLen);\n\n    // Base64 to Base64URL\n    credentialID = base64ToBase64URL(credentialIDBuffer.toString('base64'));\n    credentialPublicKey = base64ToBase64URL(buffer.toString('base64'));\n    console.log(buffer);\n    console.log(buffer.toString('base64'));\n    const pubKey = decode(toArrayBuffer(buffer));\n    console.log(pubKey);\n\n    // TODO: Handle this differently if this is an RSA key\n    parsedCredentialPublicKey = {\n      keyType: pubKey === null || pubKey === void 0 ? void 0 : pubKey[1]\n    };\n    console.log(\"parsedCredentialPublicKey: \", parsedCredentialPublicKey);\n    if (pubKey) {\n      const kty = pubKey === null || pubKey === void 0 ? void 0 : pubKey[COSEKEYS.kty];\n      parsedCredentialPublicKey.keyType = coseKeyTypeToString(kty);\n      parsedCredentialPublicKey.algorithm = coseAlgToString(pubKey === null || pubKey === void 0 ? void 0 : pubKey[COSEKEYS.alg]);\n      if (kty === 3) {\n        // RSA\n        parsedCredentialPublicKey.modulus = base64ToBase64URL(Buffer.from(pubKey.get(COSEKEYS.mod)).toString('base64'));\n        parsedCredentialPublicKey.exponent = parseInt(Buffer.from(pubKey.get(COSEKEYS.exp)).toString('hex'), 16);\n      } else {\n        // Everything else, including EC2 and OKP\n        parsedCredentialPublicKey.curve = pubKey.get(COSEKEYS.crv);\n        parsedCredentialPublicKey.x = base64ToBase64URL(Buffer.from(pubKey.get(COSEKEYS.x)).toString('base64'));\n        // y isn't present in OKP certs\n        if (pubKey.get(COSEKEYS.y)) {\n          parsedCredentialPublicKey.y = base64ToBase64URL(Buffer.from(pubKey.get(COSEKEYS.y)).toString('base64'));\n        }\n      }\n    }\n  }\n  const toReturn = {\n    rpIdHash: base64ToBase64URL(rpIdHash.toString('base64')),\n    flags,\n    flagsMask: `0x${Buffer.alloc(1).fill(flagsBuf).toString('hex')}`,\n    counter\n  };\n  if (aaguid) {\n    toReturn.aaguid = aaguidToString(aaguid);\n  }\n  if (credentialID) {\n    toReturn.credentialID = credentialID;\n  }\n  if (credentialPublicKey) {\n    toReturn.credentialPublicKey = credentialPublicKey;\n    toReturn.parsedCredentialPublicKey = parsedCredentialPublicKey;\n  }\n  return toReturn;\n}","map":{"version":3,"names":["decode","Buffer","base64ToBase64URL","aaguidToString","coseKeyTypeToString","coseAlgToString","COSEKEYS","toArrayBuffer","buffer","ab","ArrayBuffer","length","view","Uint8Array","i","parseAuthData","authData","from","rpIdHash","slice","flagsBuf","flagsInt","flags","userPresent","userVerified","backupEligible","backupStatus","attestedData","extensionData","counterBuf","counter","readUInt32BE","aaguid","undefined","credentialID","credentialPublicKey","parsedCredentialPublicKey","credIDLenBuf","credIDLen","readUInt16BE","credentialIDBuffer","toString","console","log","pubKey","keyType","kty","algorithm","alg","modulus","get","mod","exponent","parseInt","exp","curve","crv","x","y","toReturn","flagsMask","alloc","fill"],"sources":["/Users/peterchen/Dropbox/Hexlink/pwa-demo/src/utils/passkey/shared/parseAuthData.ts"],"sourcesContent":["import { encode, decode } from \"utils/passkey/shared/cbor\";\nimport { Buffer } from 'buffer';\nimport { base64ToBase64URL } from './base64ToBase64URL';\nimport { aaguidToString } from './aaguidToString';\nimport { coseKeyTypeToString } from './coseKeyTypeToString';\nimport { coseAlgToString } from './coseAlgToString';\n\nenum COSEKEYS {\n  kty = 1,\n  alg = 3,\n  crv = -1,\n  x = -2,\n  y = -3,\n  // RSA\n  mod = -1,\n  exp = -2,\n}\n\nfunction toArrayBuffer(buffer: Buffer) {\n  var ab = new ArrayBuffer(buffer.length);\n  var view = new Uint8Array(ab);\n  for (var i = 0; i < buffer.length; ++i) {\n    view[i] = buffer[i];\n  }\n  return ab;\n}\n\nexport function parseAuthData(authData: ArrayBuffer): AuthenticatorData {\n  let buffer = Buffer.from(authData);\n  // const cbor = require('cbor');\n\n  const rpIdHash = buffer.slice(0, 32);\n  buffer = buffer.slice(32);\n\n  const flagsBuf = buffer.slice(0, 1);\n  buffer = buffer.slice(1);\n\n  const flagsInt: number = flagsBuf[0];\n\n  const flags = {\n    userPresent: !!(flagsInt & (1 << 0)), // User Presence\n    userVerified: !!(flagsInt & (1 << 2)), // User Verified\n    backupEligible: !!(flagsInt & (1 << 3)), // Backup Eligibility\n    backupStatus: !!(flagsInt & (1 << 4)), // Backup State\n    attestedData: !!(flagsInt & (1 << 6)), // Attested Credential Data Present\n    extensionData: !!(flagsInt & (1 << 7)), // Extension Data Present\n  };\n\n  const counterBuf = buffer.slice(0, 4);\n  buffer = buffer.slice(4);\n\n  const counter = counterBuf.readUInt32BE(0);\n\n  let aaguid: Buffer | undefined = undefined;\n  let credentialID: string | undefined = undefined;\n  let credentialPublicKey: string | undefined = undefined;\n  let parsedCredentialPublicKey: ParsedCredentialPublicKey | undefined = undefined;\n\n  if (flags.attestedData) {\n    aaguid = buffer.slice(0, 16);\n    buffer = buffer.slice(16);\n\n    const credIDLenBuf = buffer.slice(0, 2);\n    buffer = buffer.slice(2);\n\n    const credIDLen = credIDLenBuf.readUInt16BE(0);\n    const credentialIDBuffer = buffer.slice(0, credIDLen);\n    buffer = buffer.slice(credIDLen);\n\n    // Base64 to Base64URL\n    credentialID = base64ToBase64URL(credentialIDBuffer.toString('base64'));\n    credentialPublicKey = base64ToBase64URL(buffer.toString('base64'));\n    console.log(buffer);\n    console.log(buffer.toString('base64'));\n\n    const pubKey = decode(toArrayBuffer(buffer));\n    console.log(pubKey);\n\n    // TODO: Handle this differently if this is an RSA key\n    parsedCredentialPublicKey = {\n      keyType: pubKey?.[1],\n    };\n    console.log(\"parsedCredentialPublicKey: \", parsedCredentialPublicKey);\n\n    if (pubKey) {\n      const kty = pubKey?.[COSEKEYS.kty];\n\n      parsedCredentialPublicKey.keyType = coseKeyTypeToString(kty);\n      parsedCredentialPublicKey.algorithm = coseAlgToString(pubKey?.[COSEKEYS.alg]);\n\n      if (kty === 3) {\n        // RSA\n        parsedCredentialPublicKey.modulus = base64ToBase64URL(Buffer.from(pubKey.get(COSEKEYS.mod)).toString('base64'));\n        parsedCredentialPublicKey.exponent = parseInt(Buffer.from(pubKey.get(COSEKEYS.exp)).toString('hex'), 16);\n      } else {\n        // Everything else, including EC2 and OKP\n        parsedCredentialPublicKey.curve = pubKey.get(COSEKEYS.crv);\n\n        parsedCredentialPublicKey.x = base64ToBase64URL(Buffer.from(pubKey.get(COSEKEYS.x)).toString('base64'));\n        // y isn't present in OKP certs\n        if (pubKey.get(COSEKEYS.y)) {\n          parsedCredentialPublicKey.y = base64ToBase64URL(Buffer.from(pubKey.get(COSEKEYS.y)).toString('base64'));\n        }\n      }\n    }\n  }\n\n  const toReturn: AuthenticatorData = {\n    rpIdHash: base64ToBase64URL(rpIdHash.toString('base64')),\n    flags,\n    flagsMask: `0x${Buffer.alloc(1).fill(flagsBuf).toString('hex')}`,\n    counter,\n  };\n\n  if (aaguid) {\n    toReturn.aaguid = aaguidToString(aaguid);\n  }\n\n  if (credentialID) {\n    toReturn.credentialID = credentialID;\n  }\n\n  if (credentialPublicKey) {\n    toReturn.credentialPublicKey = credentialPublicKey;\n    toReturn.parsedCredentialPublicKey = parsedCredentialPublicKey;\n  }\n\n  return toReturn;\n}\n\nexport type AuthenticatorData = {\n  rpIdHash: string;\n  flags: {\n    userPresent: boolean;\n    userVerified: boolean;\n    attestedData: boolean;\n    extensionData: boolean;\n  };\n  flagsMask: string;\n  counter: number;\n  aaguid?: string;\n  credentialID?: string;\n  credentialPublicKey?: string;\n  parsedCredentialPublicKey?: ParsedCredentialPublicKey;\n  // extensionsDataBuffer?: Buffer;\n};\n\ntype ParsedCredentialPublicKey = {\n  keyType?: string;\n  algorithm?: string;\n  curve?: number | string;\n  x?: string;\n  y?: string;\n  modulus?: string;\n  exponent?: number;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}