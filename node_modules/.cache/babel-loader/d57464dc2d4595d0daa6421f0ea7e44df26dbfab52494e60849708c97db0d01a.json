{"ast":null,"code":"'use strict';\n\nconst Encoder = require('./encoder');\nconst ObjectRecorder = require('./objectRecorder');\nconst {\n  Buffer\n} = require('buffer');\n\n/**\n * Implement value sharing.\n *\n * @see {@link cbor.schmorp.de/value-sharing}\n */\nclass SharedValueEncoder extends Encoder {\n  constructor(opts) {\n    super(opts);\n    this.valueSharing = new ObjectRecorder();\n  }\n\n  /**\n   * @param {object} obj Object to encode.\n   * @param {import('./encoder').ObjectOptions} [opts] Options for encoding\n   *   this object.\n   * @returns {boolean} True on success.\n   * @throws {Error} Loop detected.\n   * @ignore\n   */\n  _pushObject(obj, opts) {\n    if (obj !== null) {\n      const shared = this.valueSharing.check(obj);\n      switch (shared) {\n        case ObjectRecorder.FIRST:\n          // Prefix with tag 28\n          this._pushTag(28);\n          break;\n        case ObjectRecorder.NEVER:\n          // Do nothing\n          break;\n        default:\n          return this._pushTag(29) && this._pushIntNum(shared);\n      }\n    }\n    return super._pushObject(obj, opts);\n  }\n\n  /**\n   * Between encoding runs, stop recording, and start outputing correct tags.\n   */\n  stopRecording() {\n    this.valueSharing.stop();\n  }\n\n  /**\n   * Remove the existing recording and start over.  Do this between encoding\n   * pairs.\n   */\n  clearRecording() {\n    this.valueSharing.clear();\n  }\n\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encode(...objs) {\n    const enc = new SharedValueEncoder();\n    // eslint-disable-next-line no-empty-function\n    enc.on('data', () => {}); // Sink all writes\n\n    for (const o of objs) {\n      enc.pushAny(o);\n    }\n    enc.stopRecording();\n    enc.removeAllListeners('data');\n    return enc._encodeAll(objs);\n  }\n\n  // eslint-disable-next-line jsdoc/require-returns-check\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} Never.\n   * @throws {Error} Always.  This combination doesn't work at the moment.\n   */\n  static encodeCanonical(...objs) {\n    throw new Error('Cannot encode canonically in a SharedValueEncoder, which serializes objects multiple times.');\n  }\n\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @param {any} obj The object to encode.\n   * @param {import('./encoder').EncodingOptions} [options={}]\n   *   Passed to the Encoder constructor.\n   * @returns {Buffer} The encoded objects.\n   * @static\n   */\n  static encodeOne(obj, options) {\n    const enc = new SharedValueEncoder(options);\n    // eslint-disable-next-line no-empty-function\n    enc.on('data', () => {}); // Sink all writes\n    enc.pushAny(obj);\n    enc.stopRecording();\n    enc.removeAllListeners('data');\n    return enc._encodeAll([obj]);\n  }\n\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this\n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj The object to encode.\n   * @param {import('./encoder').EncodingOptions} [options={}]\n   *   Passed to the Encoder constructor.\n   * @returns {Promise<Buffer>} A promise for the encoded buffer.\n   */\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      /** @type {Buffer[]} */\n      const bufs = [];\n      const enc = new SharedValueEncoder(options);\n      // eslint-disable-next-line no-empty-function\n      enc.on('data', () => {});\n      enc.on('error', reject);\n      enc.on('finish', () => resolve(Buffer.concat(bufs)));\n      enc.pushAny(obj);\n      enc.stopRecording();\n      enc.removeAllListeners('data');\n      enc.on('data', buf => bufs.push(buf));\n      enc.pushAny(obj);\n      enc.end();\n    });\n  }\n}\nmodule.exports = SharedValueEncoder;","map":{"version":3,"names":["Encoder","require","ObjectRecorder","Buffer","SharedValueEncoder","constructor","opts","valueSharing","_pushObject","obj","shared","check","FIRST","_pushTag","NEVER","_pushIntNum","stopRecording","stop","clearRecording","clear","encode","objs","enc","on","o","pushAny","removeAllListeners","_encodeAll","encodeCanonical","Error","encodeOne","options","encodeAsync","Promise","resolve","reject","bufs","concat","buf","push","end","module","exports"],"sources":["/Users/peterchen/Dropbox/Hexlink/pwa-demo/node_modules/cbor/lib/sharedValueEncoder.js"],"sourcesContent":["'use strict'\n\nconst Encoder = require('./encoder')\nconst ObjectRecorder = require('./objectRecorder')\nconst {Buffer} = require('buffer')\n\n/**\n * Implement value sharing.\n *\n * @see {@link cbor.schmorp.de/value-sharing}\n */\nclass SharedValueEncoder extends Encoder {\n  constructor(opts) {\n    super(opts)\n    this.valueSharing = new ObjectRecorder()\n  }\n\n  /**\n   * @param {object} obj Object to encode.\n   * @param {import('./encoder').ObjectOptions} [opts] Options for encoding\n   *   this object.\n   * @returns {boolean} True on success.\n   * @throws {Error} Loop detected.\n   * @ignore\n   */\n  _pushObject(obj, opts) {\n    if (obj !== null) {\n      const shared = this.valueSharing.check(obj)\n      switch (shared) {\n        case ObjectRecorder.FIRST:\n          // Prefix with tag 28\n          this._pushTag(28)\n          break\n        case ObjectRecorder.NEVER:\n          // Do nothing\n          break\n        default:\n          return this._pushTag(29) && this._pushIntNum(shared)\n      }\n    }\n    return super._pushObject(obj, opts)\n  }\n\n  /**\n   * Between encoding runs, stop recording, and start outputing correct tags.\n   */\n  stopRecording() {\n    this.valueSharing.stop()\n  }\n\n  /**\n   * Remove the existing recording and start over.  Do this between encoding\n   * pairs.\n   */\n  clearRecording() {\n    this.valueSharing.clear()\n  }\n\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encode(...objs) {\n    const enc = new SharedValueEncoder()\n    // eslint-disable-next-line no-empty-function\n    enc.on('data', () => {}) // Sink all writes\n\n    for (const o of objs) {\n      enc.pushAny(o)\n    }\n    enc.stopRecording()\n    enc.removeAllListeners('data')\n    return enc._encodeAll(objs)\n  }\n\n  // eslint-disable-next-line jsdoc/require-returns-check\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} Never.\n   * @throws {Error} Always.  This combination doesn't work at the moment.\n   */\n  static encodeCanonical(...objs) {\n    throw new Error('Cannot encode canonically in a SharedValueEncoder, which serializes objects multiple times.')\n  }\n\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @param {any} obj The object to encode.\n   * @param {import('./encoder').EncodingOptions} [options={}]\n   *   Passed to the Encoder constructor.\n   * @returns {Buffer} The encoded objects.\n   * @static\n   */\n  static encodeOne(obj, options) {\n    const enc = new SharedValueEncoder(options)\n    // eslint-disable-next-line no-empty-function\n    enc.on('data', () => {}) // Sink all writes\n    enc.pushAny(obj)\n    enc.stopRecording()\n    enc.removeAllListeners('data')\n    return enc._encodeAll([obj])\n  }\n\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this\n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj The object to encode.\n   * @param {import('./encoder').EncodingOptions} [options={}]\n   *   Passed to the Encoder constructor.\n   * @returns {Promise<Buffer>} A promise for the encoded buffer.\n   */\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      /** @type {Buffer[]} */\n      const bufs = []\n      const enc = new SharedValueEncoder(options)\n      // eslint-disable-next-line no-empty-function\n      enc.on('data', () => {})\n      enc.on('error', reject)\n      enc.on('finish', () => resolve(Buffer.concat(bufs)))\n      enc.pushAny(obj)\n      enc.stopRecording()\n      enc.removeAllListeners('data')\n      enc.on('data', buf => bufs.push(buf))\n      enc.pushAny(obj)\n      enc.end()\n    })\n  }\n}\n\nmodule.exports = SharedValueEncoder\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}