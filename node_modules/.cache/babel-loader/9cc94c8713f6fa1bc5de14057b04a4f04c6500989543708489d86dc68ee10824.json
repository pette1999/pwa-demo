{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\nconst Decoder = require('./decoder');\nconst utils = require('./utils');\nconst NoFilter = require('nofilter');\nconst {\n  MT,\n  SYMS\n} = require('./constants');\n\n/**\n * Things that can act as inputs, from which a NoFilter can be created.\n *\n * @typedef {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n *   |DataView|stream.Readable} BufferLike\n */\n\n/**\n * @typedef DiagnoseOptions\n * @property {string} [separator='\\n'] Output between detected objects.\n * @property {boolean} [stream_errors=false] Put error info into the\n *   output stream.\n * @property {number} [max_depth=-1] The maximum depth to parse.\n *   Use -1 for \"until you run out of memory\".  Set this to a finite\n *   positive number for un-trusted inputs.  Most standard inputs won't nest\n *   more than 100 or so levels; I've tested into the millions before\n *   running out of memory.\n * @property {object} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] The encoding of input, ignored if\n *   input is not string.\n */\n/**\n * @callback diagnoseCallback\n * @param {Error} [error] If one was generated.\n * @param {string} [value] The diagnostic value.\n * @returns {void}\n */\n/**\n * @param {DiagnoseOptions|diagnoseCallback|string} opts Options,\n *   the callback, or input incoding.\n * @param {diagnoseCallback} [cb] Called on completion.\n * @returns {{options: DiagnoseOptions, cb: diagnoseCallback}} Normalized.\n * @throws {TypeError} Unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {\n        options: {},\n        cb: /** @type {diagnoseCallback} */opts\n      };\n    case 'string':\n      return {\n        options: {\n          encoding: /** @type {BufferEncoding} */opts\n        },\n        cb\n      };\n    case 'object':\n      return {\n        options: opts || {},\n        cb\n      };\n    default:\n      throw new TypeError('Unknown option type');\n  }\n}\n\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n * @extends stream.Transform\n */\nclass Diagnose extends stream.Transform {\n  /**\n   * Creates an instance of Diagnose.\n   *\n   * @param {DiagnoseOptions} [options={}] Options for creation.\n   */\n  constructor(options = {}) {\n    const {\n      separator = '\\n',\n      stream_errors = false,\n      // Decoder options\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n      // Stream.Transform options\n      ...superOpts\n    } = options;\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: false\n    });\n    this.float_bytes = -1;\n    this.separator = separator;\n    this.stream_errors = stream_errors;\n    this.parser = new Decoder({\n      tags,\n      max_depth,\n      preferWeb,\n      encoding\n    });\n    this.parser.on('more-bytes', this._on_more.bind(this));\n    this.parser.on('value', this._on_value.bind(this));\n    this.parser.on('start', this._on_start.bind(this));\n    this.parser.on('stop', this._on_stop.bind(this));\n    this.parser.on('data', this._on_data.bind(this));\n    this.parser.on('error', this._on_error.bind(this));\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, encoding, cb) {\n    this.parser.write(fresh, encoding, cb);\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _flush(cb) {\n    this.parser._flush(er => {\n      if (this.stream_errors) {\n        if (er) {\n          this._on_error(er);\n        }\n        return cb();\n      }\n      return cb(er);\n    });\n  }\n\n  /**\n   * Convenience function to return a string in diagnostic format.\n   *\n   * @param {BufferLike} input The CBOR bytes to format.\n   * @param {DiagnoseOptions |diagnoseCallback|string} [options={}]\n   *   Options, the callback, or the input encoding.\n   * @param {diagnoseCallback} [cb] Callback.\n   * @returns {Promise} If callback not specified.\n   * @throws {TypeError} Input not provided.\n   */\n  static diagnose(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n    ({\n      options,\n      cb\n    } = normalizeOptions(options, cb));\n    const {\n      encoding = 'hex',\n      ...opts\n    } = options;\n    const bs = new NoFilter();\n    const d = new Diagnose(opts);\n    let p = null;\n    if (typeof cb === 'function') {\n      d.on('end', () => cb(null, bs.toString('utf8')));\n      d.on('error', cb);\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => resolve(bs.toString('utf8')));\n        d.on('error', reject);\n      });\n    }\n    d.pipe(bs);\n    utils.guessEncoding(input, encoding).pipe(d);\n    return p;\n  }\n\n  /**\n   * @ignore\n   */\n  _on_error(er) {\n    if (this.stream_errors) {\n      this.push(er.toString());\n    } else {\n      this.emit('error', er);\n    }\n  }\n\n  /** @private */\n  _on_more(mt, len, parent_mt, pos) {\n    if (mt === MT.SIMPLE_FLOAT) {\n      this.float_bytes = {\n        2: 1,\n        4: 2,\n        8: 3\n      }[len];\n    }\n  }\n\n  /** @private */\n  _fore(parent_mt, pos) {\n    switch (parent_mt) {\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n      case MT.ARRAY:\n        if (pos > 0) {\n          this.push(', ');\n        }\n        break;\n      case MT.MAP:\n        if (pos > 0) {\n          if (pos % 2) {\n            this.push(': ');\n          } else {\n            this.push(', ');\n          }\n        }\n    }\n  }\n\n  /** @private */\n  _on_value(val, parent_mt, pos) {\n    if (val === SYMS.BREAK) {\n      return;\n    }\n    this._fore(parent_mt, pos);\n    const fb = this.float_bytes;\n    this.float_bytes = -1;\n    this.push(utils.cborValueToString(val, fb));\n  }\n\n  /** @private */\n  _on_start(mt, tag, parent_mt, pos) {\n    this._fore(parent_mt, pos);\n    switch (mt) {\n      case MT.TAG:\n        this.push(`${tag}(`);\n        break;\n      case MT.ARRAY:\n        this.push('[');\n        break;\n      case MT.MAP:\n        this.push('{');\n        break;\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push('(');\n        break;\n    }\n    if (tag === SYMS.STREAM) {\n      this.push('_ ');\n    }\n  }\n\n  /** @private */\n  _on_stop(mt) {\n    switch (mt) {\n      case MT.TAG:\n        this.push(')');\n        break;\n      case MT.ARRAY:\n        this.push(']');\n        break;\n      case MT.MAP:\n        this.push('}');\n        break;\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push(')');\n        break;\n    }\n  }\n\n  /** @private */\n  _on_data() {\n    this.push(this.separator);\n  }\n}\nmodule.exports = Diagnose;","map":{"version":3,"names":["stream","require","Decoder","utils","NoFilter","MT","SYMS","normalizeOptions","opts","cb","options","encoding","TypeError","Diagnose","Transform","constructor","separator","stream_errors","tags","max_depth","preferWeb","superOpts","readableObjectMode","writableObjectMode","float_bytes","parser","on","_on_more","bind","_on_value","_on_start","_on_stop","_on_data","_on_error","_transform","fresh","write","_flush","er","diagnose","input","bs","d","p","toString","Promise","resolve","reject","pipe","guessEncoding","push","emit","mt","len","parent_mt","pos","SIMPLE_FLOAT","_fore","BYTE_STRING","UTF8_STRING","ARRAY","MAP","val","BREAK","fb","cborValueToString","tag","TAG","STREAM","module","exports"],"sources":["/Users/peterchen/Dropbox/Hexlink/pwa-demo/node_modules/cbor/lib/diagnose.js"],"sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst Decoder = require('./decoder')\nconst utils = require('./utils')\nconst NoFilter = require('nofilter')\nconst {MT, SYMS} = require('./constants')\n\n/**\n * Things that can act as inputs, from which a NoFilter can be created.\n *\n * @typedef {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n *   |DataView|stream.Readable} BufferLike\n */\n\n/**\n * @typedef DiagnoseOptions\n * @property {string} [separator='\\n'] Output between detected objects.\n * @property {boolean} [stream_errors=false] Put error info into the\n *   output stream.\n * @property {number} [max_depth=-1] The maximum depth to parse.\n *   Use -1 for \"until you run out of memory\".  Set this to a finite\n *   positive number for un-trusted inputs.  Most standard inputs won't nest\n *   more than 100 or so levels; I've tested into the millions before\n *   running out of memory.\n * @property {object} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] The encoding of input, ignored if\n *   input is not string.\n */\n/**\n * @callback diagnoseCallback\n * @param {Error} [error] If one was generated.\n * @param {string} [value] The diagnostic value.\n * @returns {void}\n */\n/**\n * @param {DiagnoseOptions|diagnoseCallback|string} opts Options,\n *   the callback, or input incoding.\n * @param {diagnoseCallback} [cb] Called on completion.\n * @returns {{options: DiagnoseOptions, cb: diagnoseCallback}} Normalized.\n * @throws {TypeError} Unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {diagnoseCallback} */ (opts)}\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb}\n    case 'object':\n      return {options: opts || {}, cb}\n    default:\n      throw new TypeError('Unknown option type')\n  }\n}\n\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n * @extends stream.Transform\n */\nclass Diagnose extends stream.Transform {\n  /**\n   * Creates an instance of Diagnose.\n   *\n   * @param {DiagnoseOptions} [options={}] Options for creation.\n   */\n  constructor(options = {}) {\n    const {\n      separator = '\\n',\n      stream_errors = false,\n      // Decoder options\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n      // Stream.Transform options\n      ...superOpts\n    } = options\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: false,\n    })\n\n    this.float_bytes = -1\n    this.separator = separator\n    this.stream_errors = stream_errors\n    this.parser = new Decoder({\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n    })\n    this.parser.on('more-bytes', this._on_more.bind(this))\n    this.parser.on('value', this._on_value.bind(this))\n    this.parser.on('start', this._on_start.bind(this))\n    this.parser.on('stop', this._on_stop.bind(this))\n    this.parser.on('data', this._on_data.bind(this))\n    this.parser.on('error', this._on_error.bind(this))\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, encoding, cb) {\n    this.parser.write(fresh, encoding, cb)\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _flush(cb) {\n    this.parser._flush(er => {\n      if (this.stream_errors) {\n        if (er) {\n          this._on_error(er)\n        }\n        return cb()\n      }\n      return cb(er)\n    })\n  }\n\n  /**\n   * Convenience function to return a string in diagnostic format.\n   *\n   * @param {BufferLike} input The CBOR bytes to format.\n   * @param {DiagnoseOptions |diagnoseCallback|string} [options={}]\n   *   Options, the callback, or the input encoding.\n   * @param {diagnoseCallback} [cb] Callback.\n   * @returns {Promise} If callback not specified.\n   * @throws {TypeError} Input not provided.\n   */\n  static diagnose(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options, cb} = normalizeOptions(options, cb))\n    const {encoding = 'hex', ...opts} = options\n\n    const bs = new NoFilter()\n    const d = new Diagnose(opts)\n    let p = null\n    if (typeof cb === 'function') {\n      d.on('end', () => cb(null, bs.toString('utf8')))\n      d.on('error', cb)\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => resolve(bs.toString('utf8')))\n        d.on('error', reject)\n      })\n    }\n    d.pipe(bs)\n    utils.guessEncoding(input, encoding).pipe(d)\n    return p\n  }\n\n  /**\n   * @ignore\n   */\n  _on_error(er) {\n    if (this.stream_errors) {\n      this.push(er.toString())\n    } else {\n      this.emit('error', er)\n    }\n  }\n\n  /** @private */\n  _on_more(mt, len, parent_mt, pos) {\n    if (mt === MT.SIMPLE_FLOAT) {\n      this.float_bytes = {\n        2: 1,\n        4: 2,\n        8: 3,\n      }[len]\n    }\n  }\n\n  /** @private */\n  _fore(parent_mt, pos) {\n    switch (parent_mt) {\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n      case MT.ARRAY:\n        if (pos > 0) {\n          this.push(', ')\n        }\n        break\n      case MT.MAP:\n        if (pos > 0) {\n          if (pos % 2) {\n            this.push(': ')\n          } else {\n            this.push(', ')\n          }\n        }\n    }\n  }\n\n  /** @private */\n  _on_value(val, parent_mt, pos) {\n    if (val === SYMS.BREAK) {\n      return\n    }\n    this._fore(parent_mt, pos)\n    const fb = this.float_bytes\n    this.float_bytes = -1\n    this.push(utils.cborValueToString(val, fb))\n  }\n\n  /** @private */\n  _on_start(mt, tag, parent_mt, pos) {\n    this._fore(parent_mt, pos)\n    switch (mt) {\n      case MT.TAG:\n        this.push(`${tag}(`)\n        break\n      case MT.ARRAY:\n        this.push('[')\n        break\n      case MT.MAP:\n        this.push('{')\n        break\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push('(')\n        break\n    }\n    if (tag === SYMS.STREAM) {\n      this.push('_ ')\n    }\n  }\n\n  /** @private */\n  _on_stop(mt) {\n    switch (mt) {\n      case MT.TAG:\n        this.push(')')\n        break\n      case MT.ARRAY:\n        this.push(']')\n        break\n      case MT.MAP:\n        this.push('}')\n        break\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push(')')\n        break\n    }\n  }\n\n  /** @private */\n  _on_data() {\n    this.push(this.separator)\n  }\n}\n\nmodule.exports = Diagnose\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}