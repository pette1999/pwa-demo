{"ast":null,"code":"/*!\n * Copyright (c) 2014, GMO GlobalSign\n * Copyright (c) 2015-2022, Peculiar Ventures\n * All rights reserved.\n * \n * Author 2014-2019, Yury Strozhevsky\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n * \n * * Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n * \n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n */\n\nimport * as pvtsutils from 'pvtsutils';\nimport * as pvutils from 'pvutils';\nfunction assertBigInt() {\n  if (typeof BigInt === \"undefined\") {\n    throw new Error(\"BigInt is not defined. Your environment doesn't implement BigInt.\");\n  }\n}\nfunction concat(buffers) {\n  let outputLength = 0;\n  let prevLength = 0;\n  for (let i = 0; i < buffers.length; i++) {\n    const buffer = buffers[i];\n    outputLength += buffer.byteLength;\n  }\n  const retView = new Uint8Array(outputLength);\n  for (let i = 0; i < buffers.length; i++) {\n    const buffer = buffers[i];\n    retView.set(new Uint8Array(buffer), prevLength);\n    prevLength += buffer.byteLength;\n  }\n  return retView.buffer;\n}\nfunction checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {\n  if (!(inputBuffer instanceof Uint8Array)) {\n    baseBlock.error = \"Wrong parameter: inputBuffer must be 'Uint8Array'\";\n    return false;\n  }\n  if (!inputBuffer.byteLength) {\n    baseBlock.error = \"Wrong parameter: inputBuffer has zero length\";\n    return false;\n  }\n  if (inputOffset < 0) {\n    baseBlock.error = \"Wrong parameter: inputOffset less than zero\";\n    return false;\n  }\n  if (inputLength < 0) {\n    baseBlock.error = \"Wrong parameter: inputLength less than zero\";\n    return false;\n  }\n  if (inputBuffer.byteLength - inputOffset - inputLength < 0) {\n    baseBlock.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\n    return false;\n  }\n  return true;\n}\nclass ViewWriter {\n  constructor() {\n    this.items = [];\n  }\n  write(buf) {\n    this.items.push(buf);\n  }\n  final() {\n    return concat(this.items);\n  }\n}\nconst powers2 = [new Uint8Array([1])];\nconst digitsString = \"0123456789\";\nconst NAME = \"name\";\nconst VALUE_HEX_VIEW = \"valueHexView\";\nconst IS_HEX_ONLY = \"isHexOnly\";\nconst ID_BLOCK = \"idBlock\";\nconst TAG_CLASS = \"tagClass\";\nconst TAG_NUMBER = \"tagNumber\";\nconst IS_CONSTRUCTED = \"isConstructed\";\nconst FROM_BER = \"fromBER\";\nconst TO_BER = \"toBER\";\nconst LOCAL = \"local\";\nconst EMPTY_STRING = \"\";\nconst EMPTY_BUFFER = new ArrayBuffer(0);\nconst EMPTY_VIEW = new Uint8Array(0);\nconst END_OF_CONTENT_NAME = \"EndOfContent\";\nconst OCTET_STRING_NAME = \"OCTET STRING\";\nconst BIT_STRING_NAME = \"BIT STRING\";\nfunction HexBlock(BaseClass) {\n  var _a;\n  return _a = class Some extends BaseClass {\n    constructor(...args) {\n      var _a;\n      super(...args);\n      const params = args[0] || {};\n      this.isHexOnly = (_a = params.isHexOnly) !== null && _a !== void 0 ? _a : false;\n      this.valueHexView = params.valueHex ? pvtsutils.BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;\n    }\n    get valueHex() {\n      return this.valueHexView.slice().buffer;\n    }\n    set valueHex(value) {\n      this.valueHexView = new Uint8Array(value);\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;\n      if (!checkBufferParams(this, view, inputOffset, inputLength)) {\n        return -1;\n      }\n      const endLength = inputOffset + inputLength;\n      this.valueHexView = view.subarray(inputOffset, endLength);\n      if (!this.valueHexView.length) {\n        this.warnings.push(\"Zero buffer length\");\n        return inputOffset;\n      }\n      this.blockLength = inputLength;\n      return endLength;\n    }\n    toBER(sizeOnly = false) {\n      if (!this.isHexOnly) {\n        this.error = \"Flag 'isHexOnly' is not set, abort\";\n        return EMPTY_BUFFER;\n      }\n      if (sizeOnly) {\n        return new ArrayBuffer(this.valueHexView.byteLength);\n      }\n      return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;\n    }\n    toJSON() {\n      return {\n        ...super.toJSON(),\n        isHexOnly: this.isHexOnly,\n        valueHex: pvtsutils.Convert.ToHex(this.valueHexView)\n      };\n    }\n  }, _a.NAME = \"hexBlock\", _a;\n}\nclass LocalBaseBlock {\n  constructor({\n    blockLength = 0,\n    error = EMPTY_STRING,\n    warnings = [],\n    valueBeforeDecode = EMPTY_VIEW\n  } = {}) {\n    this.blockLength = blockLength;\n    this.error = error;\n    this.warnings = warnings;\n    this.valueBeforeDecodeView = pvtsutils.BufferSourceConverter.toUint8Array(valueBeforeDecode);\n  }\n  static blockName() {\n    return this.NAME;\n  }\n  get valueBeforeDecode() {\n    return this.valueBeforeDecodeView.slice().buffer;\n  }\n  set valueBeforeDecode(value) {\n    this.valueBeforeDecodeView = new Uint8Array(value);\n  }\n  toJSON() {\n    return {\n      blockName: this.constructor.NAME,\n      blockLength: this.blockLength,\n      error: this.error,\n      warnings: this.warnings,\n      valueBeforeDecode: pvtsutils.Convert.ToHex(this.valueBeforeDecodeView)\n    };\n  }\n}\nLocalBaseBlock.NAME = \"baseBlock\";\nclass ValueBlock extends LocalBaseBlock {\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    throw TypeError(\"User need to make a specific function in a class which extends 'ValueBlock'\");\n  }\n  toBER(sizeOnly, writer) {\n    throw TypeError(\"User need to make a specific function in a class which extends 'ValueBlock'\");\n  }\n}\nValueBlock.NAME = \"valueBlock\";\nclass LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {\n  constructor({\n    idBlock = {}\n  } = {}) {\n    var _a, _b, _c, _d;\n    super();\n    if (idBlock) {\n      this.isHexOnly = (_a = idBlock.isHexOnly) !== null && _a !== void 0 ? _a : false;\n      this.valueHexView = idBlock.valueHex ? pvtsutils.BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;\n      this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;\n      this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;\n      this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;\n    } else {\n      this.tagClass = -1;\n      this.tagNumber = -1;\n      this.isConstructed = false;\n    }\n  }\n  toBER(sizeOnly = false) {\n    let firstOctet = 0;\n    switch (this.tagClass) {\n      case 1:\n        firstOctet |= 0x00;\n        break;\n      case 2:\n        firstOctet |= 0x40;\n        break;\n      case 3:\n        firstOctet |= 0x80;\n        break;\n      case 4:\n        firstOctet |= 0xC0;\n        break;\n      default:\n        this.error = \"Unknown tag class\";\n        return EMPTY_BUFFER;\n    }\n    if (this.isConstructed) firstOctet |= 0x20;\n    if (this.tagNumber < 31 && !this.isHexOnly) {\n      const retView = new Uint8Array(1);\n      if (!sizeOnly) {\n        let number = this.tagNumber;\n        number &= 0x1F;\n        firstOctet |= number;\n        retView[0] = firstOctet;\n      }\n      return retView.buffer;\n    }\n    if (!this.isHexOnly) {\n      const encodedBuf = pvutils.utilToBase(this.tagNumber, 7);\n      const encodedView = new Uint8Array(encodedBuf);\n      const size = encodedBuf.byteLength;\n      const retView = new Uint8Array(size + 1);\n      retView[0] = firstOctet | 0x1F;\n      if (!sizeOnly) {\n        for (let i = 0; i < size - 1; i++) retView[i + 1] = encodedView[i] | 0x80;\n        retView[size] = encodedView[size - 1];\n      }\n      return retView.buffer;\n    }\n    const retView = new Uint8Array(this.valueHexView.byteLength + 1);\n    retView[0] = firstOctet | 0x1F;\n    if (!sizeOnly) {\n      const curView = this.valueHexView;\n      for (let i = 0; i < curView.length - 1; i++) retView[i + 1] = curView[i] | 0x80;\n      retView[this.valueHexView.byteLength] = curView[curView.length - 1];\n    }\n    return retView.buffer;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\n    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\n      return -1;\n    }\n    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\n    if (intBuffer.length === 0) {\n      this.error = \"Zero buffer length\";\n      return -1;\n    }\n    const tagClassMask = intBuffer[0] & 0xC0;\n    switch (tagClassMask) {\n      case 0x00:\n        this.tagClass = 1;\n        break;\n      case 0x40:\n        this.tagClass = 2;\n        break;\n      case 0x80:\n        this.tagClass = 3;\n        break;\n      case 0xC0:\n        this.tagClass = 4;\n        break;\n      default:\n        this.error = \"Unknown tag class\";\n        return -1;\n    }\n    this.isConstructed = (intBuffer[0] & 0x20) === 0x20;\n    this.isHexOnly = false;\n    const tagNumberMask = intBuffer[0] & 0x1F;\n    if (tagNumberMask !== 0x1F) {\n      this.tagNumber = tagNumberMask;\n      this.blockLength = 1;\n    } else {\n      let count = 1;\n      let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);\n      let tagNumberBufferMaxLength = 255;\n      while (intBuffer[count] & 0x80) {\n        intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\n        count++;\n        if (count >= intBuffer.length) {\n          this.error = \"End of input reached before message was fully decoded\";\n          return -1;\n        }\n        if (count === tagNumberBufferMaxLength) {\n          tagNumberBufferMaxLength += 255;\n          const tempBufferView = new Uint8Array(tagNumberBufferMaxLength);\n          for (let i = 0; i < intTagNumberBuffer.length; i++) tempBufferView[i] = intTagNumberBuffer[i];\n          intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);\n        }\n      }\n      this.blockLength = count + 1;\n      intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\n      const tempBufferView = new Uint8Array(count);\n      for (let i = 0; i < count; i++) tempBufferView[i] = intTagNumberBuffer[i];\n      intTagNumberBuffer = this.valueHexView = new Uint8Array(count);\n      intTagNumberBuffer.set(tempBufferView);\n      if (this.blockLength <= 9) this.tagNumber = pvutils.utilFromBase(intTagNumberBuffer, 7);else {\n        this.isHexOnly = true;\n        this.warnings.push(\"Tag too long, represented as hex-coded\");\n      }\n    }\n    if (this.tagClass === 1 && this.isConstructed) {\n      switch (this.tagNumber) {\n        case 1:\n        case 2:\n        case 5:\n        case 6:\n        case 9:\n        case 13:\n        case 14:\n        case 23:\n        case 24:\n        case 31:\n        case 32:\n        case 33:\n        case 34:\n          this.error = \"Constructed encoding used for primitive type\";\n          return -1;\n      }\n    }\n    return inputOffset + this.blockLength;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      tagClass: this.tagClass,\n      tagNumber: this.tagNumber,\n      isConstructed: this.isConstructed\n    };\n  }\n}\nLocalIdentificationBlock.NAME = \"identificationBlock\";\nclass LocalLengthBlock extends LocalBaseBlock {\n  constructor({\n    lenBlock = {}\n  } = {}) {\n    var _a, _b, _c;\n    super();\n    this.isIndefiniteForm = (_a = lenBlock.isIndefiniteForm) !== null && _a !== void 0 ? _a : false;\n    this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;\n    this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const view = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\n    if (!checkBufferParams(this, view, inputOffset, inputLength)) {\n      return -1;\n    }\n    const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);\n    if (intBuffer.length === 0) {\n      this.error = \"Zero buffer length\";\n      return -1;\n    }\n    if (intBuffer[0] === 0xFF) {\n      this.error = \"Length block 0xFF is reserved by standard\";\n      return -1;\n    }\n    this.isIndefiniteForm = intBuffer[0] === 0x80;\n    if (this.isIndefiniteForm) {\n      this.blockLength = 1;\n      return inputOffset + this.blockLength;\n    }\n    this.longFormUsed = !!(intBuffer[0] & 0x80);\n    if (this.longFormUsed === false) {\n      this.length = intBuffer[0];\n      this.blockLength = 1;\n      return inputOffset + this.blockLength;\n    }\n    const count = intBuffer[0] & 0x7F;\n    if (count > 8) {\n      this.error = \"Too big integer\";\n      return -1;\n    }\n    if (count + 1 > intBuffer.length) {\n      this.error = \"End of input reached before message was fully decoded\";\n      return -1;\n    }\n    const lenOffset = inputOffset + 1;\n    const lengthBufferView = view.subarray(lenOffset, lenOffset + count);\n    if (lengthBufferView[count - 1] === 0x00) this.warnings.push(\"Needlessly long encoded length\");\n    this.length = pvutils.utilFromBase(lengthBufferView, 8);\n    if (this.longFormUsed && this.length <= 127) this.warnings.push(\"Unnecessary usage of long length form\");\n    this.blockLength = count + 1;\n    return inputOffset + this.blockLength;\n  }\n  toBER(sizeOnly = false) {\n    let retBuf;\n    let retView;\n    if (this.length > 127) this.longFormUsed = true;\n    if (this.isIndefiniteForm) {\n      retBuf = new ArrayBuffer(1);\n      if (sizeOnly === false) {\n        retView = new Uint8Array(retBuf);\n        retView[0] = 0x80;\n      }\n      return retBuf;\n    }\n    if (this.longFormUsed) {\n      const encodedBuf = pvutils.utilToBase(this.length, 8);\n      if (encodedBuf.byteLength > 127) {\n        this.error = \"Too big length\";\n        return EMPTY_BUFFER;\n      }\n      retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);\n      if (sizeOnly) return retBuf;\n      const encodedView = new Uint8Array(encodedBuf);\n      retView = new Uint8Array(retBuf);\n      retView[0] = encodedBuf.byteLength | 0x80;\n      for (let i = 0; i < encodedBuf.byteLength; i++) retView[i + 1] = encodedView[i];\n      return retBuf;\n    }\n    retBuf = new ArrayBuffer(1);\n    if (sizeOnly === false) {\n      retView = new Uint8Array(retBuf);\n      retView[0] = this.length;\n    }\n    return retBuf;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      isIndefiniteForm: this.isIndefiniteForm,\n      longFormUsed: this.longFormUsed,\n      length: this.length\n    };\n  }\n}\nLocalLengthBlock.NAME = \"lengthBlock\";\nconst typeStore = {};\nclass BaseBlock extends LocalBaseBlock {\n  constructor({\n    name = EMPTY_STRING,\n    optional = false,\n    primitiveSchema,\n    ...parameters\n  } = {}, valueBlockType) {\n    super(parameters);\n    this.name = name;\n    this.optional = optional;\n    if (primitiveSchema) {\n      this.primitiveSchema = primitiveSchema;\n    }\n    this.idBlock = new LocalIdentificationBlock(parameters);\n    this.lenBlock = new LocalLengthBlock(parameters);\n    this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n    if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;\n    if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;\n    if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  }\n  toBER(sizeOnly, writer) {\n    const _writer = writer || new ViewWriter();\n    if (!writer) {\n      prepareIndefiniteForm(this);\n    }\n    const idBlockBuf = this.idBlock.toBER(sizeOnly);\n    _writer.write(idBlockBuf);\n    if (this.lenBlock.isIndefiniteForm) {\n      _writer.write(new Uint8Array([0x80]).buffer);\n      this.valueBlock.toBER(sizeOnly, _writer);\n      _writer.write(new ArrayBuffer(2));\n    } else {\n      const valueBlockBuf = this.valueBlock.toBER(sizeOnly);\n      this.lenBlock.length = valueBlockBuf.byteLength;\n      const lenBlockBuf = this.lenBlock.toBER(sizeOnly);\n      _writer.write(lenBlockBuf);\n      _writer.write(valueBlockBuf);\n    }\n    if (!writer) {\n      return _writer.final();\n    }\n    return EMPTY_BUFFER;\n  }\n  toJSON() {\n    const object = {\n      ...super.toJSON(),\n      idBlock: this.idBlock.toJSON(),\n      lenBlock: this.lenBlock.toJSON(),\n      valueBlock: this.valueBlock.toJSON(),\n      name: this.name,\n      optional: this.optional\n    };\n    if (this.primitiveSchema) object.primitiveSchema = this.primitiveSchema.toJSON();\n    return object;\n  }\n  toString(encoding = \"ascii\") {\n    if (encoding === \"ascii\") {\n      return this.onAsciiEncoding();\n    }\n    return pvtsutils.Convert.ToHex(this.toBER());\n  }\n  onAsciiEncoding() {\n    return `${this.constructor.NAME} : ${pvtsutils.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`;\n  }\n  isEqual(other) {\n    if (this === other) {\n      return true;\n    }\n    if (!(other instanceof this.constructor)) {\n      return false;\n    }\n    const thisRaw = this.toBER();\n    const otherRaw = other.toBER();\n    return pvutils.isEqualBuffer(thisRaw, otherRaw);\n  }\n}\nBaseBlock.NAME = \"BaseBlock\";\nfunction prepareIndefiniteForm(baseBlock) {\n  if (baseBlock instanceof typeStore.Constructed) {\n    for (const value of baseBlock.valueBlock.value) {\n      if (prepareIndefiniteForm(value)) {\n        baseBlock.lenBlock.isIndefiniteForm = true;\n      }\n    }\n  }\n  return !!baseBlock.lenBlock.isIndefiniteForm;\n}\nclass BaseStringBlock extends BaseBlock {\n  constructor({\n    value = EMPTY_STRING,\n    ...parameters\n  } = {}, stringValueBlockType) {\n    super(parameters, stringValueBlockType);\n    if (value) {\n      this.fromString(value);\n    }\n  }\n  getValue() {\n    return this.valueBlock.value;\n  }\n  setValue(value) {\n    this.valueBlock.value = value;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n    this.fromBuffer(this.valueBlock.valueHexView);\n    if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;\n    if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;\n    if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  }\n  onAsciiEncoding() {\n    return `${this.constructor.NAME} : '${this.valueBlock.value}'`;\n  }\n}\nBaseStringBlock.NAME = \"BaseStringBlock\";\nclass LocalPrimitiveValueBlock extends HexBlock(ValueBlock) {\n  constructor({\n    isHexOnly = true,\n    ...parameters\n  } = {}) {\n    super(parameters);\n    this.isHexOnly = isHexOnly;\n  }\n}\nLocalPrimitiveValueBlock.NAME = \"PrimitiveValueBlock\";\nvar _a$w;\nclass Primitive extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalPrimitiveValueBlock);\n    this.idBlock.isConstructed = false;\n  }\n}\n_a$w = Primitive;\n(() => {\n  typeStore.Primitive = _a$w;\n})();\nPrimitive.NAME = \"PRIMITIVE\";\nfunction localChangeType(inputObject, newType) {\n  if (inputObject instanceof newType) {\n    return inputObject;\n  }\n  const newObject = new newType();\n  newObject.idBlock = inputObject.idBlock;\n  newObject.lenBlock = inputObject.lenBlock;\n  newObject.warnings = inputObject.warnings;\n  newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;\n  return newObject;\n}\nfunction localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {\n  const incomingOffset = inputOffset;\n  let returnObject = new BaseBlock({}, ValueBlock);\n  const baseBlock = new LocalBaseBlock();\n  if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {\n    returnObject.error = baseBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n  const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);\n  if (!intBuffer.length) {\n    returnObject.error = \"Zero buffer length\";\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);\n  if (returnObject.idBlock.warnings.length) {\n    returnObject.warnings.concat(returnObject.idBlock.warnings);\n  }\n  if (resultOffset === -1) {\n    returnObject.error = returnObject.idBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n  inputOffset = resultOffset;\n  inputLength -= returnObject.idBlock.blockLength;\n  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);\n  if (returnObject.lenBlock.warnings.length) {\n    returnObject.warnings.concat(returnObject.lenBlock.warnings);\n  }\n  if (resultOffset === -1) {\n    returnObject.error = returnObject.lenBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n  inputOffset = resultOffset;\n  inputLength -= returnObject.lenBlock.blockLength;\n  if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {\n    returnObject.error = \"Indefinite length form used for primitive encoding form\";\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n  let newASN1Type = BaseBlock;\n  switch (returnObject.idBlock.tagClass) {\n    case 1:\n      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {\n        returnObject.error = \"UNIVERSAL 37 and upper tags are reserved by ASN.1 standard\";\n        return {\n          offset: -1,\n          result: returnObject\n        };\n      }\n      switch (returnObject.idBlock.tagNumber) {\n        case 0:\n          if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {\n            returnObject.error = \"Type [UNIVERSAL 0] is reserved\";\n            return {\n              offset: -1,\n              result: returnObject\n            };\n          }\n          newASN1Type = typeStore.EndOfContent;\n          break;\n        case 1:\n          newASN1Type = typeStore.Boolean;\n          break;\n        case 2:\n          newASN1Type = typeStore.Integer;\n          break;\n        case 3:\n          newASN1Type = typeStore.BitString;\n          break;\n        case 4:\n          newASN1Type = typeStore.OctetString;\n          break;\n        case 5:\n          newASN1Type = typeStore.Null;\n          break;\n        case 6:\n          newASN1Type = typeStore.ObjectIdentifier;\n          break;\n        case 10:\n          newASN1Type = typeStore.Enumerated;\n          break;\n        case 12:\n          newASN1Type = typeStore.Utf8String;\n          break;\n        case 13:\n          newASN1Type = typeStore.RelativeObjectIdentifier;\n          break;\n        case 14:\n          newASN1Type = typeStore.TIME;\n          break;\n        case 15:\n          returnObject.error = \"[UNIVERSAL 15] is reserved by ASN.1 standard\";\n          return {\n            offset: -1,\n            result: returnObject\n          };\n        case 16:\n          newASN1Type = typeStore.Sequence;\n          break;\n        case 17:\n          newASN1Type = typeStore.Set;\n          break;\n        case 18:\n          newASN1Type = typeStore.NumericString;\n          break;\n        case 19:\n          newASN1Type = typeStore.PrintableString;\n          break;\n        case 20:\n          newASN1Type = typeStore.TeletexString;\n          break;\n        case 21:\n          newASN1Type = typeStore.VideotexString;\n          break;\n        case 22:\n          newASN1Type = typeStore.IA5String;\n          break;\n        case 23:\n          newASN1Type = typeStore.UTCTime;\n          break;\n        case 24:\n          newASN1Type = typeStore.GeneralizedTime;\n          break;\n        case 25:\n          newASN1Type = typeStore.GraphicString;\n          break;\n        case 26:\n          newASN1Type = typeStore.VisibleString;\n          break;\n        case 27:\n          newASN1Type = typeStore.GeneralString;\n          break;\n        case 28:\n          newASN1Type = typeStore.UniversalString;\n          break;\n        case 29:\n          newASN1Type = typeStore.CharacterString;\n          break;\n        case 30:\n          newASN1Type = typeStore.BmpString;\n          break;\n        case 31:\n          newASN1Type = typeStore.DATE;\n          break;\n        case 32:\n          newASN1Type = typeStore.TimeOfDay;\n          break;\n        case 33:\n          newASN1Type = typeStore.DateTime;\n          break;\n        case 34:\n          newASN1Type = typeStore.Duration;\n          break;\n        default:\n          {\n            const newObject = returnObject.idBlock.isConstructed ? new typeStore.Constructed() : new typeStore.Primitive();\n            newObject.idBlock = returnObject.idBlock;\n            newObject.lenBlock = returnObject.lenBlock;\n            newObject.warnings = returnObject.warnings;\n            returnObject = newObject;\n          }\n      }\n      break;\n    case 2:\n    case 3:\n    case 4:\n    default:\n      {\n        newASN1Type = returnObject.idBlock.isConstructed ? typeStore.Constructed : typeStore.Primitive;\n      }\n  }\n  returnObject = localChangeType(returnObject, newASN1Type);\n  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);\n  returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);\n  return {\n    offset: resultOffset,\n    result: returnObject\n  };\n}\nfunction fromBER(inputBuffer) {\n  if (!inputBuffer.byteLength) {\n    const result = new BaseBlock({}, ValueBlock);\n    result.error = \"Input buffer has zero length\";\n    return {\n      offset: -1,\n      result\n    };\n  }\n  return localFromBER(pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);\n}\nfunction checkLen(indefiniteLength, length) {\n  if (indefiniteLength) {\n    return 1;\n  }\n  return length;\n}\nclass LocalConstructedValueBlock extends ValueBlock {\n  constructor({\n    value = [],\n    isIndefiniteForm = false,\n    ...parameters\n  } = {}) {\n    super(parameters);\n    this.value = value;\n    this.isIndefiniteForm = isIndefiniteForm;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const view = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\n    if (!checkBufferParams(this, view, inputOffset, inputLength)) {\n      return -1;\n    }\n    this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);\n    if (this.valueBeforeDecodeView.length === 0) {\n      this.warnings.push(\"Zero buffer length\");\n      return inputOffset;\n    }\n    let currentOffset = inputOffset;\n    while (checkLen(this.isIndefiniteForm, inputLength) > 0) {\n      const returnObject = localFromBER(view, currentOffset, inputLength);\n      if (returnObject.offset === -1) {\n        this.error = returnObject.result.error;\n        this.warnings.concat(returnObject.result.warnings);\n        return -1;\n      }\n      currentOffset = returnObject.offset;\n      this.blockLength += returnObject.result.blockLength;\n      inputLength -= returnObject.result.blockLength;\n      this.value.push(returnObject.result);\n      if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {\n        break;\n      }\n    }\n    if (this.isIndefiniteForm) {\n      if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {\n        this.value.pop();\n      } else {\n        this.warnings.push(\"No EndOfContent block encoded\");\n      }\n    }\n    return currentOffset;\n  }\n  toBER(sizeOnly, writer) {\n    const _writer = writer || new ViewWriter();\n    for (let i = 0; i < this.value.length; i++) {\n      this.value[i].toBER(sizeOnly, _writer);\n    }\n    if (!writer) {\n      return _writer.final();\n    }\n    return EMPTY_BUFFER;\n  }\n  toJSON() {\n    const object = {\n      ...super.toJSON(),\n      isIndefiniteForm: this.isIndefiniteForm,\n      value: []\n    };\n    for (const value of this.value) {\n      object.value.push(value.toJSON());\n    }\n    return object;\n  }\n}\nLocalConstructedValueBlock.NAME = \"ConstructedValueBlock\";\nvar _a$v;\nclass Constructed extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalConstructedValueBlock);\n    this.idBlock.isConstructed = true;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n    if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;\n    if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;\n    if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  }\n  onAsciiEncoding() {\n    const values = [];\n    for (const value of this.valueBlock.value) {\n      values.push(value.toString(\"ascii\").split(\"\\n\").map(o => `  ${o}`).join(\"\\n\"));\n    }\n    const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;\n    return values.length ? `${blockName} :\\n${values.join(\"\\n\")}` : `${blockName} :`;\n  }\n}\n_a$v = Constructed;\n(() => {\n  typeStore.Constructed = _a$v;\n})();\nConstructed.NAME = \"CONSTRUCTED\";\nclass LocalEndOfContentValueBlock extends ValueBlock {\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    return inputOffset;\n  }\n  toBER(sizeOnly) {\n    return EMPTY_BUFFER;\n  }\n}\nLocalEndOfContentValueBlock.override = \"EndOfContentValueBlock\";\nvar _a$u;\nclass EndOfContent extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalEndOfContentValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 0;\n  }\n}\n_a$u = EndOfContent;\n(() => {\n  typeStore.EndOfContent = _a$u;\n})();\nEndOfContent.NAME = END_OF_CONTENT_NAME;\nvar _a$t;\nclass Null extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, ValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 5;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (this.lenBlock.length > 0) this.warnings.push(\"Non-zero length of value block for Null type\");\n    if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;\n    if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;\n    this.blockLength += inputLength;\n    if (inputOffset + inputLength > inputBuffer.byteLength) {\n      this.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\n      return -1;\n    }\n    return inputOffset + inputLength;\n  }\n  toBER(sizeOnly, writer) {\n    const retBuf = new ArrayBuffer(2);\n    if (!sizeOnly) {\n      const retView = new Uint8Array(retBuf);\n      retView[0] = 0x05;\n      retView[1] = 0x00;\n    }\n    if (writer) {\n      writer.write(retBuf);\n    }\n    return retBuf;\n  }\n  onAsciiEncoding() {\n    return `${this.constructor.NAME}`;\n  }\n}\n_a$t = Null;\n(() => {\n  typeStore.Null = _a$t;\n})();\nNull.NAME = \"NULL\";\nclass LocalBooleanValueBlock extends HexBlock(ValueBlock) {\n  constructor({\n    value,\n    ...parameters\n  } = {}) {\n    super(parameters);\n    if (parameters.valueHex) {\n      this.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(parameters.valueHex);\n    } else {\n      this.valueHexView = new Uint8Array(1);\n    }\n    if (value) {\n      this.value = value;\n    }\n  }\n  get value() {\n    for (const octet of this.valueHexView) {\n      if (octet > 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n  set value(value) {\n    this.valueHexView[0] = value ? 0xFF : 0x00;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\n    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\n      return -1;\n    }\n    this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);\n    if (inputLength > 1) this.warnings.push(\"Boolean value encoded in more then 1 octet\");\n    this.isHexOnly = true;\n    pvutils.utilDecodeTC.call(this);\n    this.blockLength = inputLength;\n    return inputOffset + inputLength;\n  }\n  toBER() {\n    return this.valueHexView.slice();\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      value: this.value\n    };\n  }\n}\nLocalBooleanValueBlock.NAME = \"BooleanValueBlock\";\nvar _a$s;\nclass Boolean extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalBooleanValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 1;\n  }\n  getValue() {\n    return this.valueBlock.value;\n  }\n  setValue(value) {\n    this.valueBlock.value = value;\n  }\n  onAsciiEncoding() {\n    return `${this.constructor.NAME} : ${this.getValue}`;\n  }\n}\n_a$s = Boolean;\n(() => {\n  typeStore.Boolean = _a$s;\n})();\nBoolean.NAME = \"BOOLEAN\";\nclass LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\n  constructor({\n    isConstructed = false,\n    ...parameters\n  } = {}) {\n    super(parameters);\n    this.isConstructed = isConstructed;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    let resultOffset = 0;\n    if (this.isConstructed) {\n      this.isHexOnly = false;\n      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n      if (resultOffset === -1) return resultOffset;\n      for (let i = 0; i < this.value.length; i++) {\n        const currentBlockName = this.value[i].constructor.NAME;\n        if (currentBlockName === END_OF_CONTENT_NAME) {\n          if (this.isIndefiniteForm) break;else {\n            this.error = \"EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only\";\n            return -1;\n          }\n        }\n        if (currentBlockName !== OCTET_STRING_NAME) {\n          this.error = \"OCTET STRING may consists of OCTET STRINGs only\";\n          return -1;\n        }\n      }\n    } else {\n      this.isHexOnly = true;\n      resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n      this.blockLength = inputLength;\n    }\n    return resultOffset;\n  }\n  toBER(sizeOnly, writer) {\n    if (this.isConstructed) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);\n    return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      isConstructed: this.isConstructed\n    };\n  }\n}\nLocalOctetStringValueBlock.NAME = \"OctetStringValueBlock\";\nvar _a$r;\nclass OctetString extends BaseBlock {\n  constructor({\n    idBlock = {},\n    lenBlock = {},\n    ...parameters\n  } = {}) {\n    var _b, _c;\n    (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);\n    super({\n      idBlock: {\n        isConstructed: parameters.isConstructed,\n        ...idBlock\n      },\n      lenBlock: {\n        ...lenBlock,\n        isIndefiniteForm: !!parameters.isIndefiniteForm\n      },\n      ...parameters\n    }, LocalOctetStringValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 4;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.valueBlock.isConstructed = this.idBlock.isConstructed;\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n    if (inputLength === 0) {\n      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n      return inputOffset;\n    }\n    if (!this.valueBlock.isConstructed) {\n      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;\n      const buf = view.subarray(inputOffset, inputOffset + inputLength);\n      try {\n        if (buf.byteLength) {\n          const asn = localFromBER(buf, 0, buf.byteLength);\n          if (asn.offset !== -1 && asn.offset === inputLength) {\n            this.valueBlock.value = [asn.result];\n          }\n        }\n      } catch (e) {}\n    }\n    return super.fromBER(inputBuffer, inputOffset, inputLength);\n  }\n  onAsciiEncoding() {\n    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {\n      return Constructed.prototype.onAsciiEncoding.call(this);\n    }\n    return `${this.constructor.NAME} : ${pvtsutils.Convert.ToHex(this.valueBlock.valueHexView)}`;\n  }\n  getValue() {\n    if (!this.idBlock.isConstructed) {\n      return this.valueBlock.valueHexView.slice().buffer;\n    }\n    const array = [];\n    for (const content of this.valueBlock.value) {\n      if (content instanceof OctetString) {\n        array.push(content.valueBlock.valueHexView);\n      }\n    }\n    return pvtsutils.BufferSourceConverter.concat(array);\n  }\n}\n_a$r = OctetString;\n(() => {\n  typeStore.OctetString = _a$r;\n})();\nOctetString.NAME = OCTET_STRING_NAME;\nclass LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\n  constructor({\n    unusedBits = 0,\n    isConstructed = false,\n    ...parameters\n  } = {}) {\n    super(parameters);\n    this.unusedBits = unusedBits;\n    this.isConstructed = isConstructed;\n    this.blockLength = this.valueHexView.byteLength;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (!inputLength) {\n      return inputOffset;\n    }\n    let resultOffset = -1;\n    if (this.isConstructed) {\n      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n      if (resultOffset === -1) return resultOffset;\n      for (const value of this.value) {\n        const currentBlockName = value.constructor.NAME;\n        if (currentBlockName === END_OF_CONTENT_NAME) {\n          if (this.isIndefiniteForm) break;else {\n            this.error = \"EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only\";\n            return -1;\n          }\n        }\n        if (currentBlockName !== BIT_STRING_NAME) {\n          this.error = \"BIT STRING may consists of BIT STRINGs only\";\n          return -1;\n        }\n        const valueBlock = value.valueBlock;\n        if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {\n          this.error = \"Using of \\\"unused bits\\\" inside constructive BIT STRING allowed for least one only\";\n          return -1;\n        }\n        this.unusedBits = valueBlock.unusedBits;\n      }\n      return resultOffset;\n    }\n    const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\n    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\n      return -1;\n    }\n    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\n    this.unusedBits = intBuffer[0];\n    if (this.unusedBits > 7) {\n      this.error = \"Unused bits for BitString must be in range 0-7\";\n      return -1;\n    }\n    if (!this.unusedBits) {\n      const buf = intBuffer.subarray(1);\n      try {\n        if (buf.byteLength) {\n          const asn = localFromBER(buf, 0, buf.byteLength);\n          if (asn.offset !== -1 && asn.offset === inputLength - 1) {\n            this.value = [asn.result];\n          }\n        }\n      } catch (e) {}\n    }\n    this.valueHexView = intBuffer.subarray(1);\n    this.blockLength = intBuffer.length;\n    return inputOffset + inputLength;\n  }\n  toBER(sizeOnly, writer) {\n    if (this.isConstructed) {\n      return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);\n    }\n    if (sizeOnly) {\n      return new ArrayBuffer(this.valueHexView.byteLength + 1);\n    }\n    if (!this.valueHexView.byteLength) {\n      return EMPTY_BUFFER;\n    }\n    const retView = new Uint8Array(this.valueHexView.length + 1);\n    retView[0] = this.unusedBits;\n    retView.set(this.valueHexView, 1);\n    return retView.buffer;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      unusedBits: this.unusedBits,\n      isConstructed: this.isConstructed\n    };\n  }\n}\nLocalBitStringValueBlock.NAME = \"BitStringValueBlock\";\nvar _a$q;\nclass BitString extends BaseBlock {\n  constructor({\n    idBlock = {},\n    lenBlock = {},\n    ...parameters\n  } = {}) {\n    var _b, _c;\n    (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);\n    super({\n      idBlock: {\n        isConstructed: parameters.isConstructed,\n        ...idBlock\n      },\n      lenBlock: {\n        ...lenBlock,\n        isIndefiniteForm: !!parameters.isIndefiniteForm\n      },\n      ...parameters\n    }, LocalBitStringValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 3;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.valueBlock.isConstructed = this.idBlock.isConstructed;\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n    return super.fromBER(inputBuffer, inputOffset, inputLength);\n  }\n  onAsciiEncoding() {\n    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {\n      return Constructed.prototype.onAsciiEncoding.call(this);\n    } else {\n      const bits = [];\n      const valueHex = this.valueBlock.valueHexView;\n      for (const byte of valueHex) {\n        bits.push(byte.toString(2).padStart(8, \"0\"));\n      }\n      const bitsStr = bits.join(\"\");\n      return `${this.constructor.NAME} : ${bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits)}`;\n    }\n  }\n}\n_a$q = BitString;\n(() => {\n  typeStore.BitString = _a$q;\n})();\nBitString.NAME = BIT_STRING_NAME;\nvar _a$p;\nfunction viewAdd(first, second) {\n  const c = new Uint8Array([0]);\n  const firstView = new Uint8Array(first);\n  const secondView = new Uint8Array(second);\n  let firstViewCopy = firstView.slice(0);\n  const firstViewCopyLength = firstViewCopy.length - 1;\n  const secondViewCopy = secondView.slice(0);\n  const secondViewCopyLength = secondViewCopy.length - 1;\n  let value = 0;\n  const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;\n  let counter = 0;\n  for (let i = max; i >= 0; i--, counter++) {\n    switch (true) {\n      case counter < secondViewCopy.length:\n        value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];\n        break;\n      default:\n        value = firstViewCopy[firstViewCopyLength - counter] + c[0];\n    }\n    c[0] = value / 10;\n    switch (true) {\n      case counter >= firstViewCopy.length:\n        firstViewCopy = pvutils.utilConcatView(new Uint8Array([value % 10]), firstViewCopy);\n        break;\n      default:\n        firstViewCopy[firstViewCopyLength - counter] = value % 10;\n    }\n  }\n  if (c[0] > 0) firstViewCopy = pvutils.utilConcatView(c, firstViewCopy);\n  return firstViewCopy;\n}\nfunction power2(n) {\n  if (n >= powers2.length) {\n    for (let p = powers2.length; p <= n; p++) {\n      const c = new Uint8Array([0]);\n      let digits = powers2[p - 1].slice(0);\n      for (let i = digits.length - 1; i >= 0; i--) {\n        const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);\n        c[0] = newValue[0] / 10;\n        digits[i] = newValue[0] % 10;\n      }\n      if (c[0] > 0) digits = pvutils.utilConcatView(c, digits);\n      powers2.push(digits);\n    }\n  }\n  return powers2[n];\n}\nfunction viewSub(first, second) {\n  let b = 0;\n  const firstView = new Uint8Array(first);\n  const secondView = new Uint8Array(second);\n  const firstViewCopy = firstView.slice(0);\n  const firstViewCopyLength = firstViewCopy.length - 1;\n  const secondViewCopy = secondView.slice(0);\n  const secondViewCopyLength = secondViewCopy.length - 1;\n  let value;\n  let counter = 0;\n  for (let i = secondViewCopyLength; i >= 0; i--, counter++) {\n    value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;\n    switch (true) {\n      case value < 0:\n        b = 1;\n        firstViewCopy[firstViewCopyLength - counter] = value + 10;\n        break;\n      default:\n        b = 0;\n        firstViewCopy[firstViewCopyLength - counter] = value;\n    }\n  }\n  if (b > 0) {\n    for (let i = firstViewCopyLength - secondViewCopyLength + 1; i >= 0; i--, counter++) {\n      value = firstViewCopy[firstViewCopyLength - counter] - b;\n      if (value < 0) {\n        b = 1;\n        firstViewCopy[firstViewCopyLength - counter] = value + 10;\n      } else {\n        b = 0;\n        firstViewCopy[firstViewCopyLength - counter] = value;\n        break;\n      }\n    }\n  }\n  return firstViewCopy.slice();\n}\nclass LocalIntegerValueBlock extends HexBlock(ValueBlock) {\n  constructor({\n    value,\n    ...parameters\n  } = {}) {\n    super(parameters);\n    this._valueDec = 0;\n    if (parameters.valueHex) {\n      this.setValueHex();\n    }\n    if (value !== undefined) {\n      this.valueDec = value;\n    }\n  }\n  setValueHex() {\n    if (this.valueHexView.length >= 4) {\n      this.warnings.push(\"Too big Integer for decoding, hex only\");\n      this.isHexOnly = true;\n      this._valueDec = 0;\n    } else {\n      this.isHexOnly = false;\n      if (this.valueHexView.length > 0) {\n        this._valueDec = pvutils.utilDecodeTC.call(this);\n      }\n    }\n  }\n  set valueDec(v) {\n    this._valueDec = v;\n    this.isHexOnly = false;\n    this.valueHexView = new Uint8Array(pvutils.utilEncodeTC(v));\n  }\n  get valueDec() {\n    return this._valueDec;\n  }\n  fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {\n    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);\n    if (offset === -1) return offset;\n    const view = this.valueHexView;\n    if (view[0] === 0x00 && (view[1] & 0x80) !== 0) {\n      this.valueHexView = view.subarray(1);\n    } else {\n      if (expectedLength !== 0) {\n        if (view.length < expectedLength) {\n          if (expectedLength - view.length > 1) expectedLength = view.length + 1;\n          this.valueHexView = view.subarray(expectedLength - view.length);\n        }\n      }\n    }\n    return offset;\n  }\n  toDER(sizeOnly = false) {\n    const view = this.valueHexView;\n    switch (true) {\n      case (view[0] & 0x80) !== 0:\n        {\n          const updatedView = new Uint8Array(this.valueHexView.length + 1);\n          updatedView[0] = 0x00;\n          updatedView.set(view, 1);\n          this.valueHexView = updatedView;\n        }\n        break;\n      case view[0] === 0x00 && (view[1] & 0x80) === 0:\n        {\n          this.valueHexView = this.valueHexView.subarray(1);\n        }\n        break;\n    }\n    return this.toBER(sizeOnly);\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n    if (resultOffset === -1) {\n      return resultOffset;\n    }\n    this.setValueHex();\n    return resultOffset;\n  }\n  toBER(sizeOnly) {\n    return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      valueDec: this.valueDec\n    };\n  }\n  toString() {\n    const firstBit = this.valueHexView.length * 8 - 1;\n    let digits = new Uint8Array(this.valueHexView.length * 8 / 3);\n    let bitNumber = 0;\n    let currentByte;\n    const asn1View = this.valueHexView;\n    let result = \"\";\n    let flag = false;\n    for (let byteNumber = asn1View.byteLength - 1; byteNumber >= 0; byteNumber--) {\n      currentByte = asn1View[byteNumber];\n      for (let i = 0; i < 8; i++) {\n        if ((currentByte & 1) === 1) {\n          switch (bitNumber) {\n            case firstBit:\n              digits = viewSub(power2(bitNumber), digits);\n              result = \"-\";\n              break;\n            default:\n              digits = viewAdd(digits, power2(bitNumber));\n          }\n        }\n        bitNumber++;\n        currentByte >>= 1;\n      }\n    }\n    for (let i = 0; i < digits.length; i++) {\n      if (digits[i]) flag = true;\n      if (flag) result += digitsString.charAt(digits[i]);\n    }\n    if (flag === false) result += digitsString.charAt(0);\n    return result;\n  }\n}\n_a$p = LocalIntegerValueBlock;\nLocalIntegerValueBlock.NAME = \"IntegerValueBlock\";\n(() => {\n  Object.defineProperty(_a$p.prototype, \"valueHex\", {\n    set: function (v) {\n      this.valueHexView = new Uint8Array(v);\n      this.setValueHex();\n    },\n    get: function () {\n      return this.valueHexView.slice().buffer;\n    }\n  });\n})();\nvar _a$o;\nclass Integer extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalIntegerValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 2;\n  }\n  toBigInt() {\n    assertBigInt();\n    return BigInt(this.valueBlock.toString());\n  }\n  static fromBigInt(value) {\n    assertBigInt();\n    const bigIntValue = BigInt(value);\n    const writer = new ViewWriter();\n    const hex = bigIntValue.toString(16).replace(/^-/, \"\");\n    const view = new Uint8Array(pvtsutils.Convert.FromHex(hex));\n    if (bigIntValue < 0) {\n      const first = new Uint8Array(view.length + (view[0] & 0x80 ? 1 : 0));\n      first[0] |= 0x80;\n      const firstInt = BigInt(`0x${pvtsutils.Convert.ToHex(first)}`);\n      const secondInt = firstInt + bigIntValue;\n      const second = pvtsutils.BufferSourceConverter.toUint8Array(pvtsutils.Convert.FromHex(secondInt.toString(16)));\n      second[0] |= 0x80;\n      writer.write(second);\n    } else {\n      if (view[0] & 0x80) {\n        writer.write(new Uint8Array([0]));\n      }\n      writer.write(view);\n    }\n    const res = new Integer({\n      valueHex: writer.final()\n    });\n    return res;\n  }\n  convertToDER() {\n    const integer = new Integer({\n      valueHex: this.valueBlock.valueHexView\n    });\n    integer.valueBlock.toDER();\n    return integer;\n  }\n  convertFromDER() {\n    return new Integer({\n      valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView\n    });\n  }\n  onAsciiEncoding() {\n    return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;\n  }\n}\n_a$o = Integer;\n(() => {\n  typeStore.Integer = _a$o;\n})();\nInteger.NAME = \"INTEGER\";\nvar _a$n;\nclass Enumerated extends Integer {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 10;\n  }\n}\n_a$n = Enumerated;\n(() => {\n  typeStore.Enumerated = _a$n;\n})();\nEnumerated.NAME = \"ENUMERATED\";\nclass LocalSidValueBlock extends HexBlock(ValueBlock) {\n  constructor({\n    valueDec = -1,\n    isFirstSid = false,\n    ...parameters\n  } = {}) {\n    super(parameters);\n    this.valueDec = valueDec;\n    this.isFirstSid = isFirstSid;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (!inputLength) {\n      return inputOffset;\n    }\n    const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\n    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\n      return -1;\n    }\n    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\n    this.valueHexView = new Uint8Array(inputLength);\n    for (let i = 0; i < inputLength; i++) {\n      this.valueHexView[i] = intBuffer[i] & 0x7F;\n      this.blockLength++;\n      if ((intBuffer[i] & 0x80) === 0x00) break;\n    }\n    const tempView = new Uint8Array(this.blockLength);\n    for (let i = 0; i < this.blockLength; i++) {\n      tempView[i] = this.valueHexView[i];\n    }\n    this.valueHexView = tempView;\n    if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\n      this.error = \"End of input reached before message was fully decoded\";\n      return -1;\n    }\n    if (this.valueHexView[0] === 0x00) this.warnings.push(\"Needlessly long format of SID encoding\");\n    if (this.blockLength <= 8) this.valueDec = pvutils.utilFromBase(this.valueHexView, 7);else {\n      this.isHexOnly = true;\n      this.warnings.push(\"Too big SID for decoding, hex only\");\n    }\n    return inputOffset + this.blockLength;\n  }\n  set valueBigInt(value) {\n    assertBigInt();\n    let bits = BigInt(value).toString(2);\n    while (bits.length % 7) {\n      bits = \"0\" + bits;\n    }\n    const bytes = new Uint8Array(bits.length / 7);\n    for (let i = 0; i < bytes.length; i++) {\n      bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0);\n    }\n    this.fromBER(bytes.buffer, 0, bytes.length);\n  }\n  toBER(sizeOnly) {\n    if (this.isHexOnly) {\n      if (sizeOnly) return new ArrayBuffer(this.valueHexView.byteLength);\n      const curView = this.valueHexView;\n      const retView = new Uint8Array(this.blockLength);\n      for (let i = 0; i < this.blockLength - 1; i++) retView[i] = curView[i] | 0x80;\n      retView[this.blockLength - 1] = curView[this.blockLength - 1];\n      return retView.buffer;\n    }\n    const encodedBuf = pvutils.utilToBase(this.valueDec, 7);\n    if (encodedBuf.byteLength === 0) {\n      this.error = \"Error during encoding SID value\";\n      return EMPTY_BUFFER;\n    }\n    const retView = new Uint8Array(encodedBuf.byteLength);\n    if (!sizeOnly) {\n      const encodedView = new Uint8Array(encodedBuf);\n      const len = encodedBuf.byteLength - 1;\n      for (let i = 0; i < len; i++) retView[i] = encodedView[i] | 0x80;\n      retView[len] = encodedView[len];\n    }\n    return retView;\n  }\n  toString() {\n    let result = \"\";\n    if (this.isHexOnly) result = pvtsutils.Convert.ToHex(this.valueHexView);else {\n      if (this.isFirstSid) {\n        let sidValue = this.valueDec;\n        if (this.valueDec <= 39) result = \"0.\";else {\n          if (this.valueDec <= 79) {\n            result = \"1.\";\n            sidValue -= 40;\n          } else {\n            result = \"2.\";\n            sidValue -= 80;\n          }\n        }\n        result += sidValue.toString();\n      } else result = this.valueDec.toString();\n    }\n    return result;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      valueDec: this.valueDec,\n      isFirstSid: this.isFirstSid\n    };\n  }\n}\nLocalSidValueBlock.NAME = \"sidBlock\";\nclass LocalObjectIdentifierValueBlock extends ValueBlock {\n  constructor({\n    value = EMPTY_STRING,\n    ...parameters\n  } = {}) {\n    super(parameters);\n    this.value = [];\n    if (value) {\n      this.fromString(value);\n    }\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    let resultOffset = inputOffset;\n    while (inputLength > 0) {\n      const sidBlock = new LocalSidValueBlock();\n      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n      if (resultOffset === -1) {\n        this.blockLength = 0;\n        this.error = sidBlock.error;\n        return resultOffset;\n      }\n      if (this.value.length === 0) sidBlock.isFirstSid = true;\n      this.blockLength += sidBlock.blockLength;\n      inputLength -= sidBlock.blockLength;\n      this.value.push(sidBlock);\n    }\n    return resultOffset;\n  }\n  toBER(sizeOnly) {\n    const retBuffers = [];\n    for (let i = 0; i < this.value.length; i++) {\n      const valueBuf = this.value[i].toBER(sizeOnly);\n      if (valueBuf.byteLength === 0) {\n        this.error = this.value[i].error;\n        return EMPTY_BUFFER;\n      }\n      retBuffers.push(valueBuf);\n    }\n    return concat(retBuffers);\n  }\n  fromString(string) {\n    this.value = [];\n    let pos1 = 0;\n    let pos2 = 0;\n    let sid = \"\";\n    let flag = false;\n    do {\n      pos2 = string.indexOf(\".\", pos1);\n      if (pos2 === -1) sid = string.substring(pos1);else sid = string.substring(pos1, pos2);\n      pos1 = pos2 + 1;\n      if (flag) {\n        const sidBlock = this.value[0];\n        let plus = 0;\n        switch (sidBlock.valueDec) {\n          case 0:\n            break;\n          case 1:\n            plus = 40;\n            break;\n          case 2:\n            plus = 80;\n            break;\n          default:\n            this.value = [];\n            return;\n        }\n        const parsedSID = parseInt(sid, 10);\n        if (isNaN(parsedSID)) return;\n        sidBlock.valueDec = parsedSID + plus;\n        flag = false;\n      } else {\n        const sidBlock = new LocalSidValueBlock();\n        if (sid > Number.MAX_SAFE_INTEGER) {\n          assertBigInt();\n          const sidValue = BigInt(sid);\n          sidBlock.valueBigInt = sidValue;\n        } else {\n          sidBlock.valueDec = parseInt(sid, 10);\n          if (isNaN(sidBlock.valueDec)) return;\n        }\n        if (!this.value.length) {\n          sidBlock.isFirstSid = true;\n          flag = true;\n        }\n        this.value.push(sidBlock);\n      }\n    } while (pos2 !== -1);\n  }\n  toString() {\n    let result = \"\";\n    let isHexOnly = false;\n    for (let i = 0; i < this.value.length; i++) {\n      isHexOnly = this.value[i].isHexOnly;\n      let sidStr = this.value[i].toString();\n      if (i !== 0) result = `${result}.`;\n      if (isHexOnly) {\n        sidStr = `{${sidStr}}`;\n        if (this.value[i].isFirstSid) result = `2.{${sidStr} - 80}`;else result += sidStr;\n      } else result += sidStr;\n    }\n    return result;\n  }\n  toJSON() {\n    const object = {\n      ...super.toJSON(),\n      value: this.toString(),\n      sidArray: []\n    };\n    for (let i = 0; i < this.value.length; i++) {\n      object.sidArray.push(this.value[i].toJSON());\n    }\n    return object;\n  }\n}\nLocalObjectIdentifierValueBlock.NAME = \"ObjectIdentifierValueBlock\";\nvar _a$m;\nclass ObjectIdentifier extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalObjectIdentifierValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 6;\n  }\n  getValue() {\n    return this.valueBlock.toString();\n  }\n  setValue(value) {\n    this.valueBlock.fromString(value);\n  }\n  onAsciiEncoding() {\n    return `${this.constructor.NAME} : ${this.valueBlock.toString() || \"empty\"}`;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      value: this.getValue()\n    };\n  }\n}\n_a$m = ObjectIdentifier;\n(() => {\n  typeStore.ObjectIdentifier = _a$m;\n})();\nObjectIdentifier.NAME = \"OBJECT IDENTIFIER\";\nclass LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {\n  constructor({\n    valueDec = 0,\n    ...parameters\n  } = {}) {\n    super(parameters);\n    this.valueDec = valueDec;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (inputLength === 0) return inputOffset;\n    const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\n    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) return -1;\n    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\n    this.valueHexView = new Uint8Array(inputLength);\n    for (let i = 0; i < inputLength; i++) {\n      this.valueHexView[i] = intBuffer[i] & 0x7F;\n      this.blockLength++;\n      if ((intBuffer[i] & 0x80) === 0x00) break;\n    }\n    const tempView = new Uint8Array(this.blockLength);\n    for (let i = 0; i < this.blockLength; i++) tempView[i] = this.valueHexView[i];\n    this.valueHexView = tempView;\n    if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\n      this.error = \"End of input reached before message was fully decoded\";\n      return -1;\n    }\n    if (this.valueHexView[0] === 0x00) this.warnings.push(\"Needlessly long format of SID encoding\");\n    if (this.blockLength <= 8) this.valueDec = pvutils.utilFromBase(this.valueHexView, 7);else {\n      this.isHexOnly = true;\n      this.warnings.push(\"Too big SID for decoding, hex only\");\n    }\n    return inputOffset + this.blockLength;\n  }\n  toBER(sizeOnly) {\n    if (this.isHexOnly) {\n      if (sizeOnly) return new ArrayBuffer(this.valueHexView.byteLength);\n      const curView = this.valueHexView;\n      const retView = new Uint8Array(this.blockLength);\n      for (let i = 0; i < this.blockLength - 1; i++) retView[i] = curView[i] | 0x80;\n      retView[this.blockLength - 1] = curView[this.blockLength - 1];\n      return retView.buffer;\n    }\n    const encodedBuf = pvutils.utilToBase(this.valueDec, 7);\n    if (encodedBuf.byteLength === 0) {\n      this.error = \"Error during encoding SID value\";\n      return EMPTY_BUFFER;\n    }\n    const retView = new Uint8Array(encodedBuf.byteLength);\n    if (!sizeOnly) {\n      const encodedView = new Uint8Array(encodedBuf);\n      const len = encodedBuf.byteLength - 1;\n      for (let i = 0; i < len; i++) retView[i] = encodedView[i] | 0x80;\n      retView[len] = encodedView[len];\n    }\n    return retView.buffer;\n  }\n  toString() {\n    let result = \"\";\n    if (this.isHexOnly) result = pvtsutils.Convert.ToHex(this.valueHexView);else {\n      result = this.valueDec.toString();\n    }\n    return result;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      valueDec: this.valueDec\n    };\n  }\n}\nLocalRelativeSidValueBlock.NAME = \"relativeSidBlock\";\nclass LocalRelativeObjectIdentifierValueBlock extends ValueBlock {\n  constructor({\n    value = EMPTY_STRING,\n    ...parameters\n  } = {}) {\n    super(parameters);\n    this.value = [];\n    if (value) {\n      this.fromString(value);\n    }\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    let resultOffset = inputOffset;\n    while (inputLength > 0) {\n      const sidBlock = new LocalRelativeSidValueBlock();\n      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n      if (resultOffset === -1) {\n        this.blockLength = 0;\n        this.error = sidBlock.error;\n        return resultOffset;\n      }\n      this.blockLength += sidBlock.blockLength;\n      inputLength -= sidBlock.blockLength;\n      this.value.push(sidBlock);\n    }\n    return resultOffset;\n  }\n  toBER(sizeOnly, writer) {\n    const retBuffers = [];\n    for (let i = 0; i < this.value.length; i++) {\n      const valueBuf = this.value[i].toBER(sizeOnly);\n      if (valueBuf.byteLength === 0) {\n        this.error = this.value[i].error;\n        return EMPTY_BUFFER;\n      }\n      retBuffers.push(valueBuf);\n    }\n    return concat(retBuffers);\n  }\n  fromString(string) {\n    this.value = [];\n    let pos1 = 0;\n    let pos2 = 0;\n    let sid = \"\";\n    do {\n      pos2 = string.indexOf(\".\", pos1);\n      if (pos2 === -1) sid = string.substring(pos1);else sid = string.substring(pos1, pos2);\n      pos1 = pos2 + 1;\n      const sidBlock = new LocalRelativeSidValueBlock();\n      sidBlock.valueDec = parseInt(sid, 10);\n      if (isNaN(sidBlock.valueDec)) return true;\n      this.value.push(sidBlock);\n    } while (pos2 !== -1);\n    return true;\n  }\n  toString() {\n    let result = \"\";\n    let isHexOnly = false;\n    for (let i = 0; i < this.value.length; i++) {\n      isHexOnly = this.value[i].isHexOnly;\n      let sidStr = this.value[i].toString();\n      if (i !== 0) result = `${result}.`;\n      if (isHexOnly) {\n        sidStr = `{${sidStr}}`;\n        result += sidStr;\n      } else result += sidStr;\n    }\n    return result;\n  }\n  toJSON() {\n    const object = {\n      ...super.toJSON(),\n      value: this.toString(),\n      sidArray: []\n    };\n    for (let i = 0; i < this.value.length; i++) object.sidArray.push(this.value[i].toJSON());\n    return object;\n  }\n}\nLocalRelativeObjectIdentifierValueBlock.NAME = \"RelativeObjectIdentifierValueBlock\";\nvar _a$l;\nclass RelativeObjectIdentifier extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalRelativeObjectIdentifierValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 13;\n  }\n  getValue() {\n    return this.valueBlock.toString();\n  }\n  setValue(value) {\n    this.valueBlock.fromString(value);\n  }\n  onAsciiEncoding() {\n    return `${this.constructor.NAME} : ${this.valueBlock.toString() || \"empty\"}`;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      value: this.getValue()\n    };\n  }\n}\n_a$l = RelativeObjectIdentifier;\n(() => {\n  typeStore.RelativeObjectIdentifier = _a$l;\n})();\nRelativeObjectIdentifier.NAME = \"RelativeObjectIdentifier\";\nvar _a$k;\nclass Sequence extends Constructed {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 16;\n  }\n}\n_a$k = Sequence;\n(() => {\n  typeStore.Sequence = _a$k;\n})();\nSequence.NAME = \"SEQUENCE\";\nvar _a$j;\nclass Set extends Constructed {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 17;\n  }\n}\n_a$j = Set;\n(() => {\n  typeStore.Set = _a$j;\n})();\nSet.NAME = \"SET\";\nclass LocalStringValueBlock extends HexBlock(ValueBlock) {\n  constructor({\n    ...parameters\n  } = {}) {\n    super(parameters);\n    this.isHexOnly = true;\n    this.value = EMPTY_STRING;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      value: this.value\n    };\n  }\n}\nLocalStringValueBlock.NAME = \"StringValueBlock\";\nclass LocalSimpleStringValueBlock extends LocalStringValueBlock {}\nLocalSimpleStringValueBlock.NAME = \"SimpleStringValueBlock\";\nclass LocalSimpleStringBlock extends BaseStringBlock {\n  constructor({\n    ...parameters\n  } = {}) {\n    super(parameters, LocalSimpleStringValueBlock);\n  }\n  fromBuffer(inputBuffer) {\n    this.valueBlock.value = String.fromCharCode.apply(null, pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer));\n  }\n  fromString(inputString) {\n    const strLen = inputString.length;\n    const view = this.valueBlock.valueHexView = new Uint8Array(strLen);\n    for (let i = 0; i < strLen; i++) view[i] = inputString.charCodeAt(i);\n    this.valueBlock.value = inputString;\n  }\n}\nLocalSimpleStringBlock.NAME = \"SIMPLE STRING\";\nclass LocalUtf8StringValueBlock extends LocalSimpleStringBlock {\n  fromBuffer(inputBuffer) {\n    this.valueBlock.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\n    try {\n      this.valueBlock.value = pvtsutils.Convert.ToUtf8String(inputBuffer);\n    } catch (ex) {\n      this.warnings.push(`Error during \"decodeURIComponent\": ${ex}, using raw string`);\n      this.valueBlock.value = pvtsutils.Convert.ToBinary(inputBuffer);\n    }\n  }\n  fromString(inputString) {\n    this.valueBlock.valueHexView = new Uint8Array(pvtsutils.Convert.FromUtf8String(inputString));\n    this.valueBlock.value = inputString;\n  }\n}\nLocalUtf8StringValueBlock.NAME = \"Utf8StringValueBlock\";\nvar _a$i;\nclass Utf8String extends LocalUtf8StringValueBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 12;\n  }\n}\n_a$i = Utf8String;\n(() => {\n  typeStore.Utf8String = _a$i;\n})();\nUtf8String.NAME = \"UTF8String\";\nclass LocalBmpStringValueBlock extends LocalSimpleStringBlock {\n  fromBuffer(inputBuffer) {\n    this.valueBlock.value = pvtsutils.Convert.ToUtf16String(inputBuffer);\n    this.valueBlock.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\n  }\n  fromString(inputString) {\n    this.valueBlock.value = inputString;\n    this.valueBlock.valueHexView = new Uint8Array(pvtsutils.Convert.FromUtf16String(inputString));\n  }\n}\nLocalBmpStringValueBlock.NAME = \"BmpStringValueBlock\";\nvar _a$h;\nclass BmpString extends LocalBmpStringValueBlock {\n  constructor({\n    ...parameters\n  } = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 30;\n  }\n}\n_a$h = BmpString;\n(() => {\n  typeStore.BmpString = _a$h;\n})();\nBmpString.NAME = \"BMPString\";\nclass LocalUniversalStringValueBlock extends LocalSimpleStringBlock {\n  fromBuffer(inputBuffer) {\n    const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);\n    const valueView = new Uint8Array(copyBuffer);\n    for (let i = 0; i < valueView.length; i += 4) {\n      valueView[i] = valueView[i + 3];\n      valueView[i + 1] = valueView[i + 2];\n      valueView[i + 2] = 0x00;\n      valueView[i + 3] = 0x00;\n    }\n    this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));\n  }\n  fromString(inputString) {\n    const strLength = inputString.length;\n    const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);\n    for (let i = 0; i < strLength; i++) {\n      const codeBuf = pvutils.utilToBase(inputString.charCodeAt(i), 8);\n      const codeView = new Uint8Array(codeBuf);\n      if (codeView.length > 4) continue;\n      const dif = 4 - codeView.length;\n      for (let j = codeView.length - 1; j >= 0; j--) valueHexView[i * 4 + j + dif] = codeView[j];\n    }\n    this.valueBlock.value = inputString;\n  }\n}\nLocalUniversalStringValueBlock.NAME = \"UniversalStringValueBlock\";\nvar _a$g;\nclass UniversalString extends LocalUniversalStringValueBlock {\n  constructor({\n    ...parameters\n  } = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 28;\n  }\n}\n_a$g = UniversalString;\n(() => {\n  typeStore.UniversalString = _a$g;\n})();\nUniversalString.NAME = \"UniversalString\";\nvar _a$f;\nclass NumericString extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 18;\n  }\n}\n_a$f = NumericString;\n(() => {\n  typeStore.NumericString = _a$f;\n})();\nNumericString.NAME = \"NumericString\";\nvar _a$e;\nclass PrintableString extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 19;\n  }\n}\n_a$e = PrintableString;\n(() => {\n  typeStore.PrintableString = _a$e;\n})();\nPrintableString.NAME = \"PrintableString\";\nvar _a$d;\nclass TeletexString extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 20;\n  }\n}\n_a$d = TeletexString;\n(() => {\n  typeStore.TeletexString = _a$d;\n})();\nTeletexString.NAME = \"TeletexString\";\nvar _a$c;\nclass VideotexString extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 21;\n  }\n}\n_a$c = VideotexString;\n(() => {\n  typeStore.VideotexString = _a$c;\n})();\nVideotexString.NAME = \"VideotexString\";\nvar _a$b;\nclass IA5String extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 22;\n  }\n}\n_a$b = IA5String;\n(() => {\n  typeStore.IA5String = _a$b;\n})();\nIA5String.NAME = \"IA5String\";\nvar _a$a;\nclass GraphicString extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 25;\n  }\n}\n_a$a = GraphicString;\n(() => {\n  typeStore.GraphicString = _a$a;\n})();\nGraphicString.NAME = \"GraphicString\";\nvar _a$9;\nclass VisibleString extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 26;\n  }\n}\n_a$9 = VisibleString;\n(() => {\n  typeStore.VisibleString = _a$9;\n})();\nVisibleString.NAME = \"VisibleString\";\nvar _a$8;\nclass GeneralString extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 27;\n  }\n}\n_a$8 = GeneralString;\n(() => {\n  typeStore.GeneralString = _a$8;\n})();\nGeneralString.NAME = \"GeneralString\";\nvar _a$7;\nclass CharacterString extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 29;\n  }\n}\n_a$7 = CharacterString;\n(() => {\n  typeStore.CharacterString = _a$7;\n})();\nCharacterString.NAME = \"CharacterString\";\nvar _a$6;\nclass UTCTime extends VisibleString {\n  constructor({\n    value,\n    valueDate,\n    ...parameters\n  } = {}) {\n    super(parameters);\n    this.year = 0;\n    this.month = 0;\n    this.day = 0;\n    this.hour = 0;\n    this.minute = 0;\n    this.second = 0;\n    if (value) {\n      this.fromString(value);\n      this.valueBlock.valueHexView = new Uint8Array(value.length);\n      for (let i = 0; i < value.length; i++) this.valueBlock.valueHexView[i] = value.charCodeAt(i);\n    }\n    if (valueDate) {\n      this.fromDate(valueDate);\n      this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());\n    }\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 23;\n  }\n  fromBuffer(inputBuffer) {\n    this.fromString(String.fromCharCode.apply(null, pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer)));\n  }\n  toBuffer() {\n    const str = this.toString();\n    const buffer = new ArrayBuffer(str.length);\n    const view = new Uint8Array(buffer);\n    for (let i = 0; i < str.length; i++) view[i] = str.charCodeAt(i);\n    return buffer;\n  }\n  fromDate(inputDate) {\n    this.year = inputDate.getUTCFullYear();\n    this.month = inputDate.getUTCMonth() + 1;\n    this.day = inputDate.getUTCDate();\n    this.hour = inputDate.getUTCHours();\n    this.minute = inputDate.getUTCMinutes();\n    this.second = inputDate.getUTCSeconds();\n  }\n  toDate() {\n    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));\n  }\n  fromString(inputString) {\n    const parser = /(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z/ig;\n    const parserArray = parser.exec(inputString);\n    if (parserArray === null) {\n      this.error = \"Wrong input string for conversion\";\n      return;\n    }\n    const year = parseInt(parserArray[1], 10);\n    if (year >= 50) this.year = 1900 + year;else this.year = 2000 + year;\n    this.month = parseInt(parserArray[2], 10);\n    this.day = parseInt(parserArray[3], 10);\n    this.hour = parseInt(parserArray[4], 10);\n    this.minute = parseInt(parserArray[5], 10);\n    this.second = parseInt(parserArray[6], 10);\n  }\n  toString(encoding = \"iso\") {\n    if (encoding === \"iso\") {\n      const outputArray = new Array(7);\n      outputArray[0] = pvutils.padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);\n      outputArray[1] = pvutils.padNumber(this.month, 2);\n      outputArray[2] = pvutils.padNumber(this.day, 2);\n      outputArray[3] = pvutils.padNumber(this.hour, 2);\n      outputArray[4] = pvutils.padNumber(this.minute, 2);\n      outputArray[5] = pvutils.padNumber(this.second, 2);\n      outputArray[6] = \"Z\";\n      return outputArray.join(\"\");\n    }\n    return super.toString(encoding);\n  }\n  onAsciiEncoding() {\n    return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      year: this.year,\n      month: this.month,\n      day: this.day,\n      hour: this.hour,\n      minute: this.minute,\n      second: this.second\n    };\n  }\n}\n_a$6 = UTCTime;\n(() => {\n  typeStore.UTCTime = _a$6;\n})();\nUTCTime.NAME = \"UTCTime\";\nvar _a$5;\nclass GeneralizedTime extends UTCTime {\n  constructor(parameters = {}) {\n    var _b;\n    super(parameters);\n    (_b = this.millisecond) !== null && _b !== void 0 ? _b : this.millisecond = 0;\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 24;\n  }\n  fromDate(inputDate) {\n    super.fromDate(inputDate);\n    this.millisecond = inputDate.getUTCMilliseconds();\n  }\n  toDate() {\n    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));\n  }\n  fromString(inputString) {\n    let isUTC = false;\n    let timeString = \"\";\n    let dateTimeString = \"\";\n    let fractionPart = 0;\n    let parser;\n    let hourDifference = 0;\n    let minuteDifference = 0;\n    if (inputString[inputString.length - 1] === \"Z\") {\n      timeString = inputString.substring(0, inputString.length - 1);\n      isUTC = true;\n    } else {\n      const number = new Number(inputString[inputString.length - 1]);\n      if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for conversion\");\n      timeString = inputString;\n    }\n    if (isUTC) {\n      if (timeString.indexOf(\"+\") !== -1) throw new Error(\"Wrong input string for conversion\");\n      if (timeString.indexOf(\"-\") !== -1) throw new Error(\"Wrong input string for conversion\");\n    } else {\n      let multiplier = 1;\n      let differencePosition = timeString.indexOf(\"+\");\n      let differenceString = \"\";\n      if (differencePosition === -1) {\n        differencePosition = timeString.indexOf(\"-\");\n        multiplier = -1;\n      }\n      if (differencePosition !== -1) {\n        differenceString = timeString.substring(differencePosition + 1);\n        timeString = timeString.substring(0, differencePosition);\n        if (differenceString.length !== 2 && differenceString.length !== 4) throw new Error(\"Wrong input string for conversion\");\n        let number = parseInt(differenceString.substring(0, 2), 10);\n        if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for conversion\");\n        hourDifference = multiplier * number;\n        if (differenceString.length === 4) {\n          number = parseInt(differenceString.substring(2, 4), 10);\n          if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for conversion\");\n          minuteDifference = multiplier * number;\n        }\n      }\n    }\n    let fractionPointPosition = timeString.indexOf(\".\");\n    if (fractionPointPosition === -1) fractionPointPosition = timeString.indexOf(\",\");\n    if (fractionPointPosition !== -1) {\n      const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);\n      if (isNaN(fractionPartCheck.valueOf())) throw new Error(\"Wrong input string for conversion\");\n      fractionPart = fractionPartCheck.valueOf();\n      dateTimeString = timeString.substring(0, fractionPointPosition);\n    } else dateTimeString = timeString;\n    switch (true) {\n      case dateTimeString.length === 8:\n        parser = /(\\d{4})(\\d{2})(\\d{2})/ig;\n        if (fractionPointPosition !== -1) throw new Error(\"Wrong input string for conversion\");\n        break;\n      case dateTimeString.length === 10:\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})/ig;\n        if (fractionPointPosition !== -1) {\n          let fractionResult = 60 * fractionPart;\n          this.minute = Math.floor(fractionResult);\n          fractionResult = 60 * (fractionResult - this.minute);\n          this.second = Math.floor(fractionResult);\n          fractionResult = 1000 * (fractionResult - this.second);\n          this.millisecond = Math.floor(fractionResult);\n        }\n        break;\n      case dateTimeString.length === 12:\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n        if (fractionPointPosition !== -1) {\n          let fractionResult = 60 * fractionPart;\n          this.second = Math.floor(fractionResult);\n          fractionResult = 1000 * (fractionResult - this.second);\n          this.millisecond = Math.floor(fractionResult);\n        }\n        break;\n      case dateTimeString.length === 14:\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n        if (fractionPointPosition !== -1) {\n          const fractionResult = 1000 * fractionPart;\n          this.millisecond = Math.floor(fractionResult);\n        }\n        break;\n      default:\n        throw new Error(\"Wrong input string for conversion\");\n    }\n    const parserArray = parser.exec(dateTimeString);\n    if (parserArray === null) throw new Error(\"Wrong input string for conversion\");\n    for (let j = 1; j < parserArray.length; j++) {\n      switch (j) {\n        case 1:\n          this.year = parseInt(parserArray[j], 10);\n          break;\n        case 2:\n          this.month = parseInt(parserArray[j], 10);\n          break;\n        case 3:\n          this.day = parseInt(parserArray[j], 10);\n          break;\n        case 4:\n          this.hour = parseInt(parserArray[j], 10) + hourDifference;\n          break;\n        case 5:\n          this.minute = parseInt(parserArray[j], 10) + minuteDifference;\n          break;\n        case 6:\n          this.second = parseInt(parserArray[j], 10);\n          break;\n        default:\n          throw new Error(\"Wrong input string for conversion\");\n      }\n    }\n    if (isUTC === false) {\n      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\n      this.year = tempDate.getUTCFullYear();\n      this.month = tempDate.getUTCMonth();\n      this.day = tempDate.getUTCDay();\n      this.hour = tempDate.getUTCHours();\n      this.minute = tempDate.getUTCMinutes();\n      this.second = tempDate.getUTCSeconds();\n      this.millisecond = tempDate.getUTCMilliseconds();\n    }\n  }\n  toString(encoding = \"iso\") {\n    if (encoding === \"iso\") {\n      const outputArray = [];\n      outputArray.push(pvutils.padNumber(this.year, 4));\n      outputArray.push(pvutils.padNumber(this.month, 2));\n      outputArray.push(pvutils.padNumber(this.day, 2));\n      outputArray.push(pvutils.padNumber(this.hour, 2));\n      outputArray.push(pvutils.padNumber(this.minute, 2));\n      outputArray.push(pvutils.padNumber(this.second, 2));\n      if (this.millisecond !== 0) {\n        outputArray.push(\".\");\n        outputArray.push(pvutils.padNumber(this.millisecond, 3));\n      }\n      outputArray.push(\"Z\");\n      return outputArray.join(\"\");\n    }\n    return super.toString(encoding);\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      millisecond: this.millisecond\n    };\n  }\n}\n_a$5 = GeneralizedTime;\n(() => {\n  typeStore.GeneralizedTime = _a$5;\n})();\nGeneralizedTime.NAME = \"GeneralizedTime\";\nvar _a$4;\nclass DATE extends Utf8String {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 31;\n  }\n}\n_a$4 = DATE;\n(() => {\n  typeStore.DATE = _a$4;\n})();\nDATE.NAME = \"DATE\";\nvar _a$3;\nclass TimeOfDay extends Utf8String {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 32;\n  }\n}\n_a$3 = TimeOfDay;\n(() => {\n  typeStore.TimeOfDay = _a$3;\n})();\nTimeOfDay.NAME = \"TimeOfDay\";\nvar _a$2;\nclass DateTime extends Utf8String {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 33;\n  }\n}\n_a$2 = DateTime;\n(() => {\n  typeStore.DateTime = _a$2;\n})();\nDateTime.NAME = \"DateTime\";\nvar _a$1;\nclass Duration extends Utf8String {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 34;\n  }\n}\n_a$1 = Duration;\n(() => {\n  typeStore.Duration = _a$1;\n})();\nDuration.NAME = \"Duration\";\nvar _a;\nclass TIME extends Utf8String {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 14;\n  }\n}\n_a = TIME;\n(() => {\n  typeStore.TIME = _a;\n})();\nTIME.NAME = \"TIME\";\nclass Any {\n  constructor({\n    name = EMPTY_STRING,\n    optional = false\n  } = {}) {\n    this.name = name;\n    this.optional = optional;\n  }\n}\nclass Choice extends Any {\n  constructor({\n    value = [],\n    ...parameters\n  } = {}) {\n    super(parameters);\n    this.value = value;\n  }\n}\nclass Repeated extends Any {\n  constructor({\n    value = new Any(),\n    local = false,\n    ...parameters\n  } = {}) {\n    super(parameters);\n    this.value = value;\n    this.local = local;\n  }\n}\nclass RawData {\n  constructor({\n    data = EMPTY_VIEW\n  } = {}) {\n    this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(data);\n  }\n  get data() {\n    return this.dataView.slice().buffer;\n  }\n  set data(value) {\n    this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(value);\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const endLength = inputOffset + inputLength;\n    this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);\n    return endLength;\n  }\n  toBER(sizeOnly) {\n    return this.dataView.slice().buffer;\n  }\n}\nfunction compareSchema(root, inputData, inputSchema) {\n  if (inputSchema instanceof Choice) {\n    for (let j = 0; j < inputSchema.value.length; j++) {\n      const result = compareSchema(root, inputData, inputSchema.value[j]);\n      if (result.verified) {\n        return {\n          verified: true,\n          result: root\n        };\n      }\n    }\n    {\n      const _result = {\n        verified: false,\n        result: {\n          error: \"Wrong values for Choice type\"\n        }\n      };\n      if (inputSchema.hasOwnProperty(NAME)) _result.name = inputSchema.name;\n      return _result;\n    }\n  }\n  if (inputSchema instanceof Any) {\n    if (inputSchema.hasOwnProperty(NAME)) root[inputSchema.name] = inputData;\n    return {\n      verified: true,\n      result: root\n    };\n  }\n  if (root instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong root object\"\n      }\n    };\n  }\n  if (inputData instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 data\"\n      }\n    };\n  }\n  if (inputSchema instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n  if (ID_BLOCK in inputSchema === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n  if (FROM_BER in inputSchema.idBlock === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n  if (TO_BER in inputSchema.idBlock === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n  const encodedId = inputSchema.idBlock.toBER(false);\n  if (encodedId.byteLength === 0) {\n    return {\n      verified: false,\n      result: {\n        error: \"Error encoding idBlock for ASN.1 schema\"\n      }\n    };\n  }\n  const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);\n  if (decodedOffset === -1) {\n    return {\n      verified: false,\n      result: {\n        error: \"Error decoding idBlock for ASN.1 schema\"\n      }\n    };\n  }\n  if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n  if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {\n    return {\n      verified: false,\n      result: root\n    };\n  }\n  if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n  if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {\n    return {\n      verified: false,\n      result: root\n    };\n  }\n  if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n  if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {\n    return {\n      verified: false,\n      result: root\n    };\n  }\n  if (!(IS_HEX_ONLY in inputSchema.idBlock)) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n  if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {\n    return {\n      verified: false,\n      result: root\n    };\n  }\n  if (inputSchema.idBlock.isHexOnly) {\n    if (VALUE_HEX_VIEW in inputSchema.idBlock === false) {\n      return {\n        verified: false,\n        result: {\n          error: \"Wrong ASN.1 schema\"\n        }\n      };\n    }\n    const schemaView = inputSchema.idBlock.valueHexView;\n    const asn1View = inputData.idBlock.valueHexView;\n    if (schemaView.length !== asn1View.length) {\n      return {\n        verified: false,\n        result: root\n      };\n    }\n    for (let i = 0; i < schemaView.length; i++) {\n      if (schemaView[i] !== asn1View[1]) {\n        return {\n          verified: false,\n          result: root\n        };\n      }\n    }\n  }\n  if (inputSchema.name) {\n    inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n    if (inputSchema.name) root[inputSchema.name] = inputData;\n  }\n  if (inputSchema instanceof typeStore.Constructed) {\n    let admission = 0;\n    let result = {\n      verified: false,\n      result: {\n        error: \"Unknown error\"\n      }\n    };\n    let maxLength = inputSchema.valueBlock.value.length;\n    if (maxLength > 0) {\n      if (inputSchema.valueBlock.value[0] instanceof Repeated) {\n        maxLength = inputData.valueBlock.value.length;\n      }\n    }\n    if (maxLength === 0) {\n      return {\n        verified: true,\n        result: root\n      };\n    }\n    if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {\n      let _optional = true;\n      for (let i = 0; i < inputSchema.valueBlock.value.length; i++) _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);\n      if (_optional) {\n        return {\n          verified: true,\n          result: root\n        };\n      }\n      if (inputSchema.name) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n        if (inputSchema.name) delete root[inputSchema.name];\n      }\n      root.error = \"Inconsistent object length\";\n      return {\n        verified: false,\n        result: root\n      };\n    }\n    for (let i = 0; i < maxLength; i++) {\n      if (i - admission >= inputData.valueBlock.value.length) {\n        if (inputSchema.valueBlock.value[i].optional === false) {\n          const _result = {\n            verified: false,\n            result: root\n          };\n          root.error = \"Inconsistent length between ASN.1 data and schema\";\n          if (inputSchema.name) {\n            inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n            if (inputSchema.name) {\n              delete root[inputSchema.name];\n              _result.name = inputSchema.name;\n            }\n          }\n          return _result;\n        }\n      } else {\n        if (inputSchema.valueBlock.value[0] instanceof Repeated) {\n          result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);\n          if (result.verified === false) {\n            if (inputSchema.valueBlock.value[0].optional) admission++;else {\n              if (inputSchema.name) {\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n                if (inputSchema.name) delete root[inputSchema.name];\n              }\n              return result;\n            }\n          }\n          if (NAME in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {\n            let arrayRoot = {};\n            if (LOCAL in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local) arrayRoot = inputData;else arrayRoot = root;\n            if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === \"undefined\") arrayRoot[inputSchema.valueBlock.value[0].name] = [];\n            arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);\n          }\n        } else {\n          result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);\n          if (result.verified === false) {\n            if (inputSchema.valueBlock.value[i].optional) admission++;else {\n              if (inputSchema.name) {\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n                if (inputSchema.name) delete root[inputSchema.name];\n              }\n              return result;\n            }\n          }\n        }\n      }\n    }\n    if (result.verified === false) {\n      const _result = {\n        verified: false,\n        result: root\n      };\n      if (inputSchema.name) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n        if (inputSchema.name) {\n          delete root[inputSchema.name];\n          _result.name = inputSchema.name;\n        }\n      }\n      return _result;\n    }\n    return {\n      verified: true,\n      result: root\n    };\n  }\n  if (inputSchema.primitiveSchema && VALUE_HEX_VIEW in inputData.valueBlock) {\n    const asn1 = localFromBER(inputData.valueBlock.valueHexView);\n    if (asn1.offset === -1) {\n      const _result = {\n        verified: false,\n        result: asn1.result\n      };\n      if (inputSchema.name) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n        if (inputSchema.name) {\n          delete root[inputSchema.name];\n          _result.name = inputSchema.name;\n        }\n      }\n      return _result;\n    }\n    return compareSchema(root, asn1.result, inputSchema.primitiveSchema);\n  }\n  return {\n    verified: true,\n    result: root\n  };\n}\nfunction verifySchema(inputBuffer, inputSchema) {\n  if (inputSchema instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema type\"\n      }\n    };\n  }\n  const asn1 = localFromBER(pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer));\n  if (asn1.offset === -1) {\n    return {\n      verified: false,\n      result: asn1.result\n    };\n  }\n  return compareSchema(asn1.result, asn1.result, inputSchema);\n}\nexport { Any, BaseBlock, BaseStringBlock, BitString, BmpString, Boolean, CharacterString, Choice, Constructed, DATE, DateTime, Duration, EndOfContent, Enumerated, GeneralString, GeneralizedTime, GraphicString, HexBlock, IA5String, Integer, Null, NumericString, ObjectIdentifier, OctetString, Primitive, PrintableString, RawData, RelativeObjectIdentifier, Repeated, Sequence, Set, TIME, TeletexString, TimeOfDay, UTCTime, UniversalString, Utf8String, ValueBlock, VideotexString, ViewWriter, VisibleString, compareSchema, fromBER, verifySchema };","map":{"version":3,"names":["pvtsutils","pvutils","assertBigInt","BigInt","Error","concat","buffers","outputLength","prevLength","i","length","buffer","byteLength","retView","Uint8Array","set","checkBufferParams","baseBlock","inputBuffer","inputOffset","inputLength","error","ViewWriter","constructor","items","write","buf","push","final","powers2","digitsString","NAME","VALUE_HEX_VIEW","IS_HEX_ONLY","ID_BLOCK","TAG_CLASS","TAG_NUMBER","IS_CONSTRUCTED","FROM_BER","TO_BER","LOCAL","EMPTY_STRING","EMPTY_BUFFER","ArrayBuffer","EMPTY_VIEW","END_OF_CONTENT_NAME","OCTET_STRING_NAME","BIT_STRING_NAME","HexBlock","BaseClass","_a","Some","args","params","isHexOnly","valueHexView","valueHex","BufferSourceConverter","toUint8Array","slice","value","fromBER","view","endLength","subarray","warnings","blockLength","toBER","sizeOnly","toJSON","Convert","ToHex","LocalBaseBlock","valueBeforeDecode","valueBeforeDecodeView","blockName","ValueBlock","TypeError","writer","LocalIdentificationBlock","idBlock","_b","_c","_d","tagClass","tagNumber","isConstructed","firstOctet","number","encodedBuf","utilToBase","encodedView","size","curView","inputView","intBuffer","tagClassMask","tagNumberMask","count","intTagNumberBuffer","tagNumberBufferMaxLength","tempBufferView","utilFromBase","LocalLengthBlock","lenBlock","isIndefiniteForm","longFormUsed","lenOffset","lengthBufferView","retBuf","typeStore","BaseBlock","name","optional","primitiveSchema","parameters","valueBlockType","valueBlock","resultOffset","_writer","prepareIndefiniteForm","idBlockBuf","valueBlockBuf","lenBlockBuf","object","toString","encoding","onAsciiEncoding","isEqual","other","thisRaw","otherRaw","isEqualBuffer","Constructed","BaseStringBlock","stringValueBlockType","fromString","getValue","setValue","fromBuffer","LocalPrimitiveValueBlock","_a$w","Primitive","localChangeType","inputObject","newType","newObject","localFromBER","incomingOffset","returnObject","offset","result","newASN1Type","EndOfContent","Boolean","Integer","BitString","OctetString","Null","ObjectIdentifier","Enumerated","Utf8String","RelativeObjectIdentifier","TIME","Sequence","Set","NumericString","PrintableString","TeletexString","VideotexString","IA5String","UTCTime","GeneralizedTime","GraphicString","VisibleString","GeneralString","UniversalString","CharacterString","BmpString","DATE","TimeOfDay","DateTime","Duration","checkLen","indefiniteLength","LocalConstructedValueBlock","currentOffset","pop","_a$v","values","split","map","o","join","LocalEndOfContentValueBlock","override","_a$u","_a$t","LocalBooleanValueBlock","octet","utilDecodeTC","call","_a$s","LocalOctetStringValueBlock","prototype","currentBlockName","_a$r","asn","e","array","content","LocalBitStringValueBlock","unusedBits","_a$q","bits","byte","padStart","bitsStr","substring","_a$p","viewAdd","first","second","c","firstView","secondView","firstViewCopy","firstViewCopyLength","secondViewCopy","secondViewCopyLength","max","counter","utilConcatView","power2","n","p","digits","newValue","viewSub","b","LocalIntegerValueBlock","_valueDec","setValueHex","undefined","valueDec","v","utilEncodeTC","fromDER","expectedLength","toDER","updatedView","firstBit","bitNumber","currentByte","asn1View","flag","byteNumber","charAt","Object","defineProperty","get","_a$o","toBigInt","fromBigInt","bigIntValue","hex","replace","FromHex","firstInt","secondInt","res","convertToDER","integer","convertFromDER","_a$n","LocalSidValueBlock","isFirstSid","tempView","valueBigInt","bytes","parseInt","len","sidValue","LocalObjectIdentifierValueBlock","sidBlock","retBuffers","valueBuf","string","pos1","pos2","sid","indexOf","plus","parsedSID","isNaN","Number","MAX_SAFE_INTEGER","sidStr","sidArray","_a$m","LocalRelativeSidValueBlock","LocalRelativeObjectIdentifierValueBlock","_a$l","_a$k","_a$j","LocalStringValueBlock","LocalSimpleStringValueBlock","LocalSimpleStringBlock","String","fromCharCode","apply","inputString","strLen","charCodeAt","LocalUtf8StringValueBlock","ToUtf8String","ex","ToBinary","FromUtf8String","_a$i","LocalBmpStringValueBlock","ToUtf16String","FromUtf16String","_a$h","LocalUniversalStringValueBlock","copyBuffer","isView","valueView","Uint32Array","strLength","codeBuf","codeView","dif","j","_a$g","_a$f","_a$e","_a$d","_a$c","_a$b","_a$a","_a$9","_a$8","_a$7","_a$6","valueDate","year","month","day","hour","minute","fromDate","toBuffer","str","inputDate","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","toDate","Date","UTC","parser","parserArray","exec","outputArray","Array","padNumber","toISOString","_a$5","millisecond","getUTCMilliseconds","isUTC","timeString","dateTimeString","fractionPart","hourDifference","minuteDifference","valueOf","multiplier","differencePosition","differenceString","fractionPointPosition","fractionPartCheck","fractionResult","Math","floor","tempDate","getUTCDay","_a$4","_a$3","_a$2","_a$1","Any","Choice","Repeated","local","RawData","data","dataView","compareSchema","root","inputData","inputSchema","verified","_result","hasOwnProperty","encodedId","decodedOffset","schemaView","admission","maxLength","_optional","arrayRoot","asn1","verifySchema"],"sources":["/Users/peterchen/Dropbox/Hexlink/Projects/pwa-demo/node_modules/asn1js/build/index.es.js"],"sourcesContent":["/*!\n * Copyright (c) 2014, GMO GlobalSign\n * Copyright (c) 2015-2022, Peculiar Ventures\n * All rights reserved.\n * \n * Author 2014-2019, Yury Strozhevsky\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n * \n * * Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n * \n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n */\n\nimport * as pvtsutils from 'pvtsutils';\nimport * as pvutils from 'pvutils';\n\nfunction assertBigInt() {\r\n    if (typeof BigInt === \"undefined\") {\r\n        throw new Error(\"BigInt is not defined. Your environment doesn't implement BigInt.\");\r\n    }\r\n}\r\nfunction concat(buffers) {\r\n    let outputLength = 0;\r\n    let prevLength = 0;\r\n    for (let i = 0; i < buffers.length; i++) {\r\n        const buffer = buffers[i];\r\n        outputLength += buffer.byteLength;\r\n    }\r\n    const retView = new Uint8Array(outputLength);\r\n    for (let i = 0; i < buffers.length; i++) {\r\n        const buffer = buffers[i];\r\n        retView.set(new Uint8Array(buffer), prevLength);\r\n        prevLength += buffer.byteLength;\r\n    }\r\n    return retView.buffer;\r\n}\r\nfunction checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {\r\n    if (!(inputBuffer instanceof Uint8Array)) {\r\n        baseBlock.error = \"Wrong parameter: inputBuffer must be 'Uint8Array'\";\r\n        return false;\r\n    }\r\n    if (!inputBuffer.byteLength) {\r\n        baseBlock.error = \"Wrong parameter: inputBuffer has zero length\";\r\n        return false;\r\n    }\r\n    if (inputOffset < 0) {\r\n        baseBlock.error = \"Wrong parameter: inputOffset less than zero\";\r\n        return false;\r\n    }\r\n    if (inputLength < 0) {\r\n        baseBlock.error = \"Wrong parameter: inputLength less than zero\";\r\n        return false;\r\n    }\r\n    if ((inputBuffer.byteLength - inputOffset - inputLength) < 0) {\r\n        baseBlock.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\r\n        return false;\r\n    }\r\n    return true;\r\n}\n\nclass ViewWriter {\r\n    constructor() {\r\n        this.items = [];\r\n    }\r\n    write(buf) {\r\n        this.items.push(buf);\r\n    }\r\n    final() {\r\n        return concat(this.items);\r\n    }\r\n}\n\nconst powers2 = [new Uint8Array([1])];\r\nconst digitsString = \"0123456789\";\r\nconst NAME = \"name\";\r\nconst VALUE_HEX_VIEW = \"valueHexView\";\r\nconst IS_HEX_ONLY = \"isHexOnly\";\r\nconst ID_BLOCK = \"idBlock\";\r\nconst TAG_CLASS = \"tagClass\";\r\nconst TAG_NUMBER = \"tagNumber\";\r\nconst IS_CONSTRUCTED = \"isConstructed\";\r\nconst FROM_BER = \"fromBER\";\r\nconst TO_BER = \"toBER\";\r\nconst LOCAL = \"local\";\r\nconst EMPTY_STRING = \"\";\r\nconst EMPTY_BUFFER = new ArrayBuffer(0);\r\nconst EMPTY_VIEW = new Uint8Array(0);\r\nconst END_OF_CONTENT_NAME = \"EndOfContent\";\r\nconst OCTET_STRING_NAME = \"OCTET STRING\";\r\nconst BIT_STRING_NAME = \"BIT STRING\";\n\nfunction HexBlock(BaseClass) {\r\n    var _a;\r\n    return _a = class Some extends BaseClass {\r\n            constructor(...args) {\r\n                var _a;\r\n                super(...args);\r\n                const params = args[0] || {};\r\n                this.isHexOnly = (_a = params.isHexOnly) !== null && _a !== void 0 ? _a : false;\r\n                this.valueHexView = params.valueHex ? pvtsutils.BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;\r\n            }\r\n            get valueHex() {\r\n                return this.valueHexView.slice().buffer;\r\n            }\r\n            set valueHex(value) {\r\n                this.valueHexView = new Uint8Array(value);\r\n            }\r\n            fromBER(inputBuffer, inputOffset, inputLength) {\r\n                const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;\r\n                if (!checkBufferParams(this, view, inputOffset, inputLength)) {\r\n                    return -1;\r\n                }\r\n                const endLength = inputOffset + inputLength;\r\n                this.valueHexView = view.subarray(inputOffset, endLength);\r\n                if (!this.valueHexView.length) {\r\n                    this.warnings.push(\"Zero buffer length\");\r\n                    return inputOffset;\r\n                }\r\n                this.blockLength = inputLength;\r\n                return endLength;\r\n            }\r\n            toBER(sizeOnly = false) {\r\n                if (!this.isHexOnly) {\r\n                    this.error = \"Flag 'isHexOnly' is not set, abort\";\r\n                    return EMPTY_BUFFER;\r\n                }\r\n                if (sizeOnly) {\r\n                    return new ArrayBuffer(this.valueHexView.byteLength);\r\n                }\r\n                return (this.valueHexView.byteLength === this.valueHexView.buffer.byteLength)\r\n                    ? this.valueHexView.buffer\r\n                    : this.valueHexView.slice().buffer;\r\n            }\r\n            toJSON() {\r\n                return {\r\n                    ...super.toJSON(),\r\n                    isHexOnly: this.isHexOnly,\r\n                    valueHex: pvtsutils.Convert.ToHex(this.valueHexView),\r\n                };\r\n            }\r\n        },\r\n        _a.NAME = \"hexBlock\",\r\n        _a;\r\n}\n\nclass LocalBaseBlock {\r\n    constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW, } = {}) {\r\n        this.blockLength = blockLength;\r\n        this.error = error;\r\n        this.warnings = warnings;\r\n        this.valueBeforeDecodeView = pvtsutils.BufferSourceConverter.toUint8Array(valueBeforeDecode);\r\n    }\r\n    static blockName() {\r\n        return this.NAME;\r\n    }\r\n    get valueBeforeDecode() {\r\n        return this.valueBeforeDecodeView.slice().buffer;\r\n    }\r\n    set valueBeforeDecode(value) {\r\n        this.valueBeforeDecodeView = new Uint8Array(value);\r\n    }\r\n    toJSON() {\r\n        return {\r\n            blockName: this.constructor.NAME,\r\n            blockLength: this.blockLength,\r\n            error: this.error,\r\n            warnings: this.warnings,\r\n            valueBeforeDecode: pvtsutils.Convert.ToHex(this.valueBeforeDecodeView),\r\n        };\r\n    }\r\n}\r\nLocalBaseBlock.NAME = \"baseBlock\";\n\nclass ValueBlock extends LocalBaseBlock {\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        throw TypeError(\"User need to make a specific function in a class which extends 'ValueBlock'\");\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        throw TypeError(\"User need to make a specific function in a class which extends 'ValueBlock'\");\r\n    }\r\n}\r\nValueBlock.NAME = \"valueBlock\";\n\nclass LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {\r\n    constructor({ idBlock = {}, } = {}) {\r\n        var _a, _b, _c, _d;\r\n        super();\r\n        if (idBlock) {\r\n            this.isHexOnly = (_a = idBlock.isHexOnly) !== null && _a !== void 0 ? _a : false;\r\n            this.valueHexView = idBlock.valueHex ? pvtsutils.BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;\r\n            this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;\r\n            this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;\r\n            this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;\r\n        }\r\n        else {\r\n            this.tagClass = -1;\r\n            this.tagNumber = -1;\r\n            this.isConstructed = false;\r\n        }\r\n    }\r\n    toBER(sizeOnly = false) {\r\n        let firstOctet = 0;\r\n        switch (this.tagClass) {\r\n            case 1:\r\n                firstOctet |= 0x00;\r\n                break;\r\n            case 2:\r\n                firstOctet |= 0x40;\r\n                break;\r\n            case 3:\r\n                firstOctet |= 0x80;\r\n                break;\r\n            case 4:\r\n                firstOctet |= 0xC0;\r\n                break;\r\n            default:\r\n                this.error = \"Unknown tag class\";\r\n                return EMPTY_BUFFER;\r\n        }\r\n        if (this.isConstructed)\r\n            firstOctet |= 0x20;\r\n        if (this.tagNumber < 31 && !this.isHexOnly) {\r\n            const retView = new Uint8Array(1);\r\n            if (!sizeOnly) {\r\n                let number = this.tagNumber;\r\n                number &= 0x1F;\r\n                firstOctet |= number;\r\n                retView[0] = firstOctet;\r\n            }\r\n            return retView.buffer;\r\n        }\r\n        if (!this.isHexOnly) {\r\n            const encodedBuf = pvutils.utilToBase(this.tagNumber, 7);\r\n            const encodedView = new Uint8Array(encodedBuf);\r\n            const size = encodedBuf.byteLength;\r\n            const retView = new Uint8Array(size + 1);\r\n            retView[0] = (firstOctet | 0x1F);\r\n            if (!sizeOnly) {\r\n                for (let i = 0; i < (size - 1); i++)\r\n                    retView[i + 1] = encodedView[i] | 0x80;\r\n                retView[size] = encodedView[size - 1];\r\n            }\r\n            return retView.buffer;\r\n        }\r\n        const retView = new Uint8Array(this.valueHexView.byteLength + 1);\r\n        retView[0] = (firstOctet | 0x1F);\r\n        if (!sizeOnly) {\r\n            const curView = this.valueHexView;\r\n            for (let i = 0; i < (curView.length - 1); i++)\r\n                retView[i + 1] = curView[i] | 0x80;\r\n            retView[this.valueHexView.byteLength] = curView[curView.length - 1];\r\n        }\r\n        return retView.buffer;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        if (intBuffer.length === 0) {\r\n            this.error = \"Zero buffer length\";\r\n            return -1;\r\n        }\r\n        const tagClassMask = intBuffer[0] & 0xC0;\r\n        switch (tagClassMask) {\r\n            case 0x00:\r\n                this.tagClass = (1);\r\n                break;\r\n            case 0x40:\r\n                this.tagClass = (2);\r\n                break;\r\n            case 0x80:\r\n                this.tagClass = (3);\r\n                break;\r\n            case 0xC0:\r\n                this.tagClass = (4);\r\n                break;\r\n            default:\r\n                this.error = \"Unknown tag class\";\r\n                return -1;\r\n        }\r\n        this.isConstructed = (intBuffer[0] & 0x20) === 0x20;\r\n        this.isHexOnly = false;\r\n        const tagNumberMask = intBuffer[0] & 0x1F;\r\n        if (tagNumberMask !== 0x1F) {\r\n            this.tagNumber = (tagNumberMask);\r\n            this.blockLength = 1;\r\n        }\r\n        else {\r\n            let count = 1;\r\n            let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);\r\n            let tagNumberBufferMaxLength = 255;\r\n            while (intBuffer[count] & 0x80) {\r\n                intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\r\n                count++;\r\n                if (count >= intBuffer.length) {\r\n                    this.error = \"End of input reached before message was fully decoded\";\r\n                    return -1;\r\n                }\r\n                if (count === tagNumberBufferMaxLength) {\r\n                    tagNumberBufferMaxLength += 255;\r\n                    const tempBufferView = new Uint8Array(tagNumberBufferMaxLength);\r\n                    for (let i = 0; i < intTagNumberBuffer.length; i++)\r\n                        tempBufferView[i] = intTagNumberBuffer[i];\r\n                    intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);\r\n                }\r\n            }\r\n            this.blockLength = (count + 1);\r\n            intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\r\n            const tempBufferView = new Uint8Array(count);\r\n            for (let i = 0; i < count; i++)\r\n                tempBufferView[i] = intTagNumberBuffer[i];\r\n            intTagNumberBuffer = this.valueHexView = new Uint8Array(count);\r\n            intTagNumberBuffer.set(tempBufferView);\r\n            if (this.blockLength <= 9)\r\n                this.tagNumber = pvutils.utilFromBase(intTagNumberBuffer, 7);\r\n            else {\r\n                this.isHexOnly = true;\r\n                this.warnings.push(\"Tag too long, represented as hex-coded\");\r\n            }\r\n        }\r\n        if (((this.tagClass === 1)) &&\r\n            (this.isConstructed)) {\r\n            switch (this.tagNumber) {\r\n                case 1:\r\n                case 2:\r\n                case 5:\r\n                case 6:\r\n                case 9:\r\n                case 13:\r\n                case 14:\r\n                case 23:\r\n                case 24:\r\n                case 31:\r\n                case 32:\r\n                case 33:\r\n                case 34:\r\n                    this.error = \"Constructed encoding used for primitive type\";\r\n                    return -1;\r\n            }\r\n        }\r\n        return (inputOffset + this.blockLength);\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            tagClass: this.tagClass,\r\n            tagNumber: this.tagNumber,\r\n            isConstructed: this.isConstructed,\r\n        };\r\n    }\r\n}\r\nLocalIdentificationBlock.NAME = \"identificationBlock\";\n\nclass LocalLengthBlock extends LocalBaseBlock {\r\n    constructor({ lenBlock = {}, } = {}) {\r\n        var _a, _b, _c;\r\n        super();\r\n        this.isIndefiniteForm = (_a = lenBlock.isIndefiniteForm) !== null && _a !== void 0 ? _a : false;\r\n        this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;\r\n        this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const view = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, view, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);\r\n        if (intBuffer.length === 0) {\r\n            this.error = \"Zero buffer length\";\r\n            return -1;\r\n        }\r\n        if (intBuffer[0] === 0xFF) {\r\n            this.error = \"Length block 0xFF is reserved by standard\";\r\n            return -1;\r\n        }\r\n        this.isIndefiniteForm = intBuffer[0] === 0x80;\r\n        if (this.isIndefiniteForm) {\r\n            this.blockLength = 1;\r\n            return (inputOffset + this.blockLength);\r\n        }\r\n        this.longFormUsed = !!(intBuffer[0] & 0x80);\r\n        if (this.longFormUsed === false) {\r\n            this.length = (intBuffer[0]);\r\n            this.blockLength = 1;\r\n            return (inputOffset + this.blockLength);\r\n        }\r\n        const count = intBuffer[0] & 0x7F;\r\n        if (count > 8) {\r\n            this.error = \"Too big integer\";\r\n            return -1;\r\n        }\r\n        if ((count + 1) > intBuffer.length) {\r\n            this.error = \"End of input reached before message was fully decoded\";\r\n            return -1;\r\n        }\r\n        const lenOffset = inputOffset + 1;\r\n        const lengthBufferView = view.subarray(lenOffset, lenOffset + count);\r\n        if (lengthBufferView[count - 1] === 0x00)\r\n            this.warnings.push(\"Needlessly long encoded length\");\r\n        this.length = pvutils.utilFromBase(lengthBufferView, 8);\r\n        if (this.longFormUsed && (this.length <= 127))\r\n            this.warnings.push(\"Unnecessary usage of long length form\");\r\n        this.blockLength = count + 1;\r\n        return (inputOffset + this.blockLength);\r\n    }\r\n    toBER(sizeOnly = false) {\r\n        let retBuf;\r\n        let retView;\r\n        if (this.length > 127)\r\n            this.longFormUsed = true;\r\n        if (this.isIndefiniteForm) {\r\n            retBuf = new ArrayBuffer(1);\r\n            if (sizeOnly === false) {\r\n                retView = new Uint8Array(retBuf);\r\n                retView[0] = 0x80;\r\n            }\r\n            return retBuf;\r\n        }\r\n        if (this.longFormUsed) {\r\n            const encodedBuf = pvutils.utilToBase(this.length, 8);\r\n            if (encodedBuf.byteLength > 127) {\r\n                this.error = \"Too big length\";\r\n                return (EMPTY_BUFFER);\r\n            }\r\n            retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);\r\n            if (sizeOnly)\r\n                return retBuf;\r\n            const encodedView = new Uint8Array(encodedBuf);\r\n            retView = new Uint8Array(retBuf);\r\n            retView[0] = encodedBuf.byteLength | 0x80;\r\n            for (let i = 0; i < encodedBuf.byteLength; i++)\r\n                retView[i + 1] = encodedView[i];\r\n            return retBuf;\r\n        }\r\n        retBuf = new ArrayBuffer(1);\r\n        if (sizeOnly === false) {\r\n            retView = new Uint8Array(retBuf);\r\n            retView[0] = this.length;\r\n        }\r\n        return retBuf;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            isIndefiniteForm: this.isIndefiniteForm,\r\n            longFormUsed: this.longFormUsed,\r\n            length: this.length,\r\n        };\r\n    }\r\n}\r\nLocalLengthBlock.NAME = \"lengthBlock\";\n\nconst typeStore = {};\n\nclass BaseBlock extends LocalBaseBlock {\r\n    constructor({ name = EMPTY_STRING, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType) {\r\n        super(parameters);\r\n        this.name = name;\r\n        this.optional = optional;\r\n        if (primitiveSchema) {\r\n            this.primitiveSchema = primitiveSchema;\r\n        }\r\n        this.idBlock = new LocalIdentificationBlock(parameters);\r\n        this.lenBlock = new LocalLengthBlock(parameters);\r\n        this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm) ? inputLength : this.lenBlock.length);\r\n        if (resultOffset === -1) {\r\n            this.error = this.valueBlock.error;\r\n            return resultOffset;\r\n        }\r\n        if (!this.idBlock.error.length)\r\n            this.blockLength += this.idBlock.blockLength;\r\n        if (!this.lenBlock.error.length)\r\n            this.blockLength += this.lenBlock.blockLength;\r\n        if (!this.valueBlock.error.length)\r\n            this.blockLength += this.valueBlock.blockLength;\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        const _writer = writer || new ViewWriter();\r\n        if (!writer) {\r\n            prepareIndefiniteForm(this);\r\n        }\r\n        const idBlockBuf = this.idBlock.toBER(sizeOnly);\r\n        _writer.write(idBlockBuf);\r\n        if (this.lenBlock.isIndefiniteForm) {\r\n            _writer.write(new Uint8Array([0x80]).buffer);\r\n            this.valueBlock.toBER(sizeOnly, _writer);\r\n            _writer.write(new ArrayBuffer(2));\r\n        }\r\n        else {\r\n            const valueBlockBuf = this.valueBlock.toBER(sizeOnly);\r\n            this.lenBlock.length = valueBlockBuf.byteLength;\r\n            const lenBlockBuf = this.lenBlock.toBER(sizeOnly);\r\n            _writer.write(lenBlockBuf);\r\n            _writer.write(valueBlockBuf);\r\n        }\r\n        if (!writer) {\r\n            return _writer.final();\r\n        }\r\n        return EMPTY_BUFFER;\r\n    }\r\n    toJSON() {\r\n        const object = {\r\n            ...super.toJSON(),\r\n            idBlock: this.idBlock.toJSON(),\r\n            lenBlock: this.lenBlock.toJSON(),\r\n            valueBlock: this.valueBlock.toJSON(),\r\n            name: this.name,\r\n            optional: this.optional,\r\n        };\r\n        if (this.primitiveSchema)\r\n            object.primitiveSchema = this.primitiveSchema.toJSON();\r\n        return object;\r\n    }\r\n    toString(encoding = \"ascii\") {\r\n        if (encoding === \"ascii\") {\r\n            return this.onAsciiEncoding();\r\n        }\r\n        return pvtsutils.Convert.ToHex(this.toBER());\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${pvtsutils.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`;\r\n    }\r\n    isEqual(other) {\r\n        if (this === other) {\r\n            return true;\r\n        }\r\n        if (!(other instanceof this.constructor)) {\r\n            return false;\r\n        }\r\n        const thisRaw = this.toBER();\r\n        const otherRaw = other.toBER();\r\n        return pvutils.isEqualBuffer(thisRaw, otherRaw);\r\n    }\r\n}\r\nBaseBlock.NAME = \"BaseBlock\";\r\nfunction prepareIndefiniteForm(baseBlock) {\r\n    if (baseBlock instanceof typeStore.Constructed) {\r\n        for (const value of baseBlock.valueBlock.value) {\r\n            if (prepareIndefiniteForm(value)) {\r\n                baseBlock.lenBlock.isIndefiniteForm = true;\r\n            }\r\n        }\r\n    }\r\n    return !!baseBlock.lenBlock.isIndefiniteForm;\r\n}\n\nclass BaseStringBlock extends BaseBlock {\r\n    constructor({ value = EMPTY_STRING, ...parameters } = {}, stringValueBlockType) {\r\n        super(parameters, stringValueBlockType);\r\n        if (value) {\r\n            this.fromString(value);\r\n        }\r\n    }\r\n    getValue() {\r\n        return this.valueBlock.value;\r\n    }\r\n    setValue(value) {\r\n        this.valueBlock.value = value;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm) ? inputLength : this.lenBlock.length);\r\n        if (resultOffset === -1) {\r\n            this.error = this.valueBlock.error;\r\n            return resultOffset;\r\n        }\r\n        this.fromBuffer(this.valueBlock.valueHexView);\r\n        if (!this.idBlock.error.length)\r\n            this.blockLength += this.idBlock.blockLength;\r\n        if (!this.lenBlock.error.length)\r\n            this.blockLength += this.lenBlock.blockLength;\r\n        if (!this.valueBlock.error.length)\r\n            this.blockLength += this.valueBlock.blockLength;\r\n        return resultOffset;\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : '${this.valueBlock.value}'`;\r\n    }\r\n}\r\nBaseStringBlock.NAME = \"BaseStringBlock\";\n\nclass LocalPrimitiveValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ isHexOnly = true, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.isHexOnly = isHexOnly;\r\n    }\r\n}\r\nLocalPrimitiveValueBlock.NAME = \"PrimitiveValueBlock\";\n\nvar _a$w;\r\nclass Primitive extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalPrimitiveValueBlock);\r\n        this.idBlock.isConstructed = false;\r\n    }\r\n}\r\n_a$w = Primitive;\r\n(() => {\r\n    typeStore.Primitive = _a$w;\r\n})();\r\nPrimitive.NAME = \"PRIMITIVE\";\n\nfunction localChangeType(inputObject, newType) {\r\n    if (inputObject instanceof newType) {\r\n        return inputObject;\r\n    }\r\n    const newObject = new newType();\r\n    newObject.idBlock = inputObject.idBlock;\r\n    newObject.lenBlock = inputObject.lenBlock;\r\n    newObject.warnings = inputObject.warnings;\r\n    newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;\r\n    return newObject;\r\n}\r\nfunction localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {\r\n    const incomingOffset = inputOffset;\r\n    let returnObject = new BaseBlock({}, ValueBlock);\r\n    const baseBlock = new LocalBaseBlock();\r\n    if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {\r\n        returnObject.error = baseBlock.error;\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);\r\n    if (!intBuffer.length) {\r\n        returnObject.error = \"Zero buffer length\";\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);\r\n    if (returnObject.idBlock.warnings.length) {\r\n        returnObject.warnings.concat(returnObject.idBlock.warnings);\r\n    }\r\n    if (resultOffset === -1) {\r\n        returnObject.error = returnObject.idBlock.error;\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    inputOffset = resultOffset;\r\n    inputLength -= returnObject.idBlock.blockLength;\r\n    resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);\r\n    if (returnObject.lenBlock.warnings.length) {\r\n        returnObject.warnings.concat(returnObject.lenBlock.warnings);\r\n    }\r\n    if (resultOffset === -1) {\r\n        returnObject.error = returnObject.lenBlock.error;\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    inputOffset = resultOffset;\r\n    inputLength -= returnObject.lenBlock.blockLength;\r\n    if (!returnObject.idBlock.isConstructed &&\r\n        returnObject.lenBlock.isIndefiniteForm) {\r\n        returnObject.error = \"Indefinite length form used for primitive encoding form\";\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    let newASN1Type = BaseBlock;\r\n    switch (returnObject.idBlock.tagClass) {\r\n        case 1:\r\n            if ((returnObject.idBlock.tagNumber >= 37) &&\r\n                (returnObject.idBlock.isHexOnly === false)) {\r\n                returnObject.error = \"UNIVERSAL 37 and upper tags are reserved by ASN.1 standard\";\r\n                return {\r\n                    offset: -1,\r\n                    result: returnObject\r\n                };\r\n            }\r\n            switch (returnObject.idBlock.tagNumber) {\r\n                case 0:\r\n                    if ((returnObject.idBlock.isConstructed) &&\r\n                        (returnObject.lenBlock.length > 0)) {\r\n                        returnObject.error = \"Type [UNIVERSAL 0] is reserved\";\r\n                        return {\r\n                            offset: -1,\r\n                            result: returnObject\r\n                        };\r\n                    }\r\n                    newASN1Type = typeStore.EndOfContent;\r\n                    break;\r\n                case 1:\r\n                    newASN1Type = typeStore.Boolean;\r\n                    break;\r\n                case 2:\r\n                    newASN1Type = typeStore.Integer;\r\n                    break;\r\n                case 3:\r\n                    newASN1Type = typeStore.BitString;\r\n                    break;\r\n                case 4:\r\n                    newASN1Type = typeStore.OctetString;\r\n                    break;\r\n                case 5:\r\n                    newASN1Type = typeStore.Null;\r\n                    break;\r\n                case 6:\r\n                    newASN1Type = typeStore.ObjectIdentifier;\r\n                    break;\r\n                case 10:\r\n                    newASN1Type = typeStore.Enumerated;\r\n                    break;\r\n                case 12:\r\n                    newASN1Type = typeStore.Utf8String;\r\n                    break;\r\n                case 13:\r\n                    newASN1Type = typeStore.RelativeObjectIdentifier;\r\n                    break;\r\n                case 14:\r\n                    newASN1Type = typeStore.TIME;\r\n                    break;\r\n                case 15:\r\n                    returnObject.error = \"[UNIVERSAL 15] is reserved by ASN.1 standard\";\r\n                    return {\r\n                        offset: -1,\r\n                        result: returnObject\r\n                    };\r\n                case 16:\r\n                    newASN1Type = typeStore.Sequence;\r\n                    break;\r\n                case 17:\r\n                    newASN1Type = typeStore.Set;\r\n                    break;\r\n                case 18:\r\n                    newASN1Type = typeStore.NumericString;\r\n                    break;\r\n                case 19:\r\n                    newASN1Type = typeStore.PrintableString;\r\n                    break;\r\n                case 20:\r\n                    newASN1Type = typeStore.TeletexString;\r\n                    break;\r\n                case 21:\r\n                    newASN1Type = typeStore.VideotexString;\r\n                    break;\r\n                case 22:\r\n                    newASN1Type = typeStore.IA5String;\r\n                    break;\r\n                case 23:\r\n                    newASN1Type = typeStore.UTCTime;\r\n                    break;\r\n                case 24:\r\n                    newASN1Type = typeStore.GeneralizedTime;\r\n                    break;\r\n                case 25:\r\n                    newASN1Type = typeStore.GraphicString;\r\n                    break;\r\n                case 26:\r\n                    newASN1Type = typeStore.VisibleString;\r\n                    break;\r\n                case 27:\r\n                    newASN1Type = typeStore.GeneralString;\r\n                    break;\r\n                case 28:\r\n                    newASN1Type = typeStore.UniversalString;\r\n                    break;\r\n                case 29:\r\n                    newASN1Type = typeStore.CharacterString;\r\n                    break;\r\n                case 30:\r\n                    newASN1Type = typeStore.BmpString;\r\n                    break;\r\n                case 31:\r\n                    newASN1Type = typeStore.DATE;\r\n                    break;\r\n                case 32:\r\n                    newASN1Type = typeStore.TimeOfDay;\r\n                    break;\r\n                case 33:\r\n                    newASN1Type = typeStore.DateTime;\r\n                    break;\r\n                case 34:\r\n                    newASN1Type = typeStore.Duration;\r\n                    break;\r\n                default: {\r\n                    const newObject = returnObject.idBlock.isConstructed\r\n                        ? new typeStore.Constructed()\r\n                        : new typeStore.Primitive();\r\n                    newObject.idBlock = returnObject.idBlock;\r\n                    newObject.lenBlock = returnObject.lenBlock;\r\n                    newObject.warnings = returnObject.warnings;\r\n                    returnObject = newObject;\r\n                }\r\n            }\r\n            break;\r\n        case 2:\r\n        case 3:\r\n        case 4:\r\n        default: {\r\n            newASN1Type = returnObject.idBlock.isConstructed\r\n                ? typeStore.Constructed\r\n                : typeStore.Primitive;\r\n        }\r\n    }\r\n    returnObject = localChangeType(returnObject, newASN1Type);\r\n    resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);\r\n    returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);\r\n    return {\r\n        offset: resultOffset,\r\n        result: returnObject\r\n    };\r\n}\r\nfunction fromBER(inputBuffer) {\r\n    if (!inputBuffer.byteLength) {\r\n        const result = new BaseBlock({}, ValueBlock);\r\n        result.error = \"Input buffer has zero length\";\r\n        return {\r\n            offset: -1,\r\n            result\r\n        };\r\n    }\r\n    return localFromBER(pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);\r\n}\n\nfunction checkLen(indefiniteLength, length) {\r\n    if (indefiniteLength) {\r\n        return 1;\r\n    }\r\n    return length;\r\n}\r\nclass LocalConstructedValueBlock extends ValueBlock {\r\n    constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = value;\r\n        this.isIndefiniteForm = isIndefiniteForm;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const view = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, view, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);\r\n        if (this.valueBeforeDecodeView.length === 0) {\r\n            this.warnings.push(\"Zero buffer length\");\r\n            return inputOffset;\r\n        }\r\n        let currentOffset = inputOffset;\r\n        while (checkLen(this.isIndefiniteForm, inputLength) > 0) {\r\n            const returnObject = localFromBER(view, currentOffset, inputLength);\r\n            if (returnObject.offset === -1) {\r\n                this.error = returnObject.result.error;\r\n                this.warnings.concat(returnObject.result.warnings);\r\n                return -1;\r\n            }\r\n            currentOffset = returnObject.offset;\r\n            this.blockLength += returnObject.result.blockLength;\r\n            inputLength -= returnObject.result.blockLength;\r\n            this.value.push(returnObject.result);\r\n            if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {\r\n                break;\r\n            }\r\n        }\r\n        if (this.isIndefiniteForm) {\r\n            if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {\r\n                this.value.pop();\r\n            }\r\n            else {\r\n                this.warnings.push(\"No EndOfContent block encoded\");\r\n            }\r\n        }\r\n        return currentOffset;\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        const _writer = writer || new ViewWriter();\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            this.value[i].toBER(sizeOnly, _writer);\r\n        }\r\n        if (!writer) {\r\n            return _writer.final();\r\n        }\r\n        return EMPTY_BUFFER;\r\n    }\r\n    toJSON() {\r\n        const object = {\r\n            ...super.toJSON(),\r\n            isIndefiniteForm: this.isIndefiniteForm,\r\n            value: [],\r\n        };\r\n        for (const value of this.value) {\r\n            object.value.push(value.toJSON());\r\n        }\r\n        return object;\r\n    }\r\n}\r\nLocalConstructedValueBlock.NAME = \"ConstructedValueBlock\";\n\nvar _a$v;\r\nclass Constructed extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalConstructedValueBlock);\r\n        this.idBlock.isConstructed = true;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\r\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm) ? inputLength : this.lenBlock.length);\r\n        if (resultOffset === -1) {\r\n            this.error = this.valueBlock.error;\r\n            return resultOffset;\r\n        }\r\n        if (!this.idBlock.error.length)\r\n            this.blockLength += this.idBlock.blockLength;\r\n        if (!this.lenBlock.error.length)\r\n            this.blockLength += this.lenBlock.blockLength;\r\n        if (!this.valueBlock.error.length)\r\n            this.blockLength += this.valueBlock.blockLength;\r\n        return resultOffset;\r\n    }\r\n    onAsciiEncoding() {\r\n        const values = [];\r\n        for (const value of this.valueBlock.value) {\r\n            values.push(value.toString(\"ascii\").split(\"\\n\").map(o => `  ${o}`).join(\"\\n\"));\r\n        }\r\n        const blockName = this.idBlock.tagClass === 3\r\n            ? `[${this.idBlock.tagNumber}]`\r\n            : this.constructor.NAME;\r\n        return values.length\r\n            ? `${blockName} :\\n${values.join(\"\\n\")}`\r\n            : `${blockName} :`;\r\n    }\r\n}\r\n_a$v = Constructed;\r\n(() => {\r\n    typeStore.Constructed = _a$v;\r\n})();\r\nConstructed.NAME = \"CONSTRUCTED\";\n\nclass LocalEndOfContentValueBlock extends ValueBlock {\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        return inputOffset;\r\n    }\r\n    toBER(sizeOnly) {\r\n        return EMPTY_BUFFER;\r\n    }\r\n}\r\nLocalEndOfContentValueBlock.override = \"EndOfContentValueBlock\";\n\nvar _a$u;\r\nclass EndOfContent extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalEndOfContentValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 0;\r\n    }\r\n}\r\n_a$u = EndOfContent;\r\n(() => {\r\n    typeStore.EndOfContent = _a$u;\r\n})();\r\nEndOfContent.NAME = END_OF_CONTENT_NAME;\n\nvar _a$t;\r\nclass Null extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, ValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 5;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        if (this.lenBlock.length > 0)\r\n            this.warnings.push(\"Non-zero length of value block for Null type\");\r\n        if (!this.idBlock.error.length)\r\n            this.blockLength += this.idBlock.blockLength;\r\n        if (!this.lenBlock.error.length)\r\n            this.blockLength += this.lenBlock.blockLength;\r\n        this.blockLength += inputLength;\r\n        if ((inputOffset + inputLength) > inputBuffer.byteLength) {\r\n            this.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\r\n            return -1;\r\n        }\r\n        return (inputOffset + inputLength);\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        const retBuf = new ArrayBuffer(2);\r\n        if (!sizeOnly) {\r\n            const retView = new Uint8Array(retBuf);\r\n            retView[0] = 0x05;\r\n            retView[1] = 0x00;\r\n        }\r\n        if (writer) {\r\n            writer.write(retBuf);\r\n        }\r\n        return retBuf;\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME}`;\r\n    }\r\n}\r\n_a$t = Null;\r\n(() => {\r\n    typeStore.Null = _a$t;\r\n})();\r\nNull.NAME = \"NULL\";\n\nclass LocalBooleanValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ value, ...parameters } = {}) {\r\n        super(parameters);\r\n        if (parameters.valueHex) {\r\n            this.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(parameters.valueHex);\r\n        }\r\n        else {\r\n            this.valueHexView = new Uint8Array(1);\r\n        }\r\n        if (value) {\r\n            this.value = value;\r\n        }\r\n    }\r\n    get value() {\r\n        for (const octet of this.valueHexView) {\r\n            if (octet > 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    set value(value) {\r\n        this.valueHexView[0] = value ? 0xFF : 0x00;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        if (inputLength > 1)\r\n            this.warnings.push(\"Boolean value encoded in more then 1 octet\");\r\n        this.isHexOnly = true;\r\n        pvutils.utilDecodeTC.call(this);\r\n        this.blockLength = inputLength;\r\n        return (inputOffset + inputLength);\r\n    }\r\n    toBER() {\r\n        return this.valueHexView.slice();\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            value: this.value,\r\n        };\r\n    }\r\n}\r\nLocalBooleanValueBlock.NAME = \"BooleanValueBlock\";\n\nvar _a$s;\r\nclass Boolean extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalBooleanValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 1;\r\n    }\r\n    getValue() {\r\n        return this.valueBlock.value;\r\n    }\r\n    setValue(value) {\r\n        this.valueBlock.value = value;\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.getValue}`;\r\n    }\r\n}\r\n_a$s = Boolean;\r\n(() => {\r\n    typeStore.Boolean = _a$s;\r\n})();\r\nBoolean.NAME = \"BOOLEAN\";\n\nclass LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\r\n    constructor({ isConstructed = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.isConstructed = isConstructed;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        let resultOffset = 0;\r\n        if (this.isConstructed) {\r\n            this.isHexOnly = false;\r\n            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\r\n            if (resultOffset === -1)\r\n                return resultOffset;\r\n            for (let i = 0; i < this.value.length; i++) {\r\n                const currentBlockName = this.value[i].constructor.NAME;\r\n                if (currentBlockName === END_OF_CONTENT_NAME) {\r\n                    if (this.isIndefiniteForm)\r\n                        break;\r\n                    else {\r\n                        this.error = \"EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only\";\r\n                        return -1;\r\n                    }\r\n                }\r\n                if (currentBlockName !== OCTET_STRING_NAME) {\r\n                    this.error = \"OCTET STRING may consists of OCTET STRINGs only\";\r\n                    return -1;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this.isHexOnly = true;\r\n            resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\r\n            this.blockLength = inputLength;\r\n        }\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        if (this.isConstructed)\r\n            return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);\r\n        return sizeOnly\r\n            ? new ArrayBuffer(this.valueHexView.byteLength)\r\n            : this.valueHexView.slice().buffer;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            isConstructed: this.isConstructed,\r\n        };\r\n    }\r\n}\r\nLocalOctetStringValueBlock.NAME = \"OctetStringValueBlock\";\n\nvar _a$r;\r\nclass OctetString extends BaseBlock {\r\n    constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {\r\n        var _b, _c;\r\n        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : (parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length));\r\n        super({\r\n            idBlock: {\r\n                isConstructed: parameters.isConstructed,\r\n                ...idBlock,\r\n            },\r\n            lenBlock: {\r\n                ...lenBlock,\r\n                isIndefiniteForm: !!parameters.isIndefiniteForm,\r\n            },\r\n            ...parameters,\r\n        }, LocalOctetStringValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 4;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        this.valueBlock.isConstructed = this.idBlock.isConstructed;\r\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\r\n        if (inputLength === 0) {\r\n            if (this.idBlock.error.length === 0)\r\n                this.blockLength += this.idBlock.blockLength;\r\n            if (this.lenBlock.error.length === 0)\r\n                this.blockLength += this.lenBlock.blockLength;\r\n            return inputOffset;\r\n        }\r\n        if (!this.valueBlock.isConstructed) {\r\n            const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;\r\n            const buf = view.subarray(inputOffset, inputOffset + inputLength);\r\n            try {\r\n                if (buf.byteLength) {\r\n                    const asn = localFromBER(buf, 0, buf.byteLength);\r\n                    if (asn.offset !== -1 && asn.offset === inputLength) {\r\n                        this.valueBlock.value = [asn.result];\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n            }\r\n        }\r\n        return super.fromBER(inputBuffer, inputOffset, inputLength);\r\n    }\r\n    onAsciiEncoding() {\r\n        if (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {\r\n            return Constructed.prototype.onAsciiEncoding.call(this);\r\n        }\r\n        return `${this.constructor.NAME} : ${pvtsutils.Convert.ToHex(this.valueBlock.valueHexView)}`;\r\n    }\r\n    getValue() {\r\n        if (!this.idBlock.isConstructed) {\r\n            return this.valueBlock.valueHexView.slice().buffer;\r\n        }\r\n        const array = [];\r\n        for (const content of this.valueBlock.value) {\r\n            if (content instanceof OctetString) {\r\n                array.push(content.valueBlock.valueHexView);\r\n            }\r\n        }\r\n        return pvtsutils.BufferSourceConverter.concat(array);\r\n    }\r\n}\r\n_a$r = OctetString;\r\n(() => {\r\n    typeStore.OctetString = _a$r;\r\n})();\r\nOctetString.NAME = OCTET_STRING_NAME;\n\nclass LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\r\n    constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.unusedBits = unusedBits;\r\n        this.isConstructed = isConstructed;\r\n        this.blockLength = this.valueHexView.byteLength;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        if (!inputLength) {\r\n            return inputOffset;\r\n        }\r\n        let resultOffset = -1;\r\n        if (this.isConstructed) {\r\n            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\r\n            if (resultOffset === -1)\r\n                return resultOffset;\r\n            for (const value of this.value) {\r\n                const currentBlockName = value.constructor.NAME;\r\n                if (currentBlockName === END_OF_CONTENT_NAME) {\r\n                    if (this.isIndefiniteForm)\r\n                        break;\r\n                    else {\r\n                        this.error = \"EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only\";\r\n                        return -1;\r\n                    }\r\n                }\r\n                if (currentBlockName !== BIT_STRING_NAME) {\r\n                    this.error = \"BIT STRING may consists of BIT STRINGs only\";\r\n                    return -1;\r\n                }\r\n                const valueBlock = value.valueBlock;\r\n                if ((this.unusedBits > 0) && (valueBlock.unusedBits > 0)) {\r\n                    this.error = \"Using of \\\"unused bits\\\" inside constructive BIT STRING allowed for least one only\";\r\n                    return -1;\r\n                }\r\n                this.unusedBits = valueBlock.unusedBits;\r\n            }\r\n            return resultOffset;\r\n        }\r\n        const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        this.unusedBits = intBuffer[0];\r\n        if (this.unusedBits > 7) {\r\n            this.error = \"Unused bits for BitString must be in range 0-7\";\r\n            return -1;\r\n        }\r\n        if (!this.unusedBits) {\r\n            const buf = intBuffer.subarray(1);\r\n            try {\r\n                if (buf.byteLength) {\r\n                    const asn = localFromBER(buf, 0, buf.byteLength);\r\n                    if (asn.offset !== -1 && asn.offset === (inputLength - 1)) {\r\n                        this.value = [asn.result];\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n            }\r\n        }\r\n        this.valueHexView = intBuffer.subarray(1);\r\n        this.blockLength = intBuffer.length;\r\n        return (inputOffset + inputLength);\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        if (this.isConstructed) {\r\n            return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);\r\n        }\r\n        if (sizeOnly) {\r\n            return new ArrayBuffer(this.valueHexView.byteLength + 1);\r\n        }\r\n        if (!this.valueHexView.byteLength) {\r\n            return EMPTY_BUFFER;\r\n        }\r\n        const retView = new Uint8Array(this.valueHexView.length + 1);\r\n        retView[0] = this.unusedBits;\r\n        retView.set(this.valueHexView, 1);\r\n        return retView.buffer;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            unusedBits: this.unusedBits,\r\n            isConstructed: this.isConstructed,\r\n        };\r\n    }\r\n}\r\nLocalBitStringValueBlock.NAME = \"BitStringValueBlock\";\n\nvar _a$q;\r\nclass BitString extends BaseBlock {\r\n    constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {\r\n        var _b, _c;\r\n        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : (parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length));\r\n        super({\r\n            idBlock: {\r\n                isConstructed: parameters.isConstructed,\r\n                ...idBlock,\r\n            },\r\n            lenBlock: {\r\n                ...lenBlock,\r\n                isIndefiniteForm: !!parameters.isIndefiniteForm,\r\n            },\r\n            ...parameters,\r\n        }, LocalBitStringValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 3;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        this.valueBlock.isConstructed = this.idBlock.isConstructed;\r\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\r\n        return super.fromBER(inputBuffer, inputOffset, inputLength);\r\n    }\r\n    onAsciiEncoding() {\r\n        if (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {\r\n            return Constructed.prototype.onAsciiEncoding.call(this);\r\n        }\r\n        else {\r\n            const bits = [];\r\n            const valueHex = this.valueBlock.valueHexView;\r\n            for (const byte of valueHex) {\r\n                bits.push(byte.toString(2).padStart(8, \"0\"));\r\n            }\r\n            const bitsStr = bits.join(\"\");\r\n            return `${this.constructor.NAME} : ${bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits)}`;\r\n        }\r\n    }\r\n}\r\n_a$q = BitString;\r\n(() => {\r\n    typeStore.BitString = _a$q;\r\n})();\r\nBitString.NAME = BIT_STRING_NAME;\n\nvar _a$p;\r\nfunction viewAdd(first, second) {\r\n    const c = new Uint8Array([0]);\r\n    const firstView = new Uint8Array(first);\r\n    const secondView = new Uint8Array(second);\r\n    let firstViewCopy = firstView.slice(0);\r\n    const firstViewCopyLength = firstViewCopy.length - 1;\r\n    const secondViewCopy = secondView.slice(0);\r\n    const secondViewCopyLength = secondViewCopy.length - 1;\r\n    let value = 0;\r\n    const max = (secondViewCopyLength < firstViewCopyLength) ? firstViewCopyLength : secondViewCopyLength;\r\n    let counter = 0;\r\n    for (let i = max; i >= 0; i--, counter++) {\r\n        switch (true) {\r\n            case (counter < secondViewCopy.length):\r\n                value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];\r\n                break;\r\n            default:\r\n                value = firstViewCopy[firstViewCopyLength - counter] + c[0];\r\n        }\r\n        c[0] = value / 10;\r\n        switch (true) {\r\n            case (counter >= firstViewCopy.length):\r\n                firstViewCopy = pvutils.utilConcatView(new Uint8Array([value % 10]), firstViewCopy);\r\n                break;\r\n            default:\r\n                firstViewCopy[firstViewCopyLength - counter] = value % 10;\r\n        }\r\n    }\r\n    if (c[0] > 0)\r\n        firstViewCopy = pvutils.utilConcatView(c, firstViewCopy);\r\n    return firstViewCopy;\r\n}\r\nfunction power2(n) {\r\n    if (n >= powers2.length) {\r\n        for (let p = powers2.length; p <= n; p++) {\r\n            const c = new Uint8Array([0]);\r\n            let digits = (powers2[p - 1]).slice(0);\r\n            for (let i = (digits.length - 1); i >= 0; i--) {\r\n                const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);\r\n                c[0] = newValue[0] / 10;\r\n                digits[i] = newValue[0] % 10;\r\n            }\r\n            if (c[0] > 0)\r\n                digits = pvutils.utilConcatView(c, digits);\r\n            powers2.push(digits);\r\n        }\r\n    }\r\n    return powers2[n];\r\n}\r\nfunction viewSub(first, second) {\r\n    let b = 0;\r\n    const firstView = new Uint8Array(first);\r\n    const secondView = new Uint8Array(second);\r\n    const firstViewCopy = firstView.slice(0);\r\n    const firstViewCopyLength = firstViewCopy.length - 1;\r\n    const secondViewCopy = secondView.slice(0);\r\n    const secondViewCopyLength = secondViewCopy.length - 1;\r\n    let value;\r\n    let counter = 0;\r\n    for (let i = secondViewCopyLength; i >= 0; i--, counter++) {\r\n        value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;\r\n        switch (true) {\r\n            case (value < 0):\r\n                b = 1;\r\n                firstViewCopy[firstViewCopyLength - counter] = value + 10;\r\n                break;\r\n            default:\r\n                b = 0;\r\n                firstViewCopy[firstViewCopyLength - counter] = value;\r\n        }\r\n    }\r\n    if (b > 0) {\r\n        for (let i = (firstViewCopyLength - secondViewCopyLength + 1); i >= 0; i--, counter++) {\r\n            value = firstViewCopy[firstViewCopyLength - counter] - b;\r\n            if (value < 0) {\r\n                b = 1;\r\n                firstViewCopy[firstViewCopyLength - counter] = value + 10;\r\n            }\r\n            else {\r\n                b = 0;\r\n                firstViewCopy[firstViewCopyLength - counter] = value;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return firstViewCopy.slice();\r\n}\r\nclass LocalIntegerValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ value, ...parameters } = {}) {\r\n        super(parameters);\r\n        this._valueDec = 0;\r\n        if (parameters.valueHex) {\r\n            this.setValueHex();\r\n        }\r\n        if (value !== undefined) {\r\n            this.valueDec = value;\r\n        }\r\n    }\r\n    setValueHex() {\r\n        if (this.valueHexView.length >= 4) {\r\n            this.warnings.push(\"Too big Integer for decoding, hex only\");\r\n            this.isHexOnly = true;\r\n            this._valueDec = 0;\r\n        }\r\n        else {\r\n            this.isHexOnly = false;\r\n            if (this.valueHexView.length > 0) {\r\n                this._valueDec = pvutils.utilDecodeTC.call(this);\r\n            }\r\n        }\r\n    }\r\n    set valueDec(v) {\r\n        this._valueDec = v;\r\n        this.isHexOnly = false;\r\n        this.valueHexView = new Uint8Array(pvutils.utilEncodeTC(v));\r\n    }\r\n    get valueDec() {\r\n        return this._valueDec;\r\n    }\r\n    fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {\r\n        const offset = this.fromBER(inputBuffer, inputOffset, inputLength);\r\n        if (offset === -1)\r\n            return offset;\r\n        const view = this.valueHexView;\r\n        if ((view[0] === 0x00) && ((view[1] & 0x80) !== 0)) {\r\n            this.valueHexView = view.subarray(1);\r\n        }\r\n        else {\r\n            if (expectedLength !== 0) {\r\n                if (view.length < expectedLength) {\r\n                    if ((expectedLength - view.length) > 1)\r\n                        expectedLength = view.length + 1;\r\n                    this.valueHexView = view.subarray(expectedLength - view.length);\r\n                }\r\n            }\r\n        }\r\n        return offset;\r\n    }\r\n    toDER(sizeOnly = false) {\r\n        const view = this.valueHexView;\r\n        switch (true) {\r\n            case ((view[0] & 0x80) !== 0):\r\n                {\r\n                    const updatedView = new Uint8Array(this.valueHexView.length + 1);\r\n                    updatedView[0] = 0x00;\r\n                    updatedView.set(view, 1);\r\n                    this.valueHexView = updatedView;\r\n                }\r\n                break;\r\n            case ((view[0] === 0x00) && ((view[1] & 0x80) === 0)):\r\n                {\r\n                    this.valueHexView = this.valueHexView.subarray(1);\r\n                }\r\n                break;\r\n        }\r\n        return this.toBER(sizeOnly);\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\r\n        if (resultOffset === -1) {\r\n            return resultOffset;\r\n        }\r\n        this.setValueHex();\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly) {\r\n        return sizeOnly\r\n            ? new ArrayBuffer(this.valueHexView.length)\r\n            : this.valueHexView.slice().buffer;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            valueDec: this.valueDec,\r\n        };\r\n    }\r\n    toString() {\r\n        const firstBit = (this.valueHexView.length * 8) - 1;\r\n        let digits = new Uint8Array((this.valueHexView.length * 8) / 3);\r\n        let bitNumber = 0;\r\n        let currentByte;\r\n        const asn1View = this.valueHexView;\r\n        let result = \"\";\r\n        let flag = false;\r\n        for (let byteNumber = (asn1View.byteLength - 1); byteNumber >= 0; byteNumber--) {\r\n            currentByte = asn1View[byteNumber];\r\n            for (let i = 0; i < 8; i++) {\r\n                if ((currentByte & 1) === 1) {\r\n                    switch (bitNumber) {\r\n                        case firstBit:\r\n                            digits = viewSub(power2(bitNumber), digits);\r\n                            result = \"-\";\r\n                            break;\r\n                        default:\r\n                            digits = viewAdd(digits, power2(bitNumber));\r\n                    }\r\n                }\r\n                bitNumber++;\r\n                currentByte >>= 1;\r\n            }\r\n        }\r\n        for (let i = 0; i < digits.length; i++) {\r\n            if (digits[i])\r\n                flag = true;\r\n            if (flag)\r\n                result += digitsString.charAt(digits[i]);\r\n        }\r\n        if (flag === false)\r\n            result += digitsString.charAt(0);\r\n        return result;\r\n    }\r\n}\r\n_a$p = LocalIntegerValueBlock;\r\nLocalIntegerValueBlock.NAME = \"IntegerValueBlock\";\r\n(() => {\r\n    Object.defineProperty(_a$p.prototype, \"valueHex\", {\r\n        set: function (v) {\r\n            this.valueHexView = new Uint8Array(v);\r\n            this.setValueHex();\r\n        },\r\n        get: function () {\r\n            return this.valueHexView.slice().buffer;\r\n        },\r\n    });\r\n})();\n\nvar _a$o;\r\nclass Integer extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalIntegerValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 2;\r\n    }\r\n    toBigInt() {\r\n        assertBigInt();\r\n        return BigInt(this.valueBlock.toString());\r\n    }\r\n    static fromBigInt(value) {\r\n        assertBigInt();\r\n        const bigIntValue = BigInt(value);\r\n        const writer = new ViewWriter();\r\n        const hex = bigIntValue.toString(16).replace(/^-/, \"\");\r\n        const view = new Uint8Array(pvtsutils.Convert.FromHex(hex));\r\n        if (bigIntValue < 0) {\r\n            const first = new Uint8Array(view.length + (view[0] & 0x80 ? 1 : 0));\r\n            first[0] |= 0x80;\r\n            const firstInt = BigInt(`0x${pvtsutils.Convert.ToHex(first)}`);\r\n            const secondInt = firstInt + bigIntValue;\r\n            const second = pvtsutils.BufferSourceConverter.toUint8Array(pvtsutils.Convert.FromHex(secondInt.toString(16)));\r\n            second[0] |= 0x80;\r\n            writer.write(second);\r\n        }\r\n        else {\r\n            if (view[0] & 0x80) {\r\n                writer.write(new Uint8Array([0]));\r\n            }\r\n            writer.write(view);\r\n        }\r\n        const res = new Integer({\r\n            valueHex: writer.final(),\r\n        });\r\n        return res;\r\n    }\r\n    convertToDER() {\r\n        const integer = new Integer({ valueHex: this.valueBlock.valueHexView });\r\n        integer.valueBlock.toDER();\r\n        return integer;\r\n    }\r\n    convertFromDER() {\r\n        return new Integer({\r\n            valueHex: this.valueBlock.valueHexView[0] === 0\r\n                ? this.valueBlock.valueHexView.subarray(1)\r\n                : this.valueBlock.valueHexView,\r\n        });\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;\r\n    }\r\n}\r\n_a$o = Integer;\r\n(() => {\r\n    typeStore.Integer = _a$o;\r\n})();\r\nInteger.NAME = \"INTEGER\";\n\nvar _a$n;\r\nclass Enumerated extends Integer {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 10;\r\n    }\r\n}\r\n_a$n = Enumerated;\r\n(() => {\r\n    typeStore.Enumerated = _a$n;\r\n})();\r\nEnumerated.NAME = \"ENUMERATED\";\n\nclass LocalSidValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.valueDec = valueDec;\r\n        this.isFirstSid = isFirstSid;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        if (!inputLength) {\r\n            return inputOffset;\r\n        }\r\n        const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        this.valueHexView = new Uint8Array(inputLength);\r\n        for (let i = 0; i < inputLength; i++) {\r\n            this.valueHexView[i] = intBuffer[i] & 0x7F;\r\n            this.blockLength++;\r\n            if ((intBuffer[i] & 0x80) === 0x00)\r\n                break;\r\n        }\r\n        const tempView = new Uint8Array(this.blockLength);\r\n        for (let i = 0; i < this.blockLength; i++) {\r\n            tempView[i] = this.valueHexView[i];\r\n        }\r\n        this.valueHexView = tempView;\r\n        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\r\n            this.error = \"End of input reached before message was fully decoded\";\r\n            return -1;\r\n        }\r\n        if (this.valueHexView[0] === 0x00)\r\n            this.warnings.push(\"Needlessly long format of SID encoding\");\r\n        if (this.blockLength <= 8)\r\n            this.valueDec = pvutils.utilFromBase(this.valueHexView, 7);\r\n        else {\r\n            this.isHexOnly = true;\r\n            this.warnings.push(\"Too big SID for decoding, hex only\");\r\n        }\r\n        return (inputOffset + this.blockLength);\r\n    }\r\n    set valueBigInt(value) {\r\n        assertBigInt();\r\n        let bits = BigInt(value).toString(2);\r\n        while (bits.length % 7) {\r\n            bits = \"0\" + bits;\r\n        }\r\n        const bytes = new Uint8Array(bits.length / 7);\r\n        for (let i = 0; i < bytes.length; i++) {\r\n            bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0);\r\n        }\r\n        this.fromBER(bytes.buffer, 0, bytes.length);\r\n    }\r\n    toBER(sizeOnly) {\r\n        if (this.isHexOnly) {\r\n            if (sizeOnly)\r\n                return (new ArrayBuffer(this.valueHexView.byteLength));\r\n            const curView = this.valueHexView;\r\n            const retView = new Uint8Array(this.blockLength);\r\n            for (let i = 0; i < (this.blockLength - 1); i++)\r\n                retView[i] = curView[i] | 0x80;\r\n            retView[this.blockLength - 1] = curView[this.blockLength - 1];\r\n            return retView.buffer;\r\n        }\r\n        const encodedBuf = pvutils.utilToBase(this.valueDec, 7);\r\n        if (encodedBuf.byteLength === 0) {\r\n            this.error = \"Error during encoding SID value\";\r\n            return EMPTY_BUFFER;\r\n        }\r\n        const retView = new Uint8Array(encodedBuf.byteLength);\r\n        if (!sizeOnly) {\r\n            const encodedView = new Uint8Array(encodedBuf);\r\n            const len = encodedBuf.byteLength - 1;\r\n            for (let i = 0; i < len; i++)\r\n                retView[i] = encodedView[i] | 0x80;\r\n            retView[len] = encodedView[len];\r\n        }\r\n        return retView;\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        if (this.isHexOnly)\r\n            result = pvtsutils.Convert.ToHex(this.valueHexView);\r\n        else {\r\n            if (this.isFirstSid) {\r\n                let sidValue = this.valueDec;\r\n                if (this.valueDec <= 39)\r\n                    result = \"0.\";\r\n                else {\r\n                    if (this.valueDec <= 79) {\r\n                        result = \"1.\";\r\n                        sidValue -= 40;\r\n                    }\r\n                    else {\r\n                        result = \"2.\";\r\n                        sidValue -= 80;\r\n                    }\r\n                }\r\n                result += sidValue.toString();\r\n            }\r\n            else\r\n                result = this.valueDec.toString();\r\n        }\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            valueDec: this.valueDec,\r\n            isFirstSid: this.isFirstSid,\r\n        };\r\n    }\r\n}\r\nLocalSidValueBlock.NAME = \"sidBlock\";\n\nclass LocalObjectIdentifierValueBlock extends ValueBlock {\r\n    constructor({ value = EMPTY_STRING, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = [];\r\n        if (value) {\r\n            this.fromString(value);\r\n        }\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        let resultOffset = inputOffset;\r\n        while (inputLength > 0) {\r\n            const sidBlock = new LocalSidValueBlock();\r\n            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\r\n            if (resultOffset === -1) {\r\n                this.blockLength = 0;\r\n                this.error = sidBlock.error;\r\n                return resultOffset;\r\n            }\r\n            if (this.value.length === 0)\r\n                sidBlock.isFirstSid = true;\r\n            this.blockLength += sidBlock.blockLength;\r\n            inputLength -= sidBlock.blockLength;\r\n            this.value.push(sidBlock);\r\n        }\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly) {\r\n        const retBuffers = [];\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            const valueBuf = this.value[i].toBER(sizeOnly);\r\n            if (valueBuf.byteLength === 0) {\r\n                this.error = this.value[i].error;\r\n                return EMPTY_BUFFER;\r\n            }\r\n            retBuffers.push(valueBuf);\r\n        }\r\n        return concat(retBuffers);\r\n    }\r\n    fromString(string) {\r\n        this.value = [];\r\n        let pos1 = 0;\r\n        let pos2 = 0;\r\n        let sid = \"\";\r\n        let flag = false;\r\n        do {\r\n            pos2 = string.indexOf(\".\", pos1);\r\n            if (pos2 === -1)\r\n                sid = string.substring(pos1);\r\n            else\r\n                sid = string.substring(pos1, pos2);\r\n            pos1 = pos2 + 1;\r\n            if (flag) {\r\n                const sidBlock = this.value[0];\r\n                let plus = 0;\r\n                switch (sidBlock.valueDec) {\r\n                    case 0:\r\n                        break;\r\n                    case 1:\r\n                        plus = 40;\r\n                        break;\r\n                    case 2:\r\n                        plus = 80;\r\n                        break;\r\n                    default:\r\n                        this.value = [];\r\n                        return;\r\n                }\r\n                const parsedSID = parseInt(sid, 10);\r\n                if (isNaN(parsedSID))\r\n                    return;\r\n                sidBlock.valueDec = parsedSID + plus;\r\n                flag = false;\r\n            }\r\n            else {\r\n                const sidBlock = new LocalSidValueBlock();\r\n                if (sid > Number.MAX_SAFE_INTEGER) {\r\n                    assertBigInt();\r\n                    const sidValue = BigInt(sid);\r\n                    sidBlock.valueBigInt = sidValue;\r\n                }\r\n                else {\r\n                    sidBlock.valueDec = parseInt(sid, 10);\r\n                    if (isNaN(sidBlock.valueDec))\r\n                        return;\r\n                }\r\n                if (!this.value.length) {\r\n                    sidBlock.isFirstSid = true;\r\n                    flag = true;\r\n                }\r\n                this.value.push(sidBlock);\r\n            }\r\n        } while (pos2 !== -1);\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        let isHexOnly = false;\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            isHexOnly = this.value[i].isHexOnly;\r\n            let sidStr = this.value[i].toString();\r\n            if (i !== 0)\r\n                result = `${result}.`;\r\n            if (isHexOnly) {\r\n                sidStr = `{${sidStr}}`;\r\n                if (this.value[i].isFirstSid)\r\n                    result = `2.{${sidStr} - 80}`;\r\n                else\r\n                    result += sidStr;\r\n            }\r\n            else\r\n                result += sidStr;\r\n        }\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        const object = {\r\n            ...super.toJSON(),\r\n            value: this.toString(),\r\n            sidArray: [],\r\n        };\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            object.sidArray.push(this.value[i].toJSON());\r\n        }\r\n        return object;\r\n    }\r\n}\r\nLocalObjectIdentifierValueBlock.NAME = \"ObjectIdentifierValueBlock\";\n\nvar _a$m;\r\nclass ObjectIdentifier extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalObjectIdentifierValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 6;\r\n    }\r\n    getValue() {\r\n        return this.valueBlock.toString();\r\n    }\r\n    setValue(value) {\r\n        this.valueBlock.fromString(value);\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.valueBlock.toString() || \"empty\"}`;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            value: this.getValue(),\r\n        };\r\n    }\r\n}\r\n_a$m = ObjectIdentifier;\r\n(() => {\r\n    typeStore.ObjectIdentifier = _a$m;\r\n})();\r\nObjectIdentifier.NAME = \"OBJECT IDENTIFIER\";\n\nclass LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {\r\n    constructor({ valueDec = 0, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.valueDec = valueDec;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        if (inputLength === 0)\r\n            return inputOffset;\r\n        const inputView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength))\r\n            return -1;\r\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        this.valueHexView = new Uint8Array(inputLength);\r\n        for (let i = 0; i < inputLength; i++) {\r\n            this.valueHexView[i] = intBuffer[i] & 0x7F;\r\n            this.blockLength++;\r\n            if ((intBuffer[i] & 0x80) === 0x00)\r\n                break;\r\n        }\r\n        const tempView = new Uint8Array(this.blockLength);\r\n        for (let i = 0; i < this.blockLength; i++)\r\n            tempView[i] = this.valueHexView[i];\r\n        this.valueHexView = tempView;\r\n        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\r\n            this.error = \"End of input reached before message was fully decoded\";\r\n            return -1;\r\n        }\r\n        if (this.valueHexView[0] === 0x00)\r\n            this.warnings.push(\"Needlessly long format of SID encoding\");\r\n        if (this.blockLength <= 8)\r\n            this.valueDec = pvutils.utilFromBase(this.valueHexView, 7);\r\n        else {\r\n            this.isHexOnly = true;\r\n            this.warnings.push(\"Too big SID for decoding, hex only\");\r\n        }\r\n        return (inputOffset + this.blockLength);\r\n    }\r\n    toBER(sizeOnly) {\r\n        if (this.isHexOnly) {\r\n            if (sizeOnly)\r\n                return (new ArrayBuffer(this.valueHexView.byteLength));\r\n            const curView = this.valueHexView;\r\n            const retView = new Uint8Array(this.blockLength);\r\n            for (let i = 0; i < (this.blockLength - 1); i++)\r\n                retView[i] = curView[i] | 0x80;\r\n            retView[this.blockLength - 1] = curView[this.blockLength - 1];\r\n            return retView.buffer;\r\n        }\r\n        const encodedBuf = pvutils.utilToBase(this.valueDec, 7);\r\n        if (encodedBuf.byteLength === 0) {\r\n            this.error = \"Error during encoding SID value\";\r\n            return EMPTY_BUFFER;\r\n        }\r\n        const retView = new Uint8Array(encodedBuf.byteLength);\r\n        if (!sizeOnly) {\r\n            const encodedView = new Uint8Array(encodedBuf);\r\n            const len = encodedBuf.byteLength - 1;\r\n            for (let i = 0; i < len; i++)\r\n                retView[i] = encodedView[i] | 0x80;\r\n            retView[len] = encodedView[len];\r\n        }\r\n        return retView.buffer;\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        if (this.isHexOnly)\r\n            result = pvtsutils.Convert.ToHex(this.valueHexView);\r\n        else {\r\n            result = this.valueDec.toString();\r\n        }\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            valueDec: this.valueDec,\r\n        };\r\n    }\r\n}\r\nLocalRelativeSidValueBlock.NAME = \"relativeSidBlock\";\n\nclass LocalRelativeObjectIdentifierValueBlock extends ValueBlock {\r\n    constructor({ value = EMPTY_STRING, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = [];\r\n        if (value) {\r\n            this.fromString(value);\r\n        }\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        let resultOffset = inputOffset;\r\n        while (inputLength > 0) {\r\n            const sidBlock = new LocalRelativeSidValueBlock();\r\n            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\r\n            if (resultOffset === -1) {\r\n                this.blockLength = 0;\r\n                this.error = sidBlock.error;\r\n                return resultOffset;\r\n            }\r\n            this.blockLength += sidBlock.blockLength;\r\n            inputLength -= sidBlock.blockLength;\r\n            this.value.push(sidBlock);\r\n        }\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        const retBuffers = [];\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            const valueBuf = this.value[i].toBER(sizeOnly);\r\n            if (valueBuf.byteLength === 0) {\r\n                this.error = this.value[i].error;\r\n                return EMPTY_BUFFER;\r\n            }\r\n            retBuffers.push(valueBuf);\r\n        }\r\n        return concat(retBuffers);\r\n    }\r\n    fromString(string) {\r\n        this.value = [];\r\n        let pos1 = 0;\r\n        let pos2 = 0;\r\n        let sid = \"\";\r\n        do {\r\n            pos2 = string.indexOf(\".\", pos1);\r\n            if (pos2 === -1)\r\n                sid = string.substring(pos1);\r\n            else\r\n                sid = string.substring(pos1, pos2);\r\n            pos1 = pos2 + 1;\r\n            const sidBlock = new LocalRelativeSidValueBlock();\r\n            sidBlock.valueDec = parseInt(sid, 10);\r\n            if (isNaN(sidBlock.valueDec))\r\n                return true;\r\n            this.value.push(sidBlock);\r\n        } while (pos2 !== -1);\r\n        return true;\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        let isHexOnly = false;\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            isHexOnly = this.value[i].isHexOnly;\r\n            let sidStr = this.value[i].toString();\r\n            if (i !== 0)\r\n                result = `${result}.`;\r\n            if (isHexOnly) {\r\n                sidStr = `{${sidStr}}`;\r\n                result += sidStr;\r\n            }\r\n            else\r\n                result += sidStr;\r\n        }\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        const object = {\r\n            ...super.toJSON(),\r\n            value: this.toString(),\r\n            sidArray: [],\r\n        };\r\n        for (let i = 0; i < this.value.length; i++)\r\n            object.sidArray.push(this.value[i].toJSON());\r\n        return object;\r\n    }\r\n}\r\nLocalRelativeObjectIdentifierValueBlock.NAME = \"RelativeObjectIdentifierValueBlock\";\n\nvar _a$l;\r\nclass RelativeObjectIdentifier extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalRelativeObjectIdentifierValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 13;\r\n    }\r\n    getValue() {\r\n        return this.valueBlock.toString();\r\n    }\r\n    setValue(value) {\r\n        this.valueBlock.fromString(value);\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.valueBlock.toString() || \"empty\"}`;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            value: this.getValue(),\r\n        };\r\n    }\r\n}\r\n_a$l = RelativeObjectIdentifier;\r\n(() => {\r\n    typeStore.RelativeObjectIdentifier = _a$l;\r\n})();\r\nRelativeObjectIdentifier.NAME = \"RelativeObjectIdentifier\";\n\nvar _a$k;\r\nclass Sequence extends Constructed {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 16;\r\n    }\r\n}\r\n_a$k = Sequence;\r\n(() => {\r\n    typeStore.Sequence = _a$k;\r\n})();\r\nSequence.NAME = \"SEQUENCE\";\n\nvar _a$j;\r\nclass Set extends Constructed {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 17;\r\n    }\r\n}\r\n_a$j = Set;\r\n(() => {\r\n    typeStore.Set = _a$j;\r\n})();\r\nSet.NAME = \"SET\";\n\nclass LocalStringValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ ...parameters } = {}) {\r\n        super(parameters);\r\n        this.isHexOnly = true;\r\n        this.value = EMPTY_STRING;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            value: this.value,\r\n        };\r\n    }\r\n}\r\nLocalStringValueBlock.NAME = \"StringValueBlock\";\n\nclass LocalSimpleStringValueBlock extends LocalStringValueBlock {\r\n}\r\nLocalSimpleStringValueBlock.NAME = \"SimpleStringValueBlock\";\n\nclass LocalSimpleStringBlock extends BaseStringBlock {\r\n    constructor({ ...parameters } = {}) {\r\n        super(parameters, LocalSimpleStringValueBlock);\r\n    }\r\n    fromBuffer(inputBuffer) {\r\n        this.valueBlock.value = String.fromCharCode.apply(null, pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer));\r\n    }\r\n    fromString(inputString) {\r\n        const strLen = inputString.length;\r\n        const view = this.valueBlock.valueHexView = new Uint8Array(strLen);\r\n        for (let i = 0; i < strLen; i++)\r\n            view[i] = inputString.charCodeAt(i);\r\n        this.valueBlock.value = inputString;\r\n    }\r\n}\r\nLocalSimpleStringBlock.NAME = \"SIMPLE STRING\";\n\nclass LocalUtf8StringValueBlock extends LocalSimpleStringBlock {\r\n    fromBuffer(inputBuffer) {\r\n        this.valueBlock.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        try {\r\n            this.valueBlock.value = pvtsutils.Convert.ToUtf8String(inputBuffer);\r\n        }\r\n        catch (ex) {\r\n            this.warnings.push(`Error during \"decodeURIComponent\": ${ex}, using raw string`);\r\n            this.valueBlock.value = pvtsutils.Convert.ToBinary(inputBuffer);\r\n        }\r\n    }\r\n    fromString(inputString) {\r\n        this.valueBlock.valueHexView = new Uint8Array(pvtsutils.Convert.FromUtf8String(inputString));\r\n        this.valueBlock.value = inputString;\r\n    }\r\n}\r\nLocalUtf8StringValueBlock.NAME = \"Utf8StringValueBlock\";\n\nvar _a$i;\r\nclass Utf8String extends LocalUtf8StringValueBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 12;\r\n    }\r\n}\r\n_a$i = Utf8String;\r\n(() => {\r\n    typeStore.Utf8String = _a$i;\r\n})();\r\nUtf8String.NAME = \"UTF8String\";\n\nclass LocalBmpStringValueBlock extends LocalSimpleStringBlock {\r\n    fromBuffer(inputBuffer) {\r\n        this.valueBlock.value = pvtsutils.Convert.ToUtf16String(inputBuffer);\r\n        this.valueBlock.valueHexView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer);\r\n    }\r\n    fromString(inputString) {\r\n        this.valueBlock.value = inputString;\r\n        this.valueBlock.valueHexView = new Uint8Array(pvtsutils.Convert.FromUtf16String(inputString));\r\n    }\r\n}\r\nLocalBmpStringValueBlock.NAME = \"BmpStringValueBlock\";\n\nvar _a$h;\r\nclass BmpString extends LocalBmpStringValueBlock {\r\n    constructor({ ...parameters } = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 30;\r\n    }\r\n}\r\n_a$h = BmpString;\r\n(() => {\r\n    typeStore.BmpString = _a$h;\r\n})();\r\nBmpString.NAME = \"BMPString\";\n\nclass LocalUniversalStringValueBlock extends LocalSimpleStringBlock {\r\n    fromBuffer(inputBuffer) {\r\n        const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);\r\n        const valueView = new Uint8Array(copyBuffer);\r\n        for (let i = 0; i < valueView.length; i += 4) {\r\n            valueView[i] = valueView[i + 3];\r\n            valueView[i + 1] = valueView[i + 2];\r\n            valueView[i + 2] = 0x00;\r\n            valueView[i + 3] = 0x00;\r\n        }\r\n        this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));\r\n    }\r\n    fromString(inputString) {\r\n        const strLength = inputString.length;\r\n        const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);\r\n        for (let i = 0; i < strLength; i++) {\r\n            const codeBuf = pvutils.utilToBase(inputString.charCodeAt(i), 8);\r\n            const codeView = new Uint8Array(codeBuf);\r\n            if (codeView.length > 4)\r\n                continue;\r\n            const dif = 4 - codeView.length;\r\n            for (let j = (codeView.length - 1); j >= 0; j--)\r\n                valueHexView[i * 4 + j + dif] = codeView[j];\r\n        }\r\n        this.valueBlock.value = inputString;\r\n    }\r\n}\r\nLocalUniversalStringValueBlock.NAME = \"UniversalStringValueBlock\";\n\nvar _a$g;\r\nclass UniversalString extends LocalUniversalStringValueBlock {\r\n    constructor({ ...parameters } = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 28;\r\n    }\r\n}\r\n_a$g = UniversalString;\r\n(() => {\r\n    typeStore.UniversalString = _a$g;\r\n})();\r\nUniversalString.NAME = \"UniversalString\";\n\nvar _a$f;\r\nclass NumericString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 18;\r\n    }\r\n}\r\n_a$f = NumericString;\r\n(() => {\r\n    typeStore.NumericString = _a$f;\r\n})();\r\nNumericString.NAME = \"NumericString\";\n\nvar _a$e;\r\nclass PrintableString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 19;\r\n    }\r\n}\r\n_a$e = PrintableString;\r\n(() => {\r\n    typeStore.PrintableString = _a$e;\r\n})();\r\nPrintableString.NAME = \"PrintableString\";\n\nvar _a$d;\r\nclass TeletexString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 20;\r\n    }\r\n}\r\n_a$d = TeletexString;\r\n(() => {\r\n    typeStore.TeletexString = _a$d;\r\n})();\r\nTeletexString.NAME = \"TeletexString\";\n\nvar _a$c;\r\nclass VideotexString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 21;\r\n    }\r\n}\r\n_a$c = VideotexString;\r\n(() => {\r\n    typeStore.VideotexString = _a$c;\r\n})();\r\nVideotexString.NAME = \"VideotexString\";\n\nvar _a$b;\r\nclass IA5String extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 22;\r\n    }\r\n}\r\n_a$b = IA5String;\r\n(() => {\r\n    typeStore.IA5String = _a$b;\r\n})();\r\nIA5String.NAME = \"IA5String\";\n\nvar _a$a;\r\nclass GraphicString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 25;\r\n    }\r\n}\r\n_a$a = GraphicString;\r\n(() => {\r\n    typeStore.GraphicString = _a$a;\r\n})();\r\nGraphicString.NAME = \"GraphicString\";\n\nvar _a$9;\r\nclass VisibleString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 26;\r\n    }\r\n}\r\n_a$9 = VisibleString;\r\n(() => {\r\n    typeStore.VisibleString = _a$9;\r\n})();\r\nVisibleString.NAME = \"VisibleString\";\n\nvar _a$8;\r\nclass GeneralString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 27;\r\n    }\r\n}\r\n_a$8 = GeneralString;\r\n(() => {\r\n    typeStore.GeneralString = _a$8;\r\n})();\r\nGeneralString.NAME = \"GeneralString\";\n\nvar _a$7;\r\nclass CharacterString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 29;\r\n    }\r\n}\r\n_a$7 = CharacterString;\r\n(() => {\r\n    typeStore.CharacterString = _a$7;\r\n})();\r\nCharacterString.NAME = \"CharacterString\";\n\nvar _a$6;\r\nclass UTCTime extends VisibleString {\r\n    constructor({ value, valueDate, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.year = 0;\r\n        this.month = 0;\r\n        this.day = 0;\r\n        this.hour = 0;\r\n        this.minute = 0;\r\n        this.second = 0;\r\n        if (value) {\r\n            this.fromString(value);\r\n            this.valueBlock.valueHexView = new Uint8Array(value.length);\r\n            for (let i = 0; i < value.length; i++)\r\n                this.valueBlock.valueHexView[i] = value.charCodeAt(i);\r\n        }\r\n        if (valueDate) {\r\n            this.fromDate(valueDate);\r\n            this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());\r\n        }\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 23;\r\n    }\r\n    fromBuffer(inputBuffer) {\r\n        this.fromString(String.fromCharCode.apply(null, pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer)));\r\n    }\r\n    toBuffer() {\r\n        const str = this.toString();\r\n        const buffer = new ArrayBuffer(str.length);\r\n        const view = new Uint8Array(buffer);\r\n        for (let i = 0; i < str.length; i++)\r\n            view[i] = str.charCodeAt(i);\r\n        return buffer;\r\n    }\r\n    fromDate(inputDate) {\r\n        this.year = inputDate.getUTCFullYear();\r\n        this.month = inputDate.getUTCMonth() + 1;\r\n        this.day = inputDate.getUTCDate();\r\n        this.hour = inputDate.getUTCHours();\r\n        this.minute = inputDate.getUTCMinutes();\r\n        this.second = inputDate.getUTCSeconds();\r\n    }\r\n    toDate() {\r\n        return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second)));\r\n    }\r\n    fromString(inputString) {\r\n        const parser = /(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z/ig;\r\n        const parserArray = parser.exec(inputString);\r\n        if (parserArray === null) {\r\n            this.error = \"Wrong input string for conversion\";\r\n            return;\r\n        }\r\n        const year = parseInt(parserArray[1], 10);\r\n        if (year >= 50)\r\n            this.year = 1900 + year;\r\n        else\r\n            this.year = 2000 + year;\r\n        this.month = parseInt(parserArray[2], 10);\r\n        this.day = parseInt(parserArray[3], 10);\r\n        this.hour = parseInt(parserArray[4], 10);\r\n        this.minute = parseInt(parserArray[5], 10);\r\n        this.second = parseInt(parserArray[6], 10);\r\n    }\r\n    toString(encoding = \"iso\") {\r\n        if (encoding === \"iso\") {\r\n            const outputArray = new Array(7);\r\n            outputArray[0] = pvutils.padNumber(((this.year < 2000) ? (this.year - 1900) : (this.year - 2000)), 2);\r\n            outputArray[1] = pvutils.padNumber(this.month, 2);\r\n            outputArray[2] = pvutils.padNumber(this.day, 2);\r\n            outputArray[3] = pvutils.padNumber(this.hour, 2);\r\n            outputArray[4] = pvutils.padNumber(this.minute, 2);\r\n            outputArray[5] = pvutils.padNumber(this.second, 2);\r\n            outputArray[6] = \"Z\";\r\n            return outputArray.join(\"\");\r\n        }\r\n        return super.toString(encoding);\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            year: this.year,\r\n            month: this.month,\r\n            day: this.day,\r\n            hour: this.hour,\r\n            minute: this.minute,\r\n            second: this.second,\r\n        };\r\n    }\r\n}\r\n_a$6 = UTCTime;\r\n(() => {\r\n    typeStore.UTCTime = _a$6;\r\n})();\r\nUTCTime.NAME = \"UTCTime\";\n\nvar _a$5;\r\nclass GeneralizedTime extends UTCTime {\r\n    constructor(parameters = {}) {\r\n        var _b;\r\n        super(parameters);\r\n        (_b = this.millisecond) !== null && _b !== void 0 ? _b : (this.millisecond = 0);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 24;\r\n    }\r\n    fromDate(inputDate) {\r\n        super.fromDate(inputDate);\r\n        this.millisecond = inputDate.getUTCMilliseconds();\r\n    }\r\n    toDate() {\r\n        return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)));\r\n    }\r\n    fromString(inputString) {\r\n        let isUTC = false;\r\n        let timeString = \"\";\r\n        let dateTimeString = \"\";\r\n        let fractionPart = 0;\r\n        let parser;\r\n        let hourDifference = 0;\r\n        let minuteDifference = 0;\r\n        if (inputString[inputString.length - 1] === \"Z\") {\r\n            timeString = inputString.substring(0, inputString.length - 1);\r\n            isUTC = true;\r\n        }\r\n        else {\r\n            const number = new Number(inputString[inputString.length - 1]);\r\n            if (isNaN(number.valueOf()))\r\n                throw new Error(\"Wrong input string for conversion\");\r\n            timeString = inputString;\r\n        }\r\n        if (isUTC) {\r\n            if (timeString.indexOf(\"+\") !== -1)\r\n                throw new Error(\"Wrong input string for conversion\");\r\n            if (timeString.indexOf(\"-\") !== -1)\r\n                throw new Error(\"Wrong input string for conversion\");\r\n        }\r\n        else {\r\n            let multiplier = 1;\r\n            let differencePosition = timeString.indexOf(\"+\");\r\n            let differenceString = \"\";\r\n            if (differencePosition === -1) {\r\n                differencePosition = timeString.indexOf(\"-\");\r\n                multiplier = -1;\r\n            }\r\n            if (differencePosition !== -1) {\r\n                differenceString = timeString.substring(differencePosition + 1);\r\n                timeString = timeString.substring(0, differencePosition);\r\n                if ((differenceString.length !== 2) && (differenceString.length !== 4))\r\n                    throw new Error(\"Wrong input string for conversion\");\r\n                let number = parseInt(differenceString.substring(0, 2), 10);\r\n                if (isNaN(number.valueOf()))\r\n                    throw new Error(\"Wrong input string for conversion\");\r\n                hourDifference = multiplier * number;\r\n                if (differenceString.length === 4) {\r\n                    number = parseInt(differenceString.substring(2, 4), 10);\r\n                    if (isNaN(number.valueOf()))\r\n                        throw new Error(\"Wrong input string for conversion\");\r\n                    minuteDifference = multiplier * number;\r\n                }\r\n            }\r\n        }\r\n        let fractionPointPosition = timeString.indexOf(\".\");\r\n        if (fractionPointPosition === -1)\r\n            fractionPointPosition = timeString.indexOf(\",\");\r\n        if (fractionPointPosition !== -1) {\r\n            const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);\r\n            if (isNaN(fractionPartCheck.valueOf()))\r\n                throw new Error(\"Wrong input string for conversion\");\r\n            fractionPart = fractionPartCheck.valueOf();\r\n            dateTimeString = timeString.substring(0, fractionPointPosition);\r\n        }\r\n        else\r\n            dateTimeString = timeString;\r\n        switch (true) {\r\n            case (dateTimeString.length === 8):\r\n                parser = /(\\d{4})(\\d{2})(\\d{2})/ig;\r\n                if (fractionPointPosition !== -1)\r\n                    throw new Error(\"Wrong input string for conversion\");\r\n                break;\r\n            case (dateTimeString.length === 10):\r\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})/ig;\r\n                if (fractionPointPosition !== -1) {\r\n                    let fractionResult = 60 * fractionPart;\r\n                    this.minute = Math.floor(fractionResult);\r\n                    fractionResult = 60 * (fractionResult - this.minute);\r\n                    this.second = Math.floor(fractionResult);\r\n                    fractionResult = 1000 * (fractionResult - this.second);\r\n                    this.millisecond = Math.floor(fractionResult);\r\n                }\r\n                break;\r\n            case (dateTimeString.length === 12):\r\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\r\n                if (fractionPointPosition !== -1) {\r\n                    let fractionResult = 60 * fractionPart;\r\n                    this.second = Math.floor(fractionResult);\r\n                    fractionResult = 1000 * (fractionResult - this.second);\r\n                    this.millisecond = Math.floor(fractionResult);\r\n                }\r\n                break;\r\n            case (dateTimeString.length === 14):\r\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\r\n                if (fractionPointPosition !== -1) {\r\n                    const fractionResult = 1000 * fractionPart;\r\n                    this.millisecond = Math.floor(fractionResult);\r\n                }\r\n                break;\r\n            default:\r\n                throw new Error(\"Wrong input string for conversion\");\r\n        }\r\n        const parserArray = parser.exec(dateTimeString);\r\n        if (parserArray === null)\r\n            throw new Error(\"Wrong input string for conversion\");\r\n        for (let j = 1; j < parserArray.length; j++) {\r\n            switch (j) {\r\n                case 1:\r\n                    this.year = parseInt(parserArray[j], 10);\r\n                    break;\r\n                case 2:\r\n                    this.month = parseInt(parserArray[j], 10);\r\n                    break;\r\n                case 3:\r\n                    this.day = parseInt(parserArray[j], 10);\r\n                    break;\r\n                case 4:\r\n                    this.hour = parseInt(parserArray[j], 10) + hourDifference;\r\n                    break;\r\n                case 5:\r\n                    this.minute = parseInt(parserArray[j], 10) + minuteDifference;\r\n                    break;\r\n                case 6:\r\n                    this.second = parseInt(parserArray[j], 10);\r\n                    break;\r\n                default:\r\n                    throw new Error(\"Wrong input string for conversion\");\r\n            }\r\n        }\r\n        if (isUTC === false) {\r\n            const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\r\n            this.year = tempDate.getUTCFullYear();\r\n            this.month = tempDate.getUTCMonth();\r\n            this.day = tempDate.getUTCDay();\r\n            this.hour = tempDate.getUTCHours();\r\n            this.minute = tempDate.getUTCMinutes();\r\n            this.second = tempDate.getUTCSeconds();\r\n            this.millisecond = tempDate.getUTCMilliseconds();\r\n        }\r\n    }\r\n    toString(encoding = \"iso\") {\r\n        if (encoding === \"iso\") {\r\n            const outputArray = [];\r\n            outputArray.push(pvutils.padNumber(this.year, 4));\r\n            outputArray.push(pvutils.padNumber(this.month, 2));\r\n            outputArray.push(pvutils.padNumber(this.day, 2));\r\n            outputArray.push(pvutils.padNumber(this.hour, 2));\r\n            outputArray.push(pvutils.padNumber(this.minute, 2));\r\n            outputArray.push(pvutils.padNumber(this.second, 2));\r\n            if (this.millisecond !== 0) {\r\n                outputArray.push(\".\");\r\n                outputArray.push(pvutils.padNumber(this.millisecond, 3));\r\n            }\r\n            outputArray.push(\"Z\");\r\n            return outputArray.join(\"\");\r\n        }\r\n        return super.toString(encoding);\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            millisecond: this.millisecond,\r\n        };\r\n    }\r\n}\r\n_a$5 = GeneralizedTime;\r\n(() => {\r\n    typeStore.GeneralizedTime = _a$5;\r\n})();\r\nGeneralizedTime.NAME = \"GeneralizedTime\";\n\nvar _a$4;\r\nclass DATE extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 31;\r\n    }\r\n}\r\n_a$4 = DATE;\r\n(() => {\r\n    typeStore.DATE = _a$4;\r\n})();\r\nDATE.NAME = \"DATE\";\n\nvar _a$3;\r\nclass TimeOfDay extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 32;\r\n    }\r\n}\r\n_a$3 = TimeOfDay;\r\n(() => {\r\n    typeStore.TimeOfDay = _a$3;\r\n})();\r\nTimeOfDay.NAME = \"TimeOfDay\";\n\nvar _a$2;\r\nclass DateTime extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 33;\r\n    }\r\n}\r\n_a$2 = DateTime;\r\n(() => {\r\n    typeStore.DateTime = _a$2;\r\n})();\r\nDateTime.NAME = \"DateTime\";\n\nvar _a$1;\r\nclass Duration extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 34;\r\n    }\r\n}\r\n_a$1 = Duration;\r\n(() => {\r\n    typeStore.Duration = _a$1;\r\n})();\r\nDuration.NAME = \"Duration\";\n\nvar _a;\r\nclass TIME extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 14;\r\n    }\r\n}\r\n_a = TIME;\r\n(() => {\r\n    typeStore.TIME = _a;\r\n})();\r\nTIME.NAME = \"TIME\";\n\nclass Any {\r\n    constructor({ name = EMPTY_STRING, optional = false, } = {}) {\r\n        this.name = name;\r\n        this.optional = optional;\r\n    }\r\n}\n\nclass Choice extends Any {\r\n    constructor({ value = [], ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = value;\r\n    }\r\n}\n\nclass Repeated extends Any {\r\n    constructor({ value = new Any(), local = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = value;\r\n        this.local = local;\r\n    }\r\n}\n\nclass RawData {\r\n    constructor({ data = EMPTY_VIEW } = {}) {\r\n        this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(data);\r\n    }\r\n    get data() {\r\n        return this.dataView.slice().buffer;\r\n    }\r\n    set data(value) {\r\n        this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(value);\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const endLength = inputOffset + inputLength;\r\n        this.dataView = pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);\r\n        return endLength;\r\n    }\r\n    toBER(sizeOnly) {\r\n        return this.dataView.slice().buffer;\r\n    }\r\n}\n\nfunction compareSchema(root, inputData, inputSchema) {\r\n    if (inputSchema instanceof Choice) {\r\n        for (let j = 0; j < inputSchema.value.length; j++) {\r\n            const result = compareSchema(root, inputData, inputSchema.value[j]);\r\n            if (result.verified) {\r\n                return {\r\n                    verified: true,\r\n                    result: root\r\n                };\r\n            }\r\n        }\r\n        {\r\n            const _result = {\r\n                verified: false,\r\n                result: {\r\n                    error: \"Wrong values for Choice type\"\r\n                },\r\n            };\r\n            if (inputSchema.hasOwnProperty(NAME))\r\n                _result.name = inputSchema.name;\r\n            return _result;\r\n        }\r\n    }\r\n    if (inputSchema instanceof Any) {\r\n        if (inputSchema.hasOwnProperty(NAME))\r\n            root[inputSchema.name] = inputData;\r\n        return {\r\n            verified: true,\r\n            result: root\r\n        };\r\n    }\r\n    if ((root instanceof Object) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong root object\" }\r\n        };\r\n    }\r\n    if ((inputData instanceof Object) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 data\" }\r\n        };\r\n    }\r\n    if ((inputSchema instanceof Object) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if ((ID_BLOCK in inputSchema) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if ((FROM_BER in inputSchema.idBlock) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if ((TO_BER in inputSchema.idBlock) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    const encodedId = inputSchema.idBlock.toBER(false);\r\n    if (encodedId.byteLength === 0) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Error encoding idBlock for ASN.1 schema\" }\r\n        };\r\n    }\r\n    const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);\r\n    if (decodedOffset === -1) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Error decoding idBlock for ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {\r\n        return {\r\n            verified: false,\r\n            result: root\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {\r\n        return {\r\n            verified: false,\r\n            result: root\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {\r\n        return {\r\n            verified: false,\r\n            result: root\r\n        };\r\n    }\r\n    if (!(IS_HEX_ONLY in inputSchema.idBlock)) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {\r\n        return {\r\n            verified: false,\r\n            result: root\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.isHexOnly) {\r\n        if ((VALUE_HEX_VIEW in inputSchema.idBlock) === false) {\r\n            return {\r\n                verified: false,\r\n                result: { error: \"Wrong ASN.1 schema\" }\r\n            };\r\n        }\r\n        const schemaView = inputSchema.idBlock.valueHexView;\r\n        const asn1View = inputData.idBlock.valueHexView;\r\n        if (schemaView.length !== asn1View.length) {\r\n            return {\r\n                verified: false,\r\n                result: root\r\n            };\r\n        }\r\n        for (let i = 0; i < schemaView.length; i++) {\r\n            if (schemaView[i] !== asn1View[1]) {\r\n                return {\r\n                    verified: false,\r\n                    result: root\r\n                };\r\n            }\r\n        }\r\n    }\r\n    if (inputSchema.name) {\r\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n        if (inputSchema.name)\r\n            root[inputSchema.name] = inputData;\r\n    }\r\n    if (inputSchema instanceof typeStore.Constructed) {\r\n        let admission = 0;\r\n        let result = {\r\n            verified: false,\r\n            result: {\r\n                error: \"Unknown error\",\r\n            }\r\n        };\r\n        let maxLength = inputSchema.valueBlock.value.length;\r\n        if (maxLength > 0) {\r\n            if (inputSchema.valueBlock.value[0] instanceof Repeated) {\r\n                maxLength = inputData.valueBlock.value.length;\r\n            }\r\n        }\r\n        if (maxLength === 0) {\r\n            return {\r\n                verified: true,\r\n                result: root\r\n            };\r\n        }\r\n        if ((inputData.valueBlock.value.length === 0) &&\r\n            (inputSchema.valueBlock.value.length !== 0)) {\r\n            let _optional = true;\r\n            for (let i = 0; i < inputSchema.valueBlock.value.length; i++)\r\n                _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);\r\n            if (_optional) {\r\n                return {\r\n                    verified: true,\r\n                    result: root\r\n                };\r\n            }\r\n            if (inputSchema.name) {\r\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                if (inputSchema.name)\r\n                    delete root[inputSchema.name];\r\n            }\r\n            root.error = \"Inconsistent object length\";\r\n            return {\r\n                verified: false,\r\n                result: root\r\n            };\r\n        }\r\n        for (let i = 0; i < maxLength; i++) {\r\n            if ((i - admission) >= inputData.valueBlock.value.length) {\r\n                if (inputSchema.valueBlock.value[i].optional === false) {\r\n                    const _result = {\r\n                        verified: false,\r\n                        result: root\r\n                    };\r\n                    root.error = \"Inconsistent length between ASN.1 data and schema\";\r\n                    if (inputSchema.name) {\r\n                        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                        if (inputSchema.name) {\r\n                            delete root[inputSchema.name];\r\n                            _result.name = inputSchema.name;\r\n                        }\r\n                    }\r\n                    return _result;\r\n                }\r\n            }\r\n            else {\r\n                if (inputSchema.valueBlock.value[0] instanceof Repeated) {\r\n                    result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);\r\n                    if (result.verified === false) {\r\n                        if (inputSchema.valueBlock.value[0].optional)\r\n                            admission++;\r\n                        else {\r\n                            if (inputSchema.name) {\r\n                                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                                if (inputSchema.name)\r\n                                    delete root[inputSchema.name];\r\n                            }\r\n                            return result;\r\n                        }\r\n                    }\r\n                    if ((NAME in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].name.length > 0)) {\r\n                        let arrayRoot = {};\r\n                        if ((LOCAL in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].local))\r\n                            arrayRoot = inputData;\r\n                        else\r\n                            arrayRoot = root;\r\n                        if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === \"undefined\")\r\n                            arrayRoot[inputSchema.valueBlock.value[0].name] = [];\r\n                        arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);\r\n                    }\r\n                }\r\n                else {\r\n                    result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);\r\n                    if (result.verified === false) {\r\n                        if (inputSchema.valueBlock.value[i].optional)\r\n                            admission++;\r\n                        else {\r\n                            if (inputSchema.name) {\r\n                                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                                if (inputSchema.name)\r\n                                    delete root[inputSchema.name];\r\n                            }\r\n                            return result;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (result.verified === false) {\r\n            const _result = {\r\n                verified: false,\r\n                result: root\r\n            };\r\n            if (inputSchema.name) {\r\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                if (inputSchema.name) {\r\n                    delete root[inputSchema.name];\r\n                    _result.name = inputSchema.name;\r\n                }\r\n            }\r\n            return _result;\r\n        }\r\n        return {\r\n            verified: true,\r\n            result: root\r\n        };\r\n    }\r\n    if (inputSchema.primitiveSchema &&\r\n        (VALUE_HEX_VIEW in inputData.valueBlock)) {\r\n        const asn1 = localFromBER(inputData.valueBlock.valueHexView);\r\n        if (asn1.offset === -1) {\r\n            const _result = {\r\n                verified: false,\r\n                result: asn1.result\r\n            };\r\n            if (inputSchema.name) {\r\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                if (inputSchema.name) {\r\n                    delete root[inputSchema.name];\r\n                    _result.name = inputSchema.name;\r\n                }\r\n            }\r\n            return _result;\r\n        }\r\n        return compareSchema(root, asn1.result, inputSchema.primitiveSchema);\r\n    }\r\n    return {\r\n        verified: true,\r\n        result: root\r\n    };\r\n}\r\nfunction verifySchema(inputBuffer, inputSchema) {\r\n    if ((inputSchema instanceof Object) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema type\" }\r\n        };\r\n    }\r\n    const asn1 = localFromBER(pvtsutils.BufferSourceConverter.toUint8Array(inputBuffer));\r\n    if (asn1.offset === -1) {\r\n        return {\r\n            verified: false,\r\n            result: asn1.result\r\n        };\r\n    }\r\n    return compareSchema(asn1.result, asn1.result, inputSchema);\r\n}\n\nexport { Any, BaseBlock, BaseStringBlock, BitString, BmpString, Boolean, CharacterString, Choice, Constructed, DATE, DateTime, Duration, EndOfContent, Enumerated, GeneralString, GeneralizedTime, GraphicString, HexBlock, IA5String, Integer, Null, NumericString, ObjectIdentifier, OctetString, Primitive, PrintableString, RawData, RelativeObjectIdentifier, Repeated, Sequence, Set, TIME, TeletexString, TimeOfDay, UTCTime, UniversalString, Utf8String, ValueBlock, VideotexString, ViewWriter, VisibleString, compareSchema, fromBER, verifySchema };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}