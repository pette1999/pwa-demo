{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\nconst NoFilter = require('nofilter');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst {\n  MT,\n  NUMBYTES,\n  SHIFT32,\n  SIMPLE,\n  SYMS,\n  TAG,\n  BI\n} = constants;\nconst {\n  Buffer\n} = require('buffer');\nconst HALF = MT.SIMPLE_FLOAT << 5 | NUMBYTES.TWO;\nconst FLOAT = MT.SIMPLE_FLOAT << 5 | NUMBYTES.FOUR;\nconst DOUBLE = MT.SIMPLE_FLOAT << 5 | NUMBYTES.EIGHT;\nconst TRUE = MT.SIMPLE_FLOAT << 5 | SIMPLE.TRUE;\nconst FALSE = MT.SIMPLE_FLOAT << 5 | SIMPLE.FALSE;\nconst UNDEFINED = MT.SIMPLE_FLOAT << 5 | SIMPLE.UNDEFINED;\nconst NULL = MT.SIMPLE_FLOAT << 5 | SIMPLE.NULL;\nconst BREAK = Buffer.from([0xff]);\nconst BUF_NAN = Buffer.from('f97e00', 'hex');\nconst BUF_INF_NEG = Buffer.from('f9fc00', 'hex');\nconst BUF_INF_POS = Buffer.from('f97c00', 'hex');\nconst BUF_NEG_ZERO = Buffer.from('f98000', 'hex');\n\n/**\n * Generate the CBOR for a value.  If you are using this, you'll either need\n * to call {@link Encoder.write} with a Buffer, or look into the internals of\n * Encoder to reuse existing non-documented behavior.\n *\n * @callback EncodeFunction\n * @param {Encoder} enc The encoder to use.\n * @param {any} val The value to encode.\n * @returns {boolean} True on success.\n */\n\n/* eslint-disable jsdoc/check-types */\n/**\n * A mapping from tag number to a tag decoding function.\n *\n * @typedef {Object.<string, EncodeFunction>} SemanticMap\n */\n/* eslint-enable jsdoc/check-types */\n\n/**\n * @type {SemanticMap}\n * @private\n */\nconst SEMANTIC_TYPES = {};\n\n/**\n * @type {SemanticMap}\n * @private\n */\nlet current_SEMANTIC_TYPES = {};\n\n/**\n * @param {string} str String to normalize.\n * @returns {\"number\"|\"float\"|\"int\"|\"string\"} Normalized.\n * @throws {TypeError} Invalid input.\n * @private\n */\nfunction parseDateType(str) {\n  if (!str) {\n    return 'number';\n  }\n  switch (str.toLowerCase()) {\n    case 'number':\n      return 'number';\n    case 'float':\n      return 'float';\n    case 'int':\n    case 'integer':\n      return 'int';\n    case 'string':\n      return 'string';\n  }\n  throw new TypeError(`dateType invalid, got \"${str}\"`);\n}\n\n/**\n * @typedef ObjectOptions\n * @property {boolean} [indefinite = false] Force indefinite encoding for this\n *   object.\n * @property {boolean} [skipTypes = false] Do not use available type mappings\n *   for this object, but encode it as a \"normal\" JS object would be.\n */\n\n/**\n * @typedef EncodingOptions\n * @property {any[]|object} [genTypes=[]] Array of pairs of\n *   `type`, `function(Encoder)` for semantic types to be encoded.  Not\n *   needed for Array, Date, Buffer, Map, RegExp, Set, or URL.\n *   If an object, the keys are the constructor names for the types.\n * @property {boolean} [canonical=false] Should the output be\n *   canonicalized.\n * @property {boolean|WeakSet} [detectLoops=false] Should object loops\n *   be detected?  This will currently add memory to track every part of the\n *   object being encoded in a WeakSet.  Do not encode\n *   the same object twice on the same encoder, without calling\n *   `removeLoopDetectors` in between, which will clear the WeakSet.\n *   You may pass in your own WeakSet to be used; this is useful in some\n *   recursive scenarios.\n * @property {(\"number\"|\"float\"|\"int\"|\"string\")} [dateType=\"number\"] -\n *   how should dates be encoded?  \"number\" means float or int, if no\n *   fractional seconds.\n * @property {any} [encodeUndefined=undefined] How should an\n *   \"undefined\" in the input be encoded.  By default, just encode a CBOR\n *   undefined.  If this is a buffer, use those bytes without re-encoding\n *   them.  If this is a function, the function will be called (which is a\n *   good time to throw an exception, if that's what you want), and the\n *   return value will be used according to these rules.  Anything else will\n *   be encoded as CBOR.\n * @property {boolean} [disallowUndefinedKeys=false] Should\n *   \"undefined\" be disallowed as a key in a Map that is serialized?  If\n *   this is true, encode(new Map([[undefined, 1]])) will throw an\n *   exception.  Note that it is impossible to get a key of undefined in a\n *   normal JS object.\n * @property {boolean} [collapseBigIntegers=false] Should integers\n *   that come in as ECMAscript bigint's be encoded\n *   as normal CBOR integers if they fit, discarding type information?\n * @property {number} [chunkSize=4096] Number of characters or bytes\n *   for each chunk, if obj is a string or Buffer, when indefinite encoding.\n * @property {boolean} [omitUndefinedProperties=false] When encoding\n *   objects or Maps, do not include a key if its corresponding value is\n *   `undefined`.\n */\n\n/**\n * Transform JavaScript values into CBOR bytes.  The `Writable` side of\n * the stream is in object mode.\n *\n * @extends stream.Transform\n */\nclass Encoder extends stream.Transform {\n  /**\n   * Creates an instance of Encoder.\n   *\n   * @param {EncodingOptions} [options={}] Options for the encoder.\n   */\n  constructor(options = {}) {\n    const {\n      canonical = false,\n      encodeUndefined,\n      disallowUndefinedKeys = false,\n      dateType = 'number',\n      collapseBigIntegers = false,\n      detectLoops = false,\n      omitUndefinedProperties = false,\n      genTypes = [],\n      ...superOpts\n    } = options;\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: true\n    });\n    this.canonical = canonical;\n    this.encodeUndefined = encodeUndefined;\n    this.disallowUndefinedKeys = disallowUndefinedKeys;\n    this.dateType = parseDateType(dateType);\n    this.collapseBigIntegers = this.canonical ? true : collapseBigIntegers;\n\n    /** @type {WeakSet?} */\n    this.detectLoops = undefined;\n    if (typeof detectLoops === 'boolean') {\n      if (detectLoops) {\n        this.detectLoops = new WeakSet();\n      }\n    } else if (detectLoops instanceof WeakSet) {\n      this.detectLoops = detectLoops;\n    } else {\n      throw new TypeError('detectLoops must be boolean or WeakSet');\n    }\n    this.omitUndefinedProperties = omitUndefinedProperties;\n    this.semanticTypes = {\n      ...Encoder.SEMANTIC_TYPES\n    };\n    if (Array.isArray(genTypes)) {\n      for (let i = 0, len = genTypes.length; i < len; i += 2) {\n        this.addSemanticType(genTypes[i], genTypes[i + 1]);\n      }\n    } else {\n      for (const [k, v] of Object.entries(genTypes)) {\n        this.addSemanticType(k, v);\n      }\n    }\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, encoding, cb) {\n    const ret = this.pushAny(fresh);\n    // Old transformers might not return bool.  undefined !== false\n    cb(ret === false ? new Error('Push Error') : undefined);\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  // eslint-disable-next-line class-methods-use-this\n  _flush(cb) {\n    cb();\n  }\n\n  /**\n   * @param {number} val Number(0-255) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt8(val) {\n    const b = Buffer.allocUnsafe(1);\n    b.writeUInt8(val, 0);\n    return this.push(b);\n  }\n\n  /**\n   * @param {number} val Number(0-65535) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt16BE(val) {\n    const b = Buffer.allocUnsafe(2);\n    b.writeUInt16BE(val, 0);\n    return this.push(b);\n  }\n\n  /**\n   * @param {number} val Number(0..2**32-1) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt32BE(val) {\n    const b = Buffer.allocUnsafe(4);\n    b.writeUInt32BE(val, 0);\n    return this.push(b);\n  }\n\n  /**\n   * @param {number} val Number to encode as 4-byte float.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushFloatBE(val) {\n    const b = Buffer.allocUnsafe(4);\n    b.writeFloatBE(val, 0);\n    return this.push(b);\n  }\n\n  /**\n   * @param {number} val Number to encode as 8-byte double.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushDoubleBE(val) {\n    const b = Buffer.allocUnsafe(8);\n    b.writeDoubleBE(val, 0);\n    return this.push(b);\n  }\n\n  /**\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNaN() {\n    return this.push(BUF_NAN);\n  }\n\n  /**\n   * @param {number} obj Positive or negative infinity.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushInfinity(obj) {\n    const half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;\n    return this.push(half);\n  }\n\n  /**\n   * Choose the best float representation for a number and encode it.\n   *\n   * @param {number} obj A number that is known to be not-integer, but not\n   *   how many bytes of precision it needs.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushFloat(obj) {\n    if (this.canonical) {\n      // TODO: is this enough slower to hide behind canonical?\n      // It's certainly enough of a hack (see utils.parseHalf)\n\n      // From section 3.9:\n      // If a protocol allows for IEEE floats, then additional canonicalization\n      // rules might need to be added.  One example rule might be to have all\n      // floats start as a 64-bit float, then do a test conversion to a 32-bit\n      // float; if the result is the same numeric value, use the shorter value\n      // and repeat the process with a test conversion to a 16-bit float.  (This\n      // rule selects 16-bit float for positive and negative Infinity as well.)\n\n      // which seems pretty much backwards to me.\n      const b2 = Buffer.allocUnsafe(2);\n      if (utils.writeHalf(b2, obj)) {\n        // I have convinced myself that there are no cases where writeHalf\n        // will return true but `utils.parseHalf(b2) !== obj)`\n        return this._pushUInt8(HALF) && this.push(b2);\n      }\n    }\n    if (Math.fround(obj) === obj) {\n      return this._pushUInt8(FLOAT) && this._pushFloatBE(obj);\n    }\n    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);\n  }\n\n  /**\n   * Choose the best integer representation for a postive number and encode\n   * it.  If the number is over MAX_SAFE_INTEGER, fall back on float (but I\n   * don't remember why).\n   *\n   * @param {number} obj A positive number that is known to be an integer,\n   *   but not how many bytes of precision it needs.\n   * @param {number} mt The Major Type number to combine with the integer.\n   *   Not yet shifted.\n   * @param {number} [orig] The number before it was transformed to positive.\n   *   If the mt is NEG_INT, and the positive number is over MAX_SAFE_INT,\n   *   then we'll encode this as a float rather than making the number\n   *   negative again and losing precision.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushInt(obj, mt, orig) {\n    const m = mt << 5;\n    if (obj < 24) {\n      return this._pushUInt8(m | obj);\n    }\n    if (obj <= 0xff) {\n      return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);\n    }\n    if (obj <= 0xffff) {\n      return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);\n    }\n    if (obj <= 0xffffffff) {\n      return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);\n    }\n    let max = Number.MAX_SAFE_INTEGER;\n    if (mt === MT.NEG_INT) {\n      // Special case for Number.MIN_SAFE_INTEGER - 1\n      max--;\n    }\n    if (obj <= max) {\n      return this._pushUInt8(m | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);\n    }\n    if (mt === MT.NEG_INT) {\n      return this._pushFloat(orig);\n    }\n    return this._pushFloat(obj);\n  }\n\n  /**\n   * Choose the best integer representation for a number and encode it.\n   *\n   * @param {number} obj A number that is known to be an integer,\n   *   but not how many bytes of precision it needs.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushIntNum(obj) {\n    if (Object.is(obj, -0)) {\n      return this.push(BUF_NEG_ZERO);\n    }\n    if (obj < 0) {\n      return this._pushInt(-obj - 1, MT.NEG_INT, obj);\n    }\n    return this._pushInt(obj, MT.POS_INT);\n  }\n\n  /**\n   * @param {number} obj Plain JS number to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNumber(obj) {\n    if (isNaN(obj)) {\n      return this._pushNaN();\n    }\n    if (!isFinite(obj)) {\n      return this._pushInfinity(obj);\n    }\n    if (Math.round(obj) === obj) {\n      return this._pushIntNum(obj);\n    }\n    return this._pushFloat(obj);\n  }\n\n  /**\n   * @param {string} obj String to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushString(obj) {\n    const len = Buffer.byteLength(obj, 'utf8');\n    return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8');\n  }\n\n  /**\n   * @param {boolean} obj Bool to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushBoolean(obj) {\n    return this._pushUInt8(obj ? TRUE : FALSE);\n  }\n\n  /**\n   * @param {undefined} obj Ignored.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUndefined(obj) {\n    switch (typeof this.encodeUndefined) {\n      case 'undefined':\n        return this._pushUInt8(UNDEFINED);\n      case 'function':\n        return this.pushAny(this.encodeUndefined(obj));\n      case 'object':\n        {\n          const buf = utils.bufferishToBuffer(this.encodeUndefined);\n          if (buf) {\n            return this.push(buf);\n          }\n        }\n    }\n    return this.pushAny(this.encodeUndefined);\n  }\n\n  /**\n   * @param {null} obj Ignored.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNull(obj) {\n    return this._pushUInt8(NULL);\n  }\n\n  /**\n   * @param {number} tag Tag number to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushTag(tag) {\n    return this._pushInt(tag, MT.TAG);\n  }\n\n  /**\n   * @param {bigint} obj BigInt to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushJSBigint(obj) {\n    let m = MT.POS_INT;\n    let tag = TAG.POS_BIGINT;\n    // BigInt doesn't have -0\n    if (obj < 0) {\n      obj = -obj + BI.MINUS_ONE;\n      m = MT.NEG_INT;\n      tag = TAG.NEG_BIGINT;\n    }\n    if (this.collapseBigIntegers && obj <= BI.MAXINT64) {\n      // Special handiling for 64bits\n      if (obj <= 0xffffffff) {\n        return this._pushInt(Number(obj), m);\n      }\n      return this._pushUInt8(m << 5 | NUMBYTES.EIGHT) && this._pushUInt32BE(Number(obj / BI.SHIFT32)) && this._pushUInt32BE(Number(obj % BI.SHIFT32));\n    }\n    let str = obj.toString(16);\n    if (str.length % 2) {\n      str = `0${str}`;\n    }\n    const buf = Buffer.from(str, 'hex');\n    return this._pushTag(tag) && Encoder._pushBuffer(this, buf);\n  }\n\n  /**\n   * @param {object} obj Object to encode.\n   * @param {ObjectOptions} [opts] Options for encoding this object.\n   * @returns {boolean} True on success.\n   * @throws {Error} Loop detected.\n   * @ignore\n   */\n  _pushObject(obj, opts) {\n    if (!obj) {\n      return this._pushNull(obj);\n    }\n    opts = {\n      indefinite: false,\n      skipTypes: false,\n      ...opts\n    };\n    if (!opts.indefinite) {\n      // This will only happen the first time through for indefinite encoding\n      if (this.detectLoops) {\n        if (this.detectLoops.has(obj)) {\n          throw new Error(`\\\nLoop detected while CBOR encoding.\nCall removeLoopDetectors before resuming.`);\n        } else {\n          this.detectLoops.add(obj);\n        }\n      }\n    }\n    if (!opts.skipTypes) {\n      const f = obj.encodeCBOR;\n      if (typeof f === 'function') {\n        return f.call(obj, this);\n      }\n      const converter = this.semanticTypes[obj.constructor.name];\n      if (converter) {\n        return converter.call(obj, this, obj);\n      }\n    }\n    const keys = Object.keys(obj).filter(k => {\n      const tv = typeof obj[k];\n      return tv !== 'function' && (!this.omitUndefinedProperties || tv !== 'undefined');\n    });\n    const cbor_keys = {};\n    if (this.canonical) {\n      // Note: this can't be a normal sort, because 'b' needs to sort before\n      // 'aa'\n      keys.sort((a, b) => {\n        // Always strings, so don't bother to pass options.\n        // hold on to the cbor versions, since there's no need\n        // to encode more than once\n        const a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a));\n        const b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b));\n        return a_cbor.compare(b_cbor);\n      });\n    }\n    if (opts.indefinite) {\n      if (!this._pushUInt8(MT.MAP << 5 | NUMBYTES.INDEFINITE)) {\n        return false;\n      }\n    } else if (!this._pushInt(keys.length, MT.MAP)) {\n      return false;\n    }\n    let ck = null;\n    for (let j = 0, len2 = keys.length; j < len2; j++) {\n      const k = keys[j];\n      if (this.canonical && (ck = cbor_keys[k])) {\n        if (!this.push(ck)) {\n          // Already a Buffer\n          return false;\n        }\n      } else if (!this._pushString(k)) {\n        return false;\n      }\n      if (!this.pushAny(obj[k])) {\n        return false;\n      }\n    }\n    if (opts.indefinite) {\n      if (!this.push(BREAK)) {\n        return false;\n      }\n    } else if (this.detectLoops) {\n      this.detectLoops.delete(obj);\n    }\n    return true;\n  }\n\n  /**\n   * @param {any[]} objs Array of supported things.\n   * @returns {Buffer} Concatenation of encodings for the supported things.\n   * @ignore\n   */\n  _encodeAll(objs) {\n    const bs = new NoFilter({\n      highWaterMark: this.readableHighWaterMark\n    });\n    this.pipe(bs);\n    for (const o of objs) {\n      this.pushAny(o);\n    }\n    this.end();\n    return bs.read();\n  }\n\n  /**\n   * Add an encoding function to the list of supported semantic types.  This\n   * is useful for objects for which you can't add an encodeCBOR method.\n   *\n   * @param {string|Function} type The type to encode.\n   * @param {EncodeFunction} fun The encoder to use.\n   * @returns {EncodeFunction?} The previous encoder or undefined if there\n   *   wasn't one.\n   * @throws {TypeError} Invalid function.\n   */\n  addSemanticType(type, fun) {\n    const typeName = typeof type === 'string' ? type : type.name;\n    const old = this.semanticTypes[typeName];\n    if (fun) {\n      if (typeof fun !== 'function') {\n        throw new TypeError('fun must be of type function');\n      }\n      this.semanticTypes[typeName] = fun;\n    } else if (old) {\n      delete this.semanticTypes[typeName];\n    }\n    return old;\n  }\n\n  /**\n   * Push any supported type onto the encoded stream.\n   *\n   * @param {any} obj The thing to encode.\n   * @returns {boolean} True on success.\n   * @throws {TypeError} Unknown type for obj.\n   */\n  pushAny(obj) {\n    switch (typeof obj) {\n      case 'number':\n        return this._pushNumber(obj);\n      case 'bigint':\n        return this._pushJSBigint(obj);\n      case 'string':\n        return this._pushString(obj);\n      case 'boolean':\n        return this._pushBoolean(obj);\n      case 'undefined':\n        return this._pushUndefined(obj);\n      case 'object':\n        return this._pushObject(obj);\n      case 'symbol':\n        switch (obj) {\n          case SYMS.NULL:\n            return this._pushNull(null);\n          case SYMS.UNDEFINED:\n            return this._pushUndefined(undefined);\n          // TODO: Add pluggable support for other symbols\n          default:\n            throw new TypeError(`Unknown symbol: ${obj.toString()}`);\n        }\n      default:\n        throw new TypeError(`Unknown type: ${typeof obj}, ${typeof obj.toString === 'function' ? obj.toString() : ''}`);\n    }\n  }\n\n  /**\n   * Encode an array and all of its elements.\n   *\n   * @param {Encoder} gen Encoder to use.\n   * @param {any[]} obj Array to encode.\n   * @param {object} [opts] Options.\n   * @param {boolean} [opts.indefinite=false] Use indefinite encoding?\n   * @returns {boolean} True on success.\n   */\n  static pushArray(gen, obj, opts) {\n    opts = {\n      indefinite: false,\n      ...opts\n    };\n    const len = obj.length;\n    if (opts.indefinite) {\n      if (!gen._pushUInt8(MT.ARRAY << 5 | NUMBYTES.INDEFINITE)) {\n        return false;\n      }\n    } else if (!gen._pushInt(len, MT.ARRAY)) {\n      return false;\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen.pushAny(obj[j])) {\n        return false;\n      }\n    }\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Remove the loop detector WeakSet for this Encoder.\n   *\n   * @returns {boolean} True when the Encoder was reset, else false.\n   */\n  removeLoopDetectors() {\n    if (!this.detectLoops) {\n      return false;\n    }\n    this.detectLoops = new WeakSet();\n    return true;\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Date} obj Date to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushDate(gen, obj) {\n    switch (gen.dateType) {\n      case 'string':\n        return gen._pushTag(TAG.DATE_STRING) && gen._pushString(obj.toISOString());\n      case 'int':\n        return gen._pushTag(TAG.DATE_EPOCH) && gen._pushIntNum(Math.round(obj.getTime() / 1000));\n      case 'float':\n        // Force float\n        return gen._pushTag(TAG.DATE_EPOCH) && gen._pushFloat(obj.getTime() / 1000);\n      case 'number':\n      default:\n        // If we happen to have an integral number of seconds,\n        // use integer.  Otherwise, use float.\n        return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(obj.getTime() / 1000);\n    }\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Buffer} obj Buffer to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushBuffer(gen, obj) {\n    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {NoFilter} obj Buffer to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushNoFilter(gen, obj) {\n    return Encoder._pushBuffer(gen, /** @type {Buffer} */obj.slice());\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {RegExp} obj RegExp to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushRegexp(gen, obj) {\n    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Set} obj Set to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushSet(gen, obj) {\n    if (!gen._pushTag(TAG.SET)) {\n      return false;\n    }\n    if (!gen._pushInt(obj.size, MT.ARRAY)) {\n      return false;\n    }\n    for (const x of obj) {\n      if (!gen.pushAny(x)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {URL} obj URL to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushURL(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString());\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {object} obj Boxed String, Number, or Boolean object to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushBoxed(gen, obj) {\n    return gen.pushAny(obj.valueOf());\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Map} obj Map to encode.\n   * @returns {boolean} True on success.\n   * @throws {Error} Map key that is undefined.\n   * @ignore\n   */\n  static _pushMap(gen, obj, opts) {\n    opts = {\n      indefinite: false,\n      ...opts\n    };\n    let entries = [...obj.entries()];\n    if (gen.omitUndefinedProperties) {\n      entries = entries.filter(([k, v]) => v !== undefined);\n    }\n    if (opts.indefinite) {\n      if (!gen._pushUInt8(MT.MAP << 5 | NUMBYTES.INDEFINITE)) {\n        return false;\n      }\n    } else if (!gen._pushInt(entries.length, MT.MAP)) {\n      return false;\n    }\n    // Memoizing the cbor only helps in certain cases, and hurts in most\n    // others.  Just avoid it.\n    if (gen.canonical) {\n      // Keep the key/value pairs together, so we don't have to do odd\n      // gets with object keys later\n      const enc = new Encoder({\n        genTypes: gen.semanticTypes,\n        canonical: gen.canonical,\n        detectLoops: Boolean(gen.detectLoops),\n        // Give enc its own loop detector\n        dateType: gen.dateType,\n        disallowUndefinedKeys: gen.disallowUndefinedKeys,\n        collapseBigIntegers: gen.collapseBigIntegers\n      });\n      const bs = new NoFilter({\n        highWaterMark: gen.readableHighWaterMark\n      });\n      enc.pipe(bs);\n      entries.sort(([a], [b]) => {\n        // Both a and b are the keys\n        enc.pushAny(a);\n        const a_cbor = bs.read();\n        enc.pushAny(b);\n        const b_cbor = bs.read();\n        return a_cbor.compare(b_cbor);\n      });\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && typeof k === 'undefined') {\n          throw new Error('Invalid Map key: undefined');\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false;\n        }\n      }\n    } else {\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && typeof k === 'undefined') {\n          throw new Error('Invalid Map key: undefined');\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false;\n        }\n      }\n    }\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {NodeJS.TypedArray} obj Array to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushTypedArray(gen, obj) {\n    // See https://tools.ietf.org/html/rfc8746\n\n    let typ = 0b01000000;\n    let sz = obj.BYTES_PER_ELEMENT;\n    const {\n      name\n    } = obj.constructor;\n    if (name.startsWith('Float')) {\n      typ |= 0b00010000;\n      sz /= 2;\n    } else if (!name.includes('U')) {\n      typ |= 0b00001000;\n    }\n    if (name.includes('Clamped') || sz !== 1 && !utils.isBigEndian()) {\n      typ |= 0b00000100;\n    }\n    typ |= {\n      1: 0b00,\n      2: 0b01,\n      4: 0b10,\n      8: 0b11\n    }[sz];\n    if (!gen._pushTag(typ)) {\n      return false;\n    }\n    return Encoder._pushBuffer(gen, Buffer.from(obj.buffer, obj.byteOffset, obj.byteLength));\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param { ArrayBuffer } obj Array to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushArrayBuffer(gen, obj) {\n    return Encoder._pushBuffer(gen, Buffer.from(obj));\n  }\n\n  /**\n   * Encode the given object with indefinite length.  There are apparently\n   * some (IMO) broken implementations of poorly-specified protocols that\n   * REQUIRE indefinite-encoding.  See the example for how to add this as an\n   * `encodeCBOR` function to an object or class to get indefinite encoding.\n   *\n   * @param {Encoder} gen The encoder to use.\n   * @param {string|Buffer|Array|Map|object} [obj] The object to encode.  If\n   *   null, use \"this\" instead.\n   * @param {EncodingOptions} [options={}] Options for encoding.\n   * @returns {boolean} True on success.\n   * @throws {Error} No object to encode or invalid indefinite encoding.\n   * @example <caption>Force indefinite encoding:</caption>\n   * const o = {\n   *   a: true,\n   *   encodeCBOR: cbor.Encoder.encodeIndefinite,\n   * }\n   * const m = []\n   * m.encodeCBOR = cbor.Encoder.encodeIndefinite\n   * cbor.encodeOne([o, m])\n   */\n  static encodeIndefinite(gen, obj, options = {}) {\n    if (obj == null) {\n      if (this == null) {\n        throw new Error('No object to encode');\n      }\n      obj = this;\n    }\n\n    // TODO: consider other options\n    const {\n      chunkSize = 4096\n    } = options;\n    let ret = true;\n    const objType = typeof obj;\n    let buf = null;\n    if (objType === 'string') {\n      // TODO: make sure not to split surrogate pairs at the edges of chunks,\n      // since such half-surrogates cannot be legally encoded as UTF-8.\n      ret = ret && gen._pushUInt8(MT.UTF8_STRING << 5 | NUMBYTES.INDEFINITE);\n      let offset = 0;\n      while (offset < obj.length) {\n        const endIndex = offset + chunkSize;\n        ret = ret && gen._pushString(obj.slice(offset, endIndex));\n        offset = endIndex;\n      }\n      ret = ret && gen.push(BREAK);\n    } else if (buf = utils.bufferishToBuffer(obj)) {\n      ret = ret && gen._pushUInt8(MT.BYTE_STRING << 5 | NUMBYTES.INDEFINITE);\n      let offset = 0;\n      while (offset < buf.length) {\n        const endIndex = offset + chunkSize;\n        ret = ret && Encoder._pushBuffer(gen, buf.slice(offset, endIndex));\n        offset = endIndex;\n      }\n      ret = ret && gen.push(BREAK);\n    } else if (Array.isArray(obj)) {\n      ret = ret && Encoder.pushArray(gen, obj, {\n        indefinite: true\n      });\n    } else if (obj instanceof Map) {\n      ret = ret && Encoder._pushMap(gen, obj, {\n        indefinite: true\n      });\n    } else {\n      if (objType !== 'object') {\n        throw new Error('Invalid indefinite encoding');\n      }\n      ret = ret && gen._pushObject(obj, {\n        indefinite: true,\n        skipTypes: true\n      });\n    }\n    return ret;\n  }\n\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encode(...objs) {\n    return new Encoder()._encodeAll(objs);\n  }\n\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encodeCanonical(...objs) {\n    return new Encoder({\n      canonical: true\n    })._encodeAll(objs);\n  }\n\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @param {any} obj The object to encode.\n   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.\n   * @returns {Buffer} The encoded objects.\n   * @static\n   */\n  static encodeOne(obj, options) {\n    return new Encoder(options)._encodeAll([obj]);\n  }\n\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this\n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj The object to encode.\n   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.\n   * @returns {Promise<Buffer>} A promise for the encoded buffer.\n   */\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      const bufs = [];\n      const enc = new Encoder(options);\n      enc.on('data', buf => bufs.push(buf));\n      enc.on('error', reject);\n      enc.on('finish', () => resolve(Buffer.concat(bufs)));\n      enc.pushAny(obj);\n      enc.end();\n    });\n  }\n\n  /**\n   * The currently supported set of semantic types.  May be modified by plugins.\n   *\n   * @type {SemanticMap}\n   */\n  static get SEMANTIC_TYPES() {\n    return current_SEMANTIC_TYPES;\n  }\n  static set SEMANTIC_TYPES(val) {\n    current_SEMANTIC_TYPES = val;\n  }\n\n  /**\n   * Reset the supported semantic types to the original set, before any\n   * plugins modified the list.\n   */\n  static reset() {\n    Encoder.SEMANTIC_TYPES = {\n      ...SEMANTIC_TYPES\n    };\n  }\n}\nObject.assign(SEMANTIC_TYPES, {\n  Array: Encoder.pushArray,\n  Date: Encoder._pushDate,\n  Buffer: Encoder._pushBuffer,\n  [Buffer.name]: Encoder._pushBuffer,\n  // Might be mangled\n  Map: Encoder._pushMap,\n  NoFilter: Encoder._pushNoFilter,\n  [NoFilter.name]: Encoder._pushNoFilter,\n  // Mßight be mangled\n  RegExp: Encoder._pushRegexp,\n  Set: Encoder._pushSet,\n  ArrayBuffer: Encoder._pushArrayBuffer,\n  Uint8ClampedArray: Encoder._pushTypedArray,\n  Uint8Array: Encoder._pushTypedArray,\n  Uint16Array: Encoder._pushTypedArray,\n  Uint32Array: Encoder._pushTypedArray,\n  Int8Array: Encoder._pushTypedArray,\n  Int16Array: Encoder._pushTypedArray,\n  Int32Array: Encoder._pushTypedArray,\n  Float32Array: Encoder._pushTypedArray,\n  Float64Array: Encoder._pushTypedArray,\n  URL: Encoder._pushURL,\n  Boolean: Encoder._pushBoxed,\n  Number: Encoder._pushBoxed,\n  String: Encoder._pushBoxed\n});\n\n// Safari needs to get better.\nif (typeof BigUint64Array !== 'undefined') {\n  SEMANTIC_TYPES[BigUint64Array.name] = Encoder._pushTypedArray;\n}\nif (typeof BigInt64Array !== 'undefined') {\n  SEMANTIC_TYPES[BigInt64Array.name] = Encoder._pushTypedArray;\n}\nEncoder.reset();\nmodule.exports = Encoder;","map":{"version":3,"names":["stream","require","NoFilter","utils","constants","MT","NUMBYTES","SHIFT32","SIMPLE","SYMS","TAG","BI","Buffer","HALF","SIMPLE_FLOAT","TWO","FLOAT","FOUR","DOUBLE","EIGHT","TRUE","FALSE","UNDEFINED","NULL","BREAK","from","BUF_NAN","BUF_INF_NEG","BUF_INF_POS","BUF_NEG_ZERO","SEMANTIC_TYPES","current_SEMANTIC_TYPES","parseDateType","str","toLowerCase","TypeError","Encoder","Transform","constructor","options","canonical","encodeUndefined","disallowUndefinedKeys","dateType","collapseBigIntegers","detectLoops","omitUndefinedProperties","genTypes","superOpts","readableObjectMode","writableObjectMode","undefined","WeakSet","semanticTypes","Array","isArray","i","len","length","addSemanticType","k","v","Object","entries","_transform","fresh","encoding","cb","ret","pushAny","Error","_flush","_pushUInt8","val","b","allocUnsafe","writeUInt8","push","_pushUInt16BE","writeUInt16BE","_pushUInt32BE","writeUInt32BE","_pushFloatBE","writeFloatBE","_pushDoubleBE","writeDoubleBE","_pushNaN","_pushInfinity","obj","half","_pushFloat","b2","writeHalf","Math","fround","_pushInt","mt","orig","m","ONE","max","Number","MAX_SAFE_INTEGER","NEG_INT","floor","_pushIntNum","is","POS_INT","_pushNumber","isNaN","isFinite","round","_pushString","byteLength","UTF8_STRING","_pushBoolean","_pushUndefined","buf","bufferishToBuffer","_pushNull","_pushTag","tag","_pushJSBigint","POS_BIGINT","MINUS_ONE","NEG_BIGINT","MAXINT64","toString","_pushBuffer","_pushObject","opts","indefinite","skipTypes","has","add","f","encodeCBOR","call","converter","name","keys","filter","tv","cbor_keys","sort","a","a_cbor","encode","b_cbor","compare","MAP","INDEFINITE","ck","j","len2","delete","_encodeAll","objs","bs","highWaterMark","readableHighWaterMark","pipe","o","end","read","type","fun","typeName","old","pushArray","gen","ARRAY","removeLoopDetectors","_pushDate","DATE_STRING","toISOString","DATE_EPOCH","getTime","BYTE_STRING","_pushNoFilter","slice","_pushRegexp","REGEXP","source","_pushSet","SET","size","x","_pushURL","URI","_pushBoxed","valueOf","_pushMap","enc","Boolean","_pushTypedArray","typ","sz","BYTES_PER_ELEMENT","startsWith","includes","isBigEndian","buffer","byteOffset","_pushArrayBuffer","encodeIndefinite","chunkSize","objType","offset","endIndex","Map","encodeCanonical","encodeOne","encodeAsync","Promise","resolve","reject","bufs","on","concat","reset","assign","Date","RegExp","Set","ArrayBuffer","Uint8ClampedArray","Uint8Array","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","Float64Array","URL","String","BigUint64Array","BigInt64Array","module","exports"],"sources":["/Users/peterchen/Dropbox/Hexlink/pwa-demo/node_modules/cbor/lib/encoder.js"],"sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst NoFilter = require('nofilter')\nconst utils = require('./utils')\nconst constants = require('./constants')\nconst {\n  MT, NUMBYTES, SHIFT32, SIMPLE, SYMS, TAG, BI,\n} = constants\nconst {Buffer} = require('buffer')\n\nconst HALF = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.TWO\nconst FLOAT = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.FOUR\nconst DOUBLE = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.EIGHT\nconst TRUE = (MT.SIMPLE_FLOAT << 5) | SIMPLE.TRUE\nconst FALSE = (MT.SIMPLE_FLOAT << 5) | SIMPLE.FALSE\nconst UNDEFINED = (MT.SIMPLE_FLOAT << 5) | SIMPLE.UNDEFINED\nconst NULL = (MT.SIMPLE_FLOAT << 5) | SIMPLE.NULL\n\nconst BREAK = Buffer.from([0xff])\nconst BUF_NAN = Buffer.from('f97e00', 'hex')\nconst BUF_INF_NEG = Buffer.from('f9fc00', 'hex')\nconst BUF_INF_POS = Buffer.from('f97c00', 'hex')\nconst BUF_NEG_ZERO = Buffer.from('f98000', 'hex')\n\n/**\n * Generate the CBOR for a value.  If you are using this, you'll either need\n * to call {@link Encoder.write} with a Buffer, or look into the internals of\n * Encoder to reuse existing non-documented behavior.\n *\n * @callback EncodeFunction\n * @param {Encoder} enc The encoder to use.\n * @param {any} val The value to encode.\n * @returns {boolean} True on success.\n */\n\n/* eslint-disable jsdoc/check-types */\n/**\n * A mapping from tag number to a tag decoding function.\n *\n * @typedef {Object.<string, EncodeFunction>} SemanticMap\n */\n/* eslint-enable jsdoc/check-types */\n\n/**\n * @type {SemanticMap}\n * @private\n */\nconst SEMANTIC_TYPES = {}\n\n/**\n * @type {SemanticMap}\n * @private\n */\nlet current_SEMANTIC_TYPES = {}\n\n/**\n * @param {string} str String to normalize.\n * @returns {\"number\"|\"float\"|\"int\"|\"string\"} Normalized.\n * @throws {TypeError} Invalid input.\n * @private\n */\nfunction parseDateType(str) {\n  if (!str) {\n    return 'number'\n  }\n  switch (str.toLowerCase()) {\n    case 'number':\n      return 'number'\n    case 'float':\n      return 'float'\n    case 'int':\n    case 'integer':\n      return 'int'\n    case 'string':\n      return 'string'\n  }\n  throw new TypeError(`dateType invalid, got \"${str}\"`)\n}\n\n/**\n * @typedef ObjectOptions\n * @property {boolean} [indefinite = false] Force indefinite encoding for this\n *   object.\n * @property {boolean} [skipTypes = false] Do not use available type mappings\n *   for this object, but encode it as a \"normal\" JS object would be.\n */\n\n/**\n * @typedef EncodingOptions\n * @property {any[]|object} [genTypes=[]] Array of pairs of\n *   `type`, `function(Encoder)` for semantic types to be encoded.  Not\n *   needed for Array, Date, Buffer, Map, RegExp, Set, or URL.\n *   If an object, the keys are the constructor names for the types.\n * @property {boolean} [canonical=false] Should the output be\n *   canonicalized.\n * @property {boolean|WeakSet} [detectLoops=false] Should object loops\n *   be detected?  This will currently add memory to track every part of the\n *   object being encoded in a WeakSet.  Do not encode\n *   the same object twice on the same encoder, without calling\n *   `removeLoopDetectors` in between, which will clear the WeakSet.\n *   You may pass in your own WeakSet to be used; this is useful in some\n *   recursive scenarios.\n * @property {(\"number\"|\"float\"|\"int\"|\"string\")} [dateType=\"number\"] -\n *   how should dates be encoded?  \"number\" means float or int, if no\n *   fractional seconds.\n * @property {any} [encodeUndefined=undefined] How should an\n *   \"undefined\" in the input be encoded.  By default, just encode a CBOR\n *   undefined.  If this is a buffer, use those bytes without re-encoding\n *   them.  If this is a function, the function will be called (which is a\n *   good time to throw an exception, if that's what you want), and the\n *   return value will be used according to these rules.  Anything else will\n *   be encoded as CBOR.\n * @property {boolean} [disallowUndefinedKeys=false] Should\n *   \"undefined\" be disallowed as a key in a Map that is serialized?  If\n *   this is true, encode(new Map([[undefined, 1]])) will throw an\n *   exception.  Note that it is impossible to get a key of undefined in a\n *   normal JS object.\n * @property {boolean} [collapseBigIntegers=false] Should integers\n *   that come in as ECMAscript bigint's be encoded\n *   as normal CBOR integers if they fit, discarding type information?\n * @property {number} [chunkSize=4096] Number of characters or bytes\n *   for each chunk, if obj is a string or Buffer, when indefinite encoding.\n * @property {boolean} [omitUndefinedProperties=false] When encoding\n *   objects or Maps, do not include a key if its corresponding value is\n *   `undefined`.\n */\n\n/**\n * Transform JavaScript values into CBOR bytes.  The `Writable` side of\n * the stream is in object mode.\n *\n * @extends stream.Transform\n */\nclass Encoder extends stream.Transform {\n  /**\n   * Creates an instance of Encoder.\n   *\n   * @param {EncodingOptions} [options={}] Options for the encoder.\n   */\n  constructor(options = {}) {\n    const {\n      canonical = false,\n      encodeUndefined,\n      disallowUndefinedKeys = false,\n      dateType = 'number',\n      collapseBigIntegers = false,\n      detectLoops = false,\n      omitUndefinedProperties = false,\n      genTypes = [],\n      ...superOpts\n    } = options\n\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: true,\n    })\n\n    this.canonical = canonical\n    this.encodeUndefined = encodeUndefined\n    this.disallowUndefinedKeys = disallowUndefinedKeys\n    this.dateType = parseDateType(dateType)\n    this.collapseBigIntegers = this.canonical ? true : collapseBigIntegers\n\n    /** @type {WeakSet?} */\n    this.detectLoops = undefined\n    if (typeof detectLoops === 'boolean') {\n      if (detectLoops) {\n        this.detectLoops = new WeakSet()\n      }\n    } else if (detectLoops instanceof WeakSet) {\n      this.detectLoops = detectLoops\n    } else {\n      throw new TypeError('detectLoops must be boolean or WeakSet')\n    }\n    this.omitUndefinedProperties = omitUndefinedProperties\n\n    this.semanticTypes = {...Encoder.SEMANTIC_TYPES}\n\n    if (Array.isArray(genTypes)) {\n      for (let i = 0, len = genTypes.length; i < len; i += 2) {\n        this.addSemanticType(genTypes[i], genTypes[i + 1])\n      }\n    } else {\n      for (const [k, v] of Object.entries(genTypes)) {\n        this.addSemanticType(k, v)\n      }\n    }\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, encoding, cb) {\n    const ret = this.pushAny(fresh)\n    // Old transformers might not return bool.  undefined !== false\n    cb((ret === false) ? new Error('Push Error') : undefined)\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  // eslint-disable-next-line class-methods-use-this\n  _flush(cb) {\n    cb()\n  }\n\n  /**\n   * @param {number} val Number(0-255) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt8(val) {\n    const b = Buffer.allocUnsafe(1)\n    b.writeUInt8(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @param {number} val Number(0-65535) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt16BE(val) {\n    const b = Buffer.allocUnsafe(2)\n    b.writeUInt16BE(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @param {number} val Number(0..2**32-1) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt32BE(val) {\n    const b = Buffer.allocUnsafe(4)\n    b.writeUInt32BE(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @param {number} val Number to encode as 4-byte float.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushFloatBE(val) {\n    const b = Buffer.allocUnsafe(4)\n    b.writeFloatBE(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @param {number} val Number to encode as 8-byte double.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushDoubleBE(val) {\n    const b = Buffer.allocUnsafe(8)\n    b.writeDoubleBE(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNaN() {\n    return this.push(BUF_NAN)\n  }\n\n  /**\n   * @param {number} obj Positive or negative infinity.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushInfinity(obj) {\n    const half = (obj < 0) ? BUF_INF_NEG : BUF_INF_POS\n    return this.push(half)\n  }\n\n  /**\n   * Choose the best float representation for a number and encode it.\n   *\n   * @param {number} obj A number that is known to be not-integer, but not\n   *   how many bytes of precision it needs.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushFloat(obj) {\n    if (this.canonical) {\n      // TODO: is this enough slower to hide behind canonical?\n      // It's certainly enough of a hack (see utils.parseHalf)\n\n      // From section 3.9:\n      // If a protocol allows for IEEE floats, then additional canonicalization\n      // rules might need to be added.  One example rule might be to have all\n      // floats start as a 64-bit float, then do a test conversion to a 32-bit\n      // float; if the result is the same numeric value, use the shorter value\n      // and repeat the process with a test conversion to a 16-bit float.  (This\n      // rule selects 16-bit float for positive and negative Infinity as well.)\n\n      // which seems pretty much backwards to me.\n      const b2 = Buffer.allocUnsafe(2)\n      if (utils.writeHalf(b2, obj)) {\n        // I have convinced myself that there are no cases where writeHalf\n        // will return true but `utils.parseHalf(b2) !== obj)`\n        return this._pushUInt8(HALF) && this.push(b2)\n      }\n    }\n    if (Math.fround(obj) === obj) {\n      return this._pushUInt8(FLOAT) && this._pushFloatBE(obj)\n    }\n\n    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj)\n  }\n\n  /**\n   * Choose the best integer representation for a postive number and encode\n   * it.  If the number is over MAX_SAFE_INTEGER, fall back on float (but I\n   * don't remember why).\n   *\n   * @param {number} obj A positive number that is known to be an integer,\n   *   but not how many bytes of precision it needs.\n   * @param {number} mt The Major Type number to combine with the integer.\n   *   Not yet shifted.\n   * @param {number} [orig] The number before it was transformed to positive.\n   *   If the mt is NEG_INT, and the positive number is over MAX_SAFE_INT,\n   *   then we'll encode this as a float rather than making the number\n   *   negative again and losing precision.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushInt(obj, mt, orig) {\n    const m = mt << 5\n\n    if (obj < 24) {\n      return this._pushUInt8(m | obj)\n    }\n    if (obj <= 0xff) {\n      return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj)\n    }\n    if (obj <= 0xffff) {\n      return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj)\n    }\n    if (obj <= 0xffffffff) {\n      return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj)\n    }\n    let max = Number.MAX_SAFE_INTEGER\n    if (mt === MT.NEG_INT) {\n      // Special case for Number.MIN_SAFE_INTEGER - 1\n      max--\n    }\n    if (obj <= max) {\n      return this._pushUInt8(m | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(Math.floor(obj / SHIFT32)) &&\n        this._pushUInt32BE(obj % SHIFT32)\n    }\n    if (mt === MT.NEG_INT) {\n      return this._pushFloat(orig)\n    }\n    return this._pushFloat(obj)\n  }\n\n  /**\n   * Choose the best integer representation for a number and encode it.\n   *\n   * @param {number} obj A number that is known to be an integer,\n   *   but not how many bytes of precision it needs.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushIntNum(obj) {\n    if (Object.is(obj, -0)) {\n      return this.push(BUF_NEG_ZERO)\n    }\n\n    if (obj < 0) {\n      return this._pushInt(-obj - 1, MT.NEG_INT, obj)\n    }\n    return this._pushInt(obj, MT.POS_INT)\n  }\n\n  /**\n   * @param {number} obj Plain JS number to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNumber(obj) {\n    if (isNaN(obj)) {\n      return this._pushNaN()\n    }\n    if (!isFinite(obj)) {\n      return this._pushInfinity(obj)\n    }\n    if (Math.round(obj) === obj) {\n      return this._pushIntNum(obj)\n    }\n    return this._pushFloat(obj)\n  }\n\n  /**\n   * @param {string} obj String to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushString(obj) {\n    const len = Buffer.byteLength(obj, 'utf8')\n    return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8')\n  }\n\n  /**\n   * @param {boolean} obj Bool to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushBoolean(obj) {\n    return this._pushUInt8(obj ? TRUE : FALSE)\n  }\n\n  /**\n   * @param {undefined} obj Ignored.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUndefined(obj) {\n    switch (typeof this.encodeUndefined) {\n      case 'undefined':\n        return this._pushUInt8(UNDEFINED)\n      case 'function':\n        return this.pushAny(this.encodeUndefined(obj))\n      case 'object': {\n        const buf = utils.bufferishToBuffer(this.encodeUndefined)\n        if (buf) {\n          return this.push(buf)\n        }\n      }\n    }\n    return this.pushAny(this.encodeUndefined)\n  }\n\n  /**\n   * @param {null} obj Ignored.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNull(obj) {\n    return this._pushUInt8(NULL)\n  }\n\n  /**\n   * @param {number} tag Tag number to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushTag(tag) {\n    return this._pushInt(tag, MT.TAG)\n  }\n\n  /**\n   * @param {bigint} obj BigInt to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushJSBigint(obj) {\n    let m = MT.POS_INT\n    let tag = TAG.POS_BIGINT\n    // BigInt doesn't have -0\n    if (obj < 0) {\n      obj = -obj + BI.MINUS_ONE\n      m = MT.NEG_INT\n      tag = TAG.NEG_BIGINT\n    }\n\n    if (this.collapseBigIntegers &&\n        (obj <= BI.MAXINT64)) {\n      // Special handiling for 64bits\n      if (obj <= 0xffffffff) {\n        return this._pushInt(Number(obj), m)\n      }\n      return this._pushUInt8((m << 5) | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(Number(obj / BI.SHIFT32)) &&\n        this._pushUInt32BE(Number(obj % BI.SHIFT32))\n    }\n\n    let str = obj.toString(16)\n    if (str.length % 2) {\n      str = `0${str}`\n    }\n    const buf = Buffer.from(str, 'hex')\n    return this._pushTag(tag) && Encoder._pushBuffer(this, buf)\n  }\n\n  /**\n   * @param {object} obj Object to encode.\n   * @param {ObjectOptions} [opts] Options for encoding this object.\n   * @returns {boolean} True on success.\n   * @throws {Error} Loop detected.\n   * @ignore\n   */\n  _pushObject(obj, opts) {\n    if (!obj) {\n      return this._pushNull(obj)\n    }\n    opts = {\n      indefinite: false,\n      skipTypes: false,\n      ...opts,\n    }\n    if (!opts.indefinite) {\n      // This will only happen the first time through for indefinite encoding\n      if (this.detectLoops) {\n        if (this.detectLoops.has(obj)) {\n          throw new Error(`\\\nLoop detected while CBOR encoding.\nCall removeLoopDetectors before resuming.`)\n        } else {\n          this.detectLoops.add(obj)\n        }\n      }\n    }\n    if (!opts.skipTypes) {\n      const f = obj.encodeCBOR\n      if (typeof f === 'function') {\n        return f.call(obj, this)\n      }\n      const converter = this.semanticTypes[obj.constructor.name]\n      if (converter) {\n        return converter.call(obj, this, obj)\n      }\n    }\n    const keys = Object.keys(obj).filter(k => {\n      const tv = typeof obj[k]\n      return (tv !== 'function') &&\n        (!this.omitUndefinedProperties || (tv !== 'undefined'))\n    })\n    const cbor_keys = {}\n    if (this.canonical) {\n      // Note: this can't be a normal sort, because 'b' needs to sort before\n      // 'aa'\n      keys.sort((a, b) => {\n        // Always strings, so don't bother to pass options.\n        // hold on to the cbor versions, since there's no need\n        // to encode more than once\n        const a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a))\n        const b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b))\n\n        return a_cbor.compare(b_cbor)\n      })\n    }\n    if (opts.indefinite) {\n      if (!this._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {\n        return false\n      }\n    } else if (!this._pushInt(keys.length, MT.MAP)) {\n      return false\n    }\n    let ck = null\n    for (let j = 0, len2 = keys.length; j < len2; j++) {\n      const k = keys[j]\n      if (this.canonical && ((ck = cbor_keys[k]))) {\n        if (!this.push(ck)) { // Already a Buffer\n          return false\n        }\n      } else if (!this._pushString(k)) {\n        return false\n      }\n      if (!this.pushAny(obj[k])) {\n        return false\n      }\n    }\n    if (opts.indefinite) {\n      if (!this.push(BREAK)) {\n        return false\n      }\n    } else if (this.detectLoops) {\n      this.detectLoops.delete(obj)\n    }\n    return true\n  }\n\n  /**\n   * @param {any[]} objs Array of supported things.\n   * @returns {Buffer} Concatenation of encodings for the supported things.\n   * @ignore\n   */\n  _encodeAll(objs) {\n    const bs = new NoFilter({highWaterMark: this.readableHighWaterMark})\n    this.pipe(bs)\n    for (const o of objs) {\n      this.pushAny(o)\n    }\n    this.end()\n    return bs.read()\n  }\n\n  /**\n   * Add an encoding function to the list of supported semantic types.  This\n   * is useful for objects for which you can't add an encodeCBOR method.\n   *\n   * @param {string|Function} type The type to encode.\n   * @param {EncodeFunction} fun The encoder to use.\n   * @returns {EncodeFunction?} The previous encoder or undefined if there\n   *   wasn't one.\n   * @throws {TypeError} Invalid function.\n   */\n  addSemanticType(type, fun) {\n    const typeName = (typeof type === 'string') ? type : type.name\n    const old = this.semanticTypes[typeName]\n\n    if (fun) {\n      if (typeof fun !== 'function') {\n        throw new TypeError('fun must be of type function')\n      }\n      this.semanticTypes[typeName] = fun\n    } else if (old) {\n      delete this.semanticTypes[typeName]\n    }\n    return old\n  }\n\n  /**\n   * Push any supported type onto the encoded stream.\n   *\n   * @param {any} obj The thing to encode.\n   * @returns {boolean} True on success.\n   * @throws {TypeError} Unknown type for obj.\n   */\n  pushAny(obj) {\n    switch (typeof obj) {\n      case 'number':\n        return this._pushNumber(obj)\n      case 'bigint':\n        return this._pushJSBigint(obj)\n      case 'string':\n        return this._pushString(obj)\n      case 'boolean':\n        return this._pushBoolean(obj)\n      case 'undefined':\n        return this._pushUndefined(obj)\n      case 'object':\n        return this._pushObject(obj)\n      case 'symbol':\n        switch (obj) {\n          case SYMS.NULL:\n            return this._pushNull(null)\n          case SYMS.UNDEFINED:\n            return this._pushUndefined(undefined)\n          // TODO: Add pluggable support for other symbols\n          default:\n            throw new TypeError(`Unknown symbol: ${obj.toString()}`)\n        }\n      default:\n        throw new TypeError(\n          `Unknown type: ${typeof obj}, ${(typeof obj.toString === 'function') ? obj.toString() : ''}`\n        )\n    }\n  }\n\n  /**\n   * Encode an array and all of its elements.\n   *\n   * @param {Encoder} gen Encoder to use.\n   * @param {any[]} obj Array to encode.\n   * @param {object} [opts] Options.\n   * @param {boolean} [opts.indefinite=false] Use indefinite encoding?\n   * @returns {boolean} True on success.\n   */\n  static pushArray(gen, obj, opts) {\n    opts = {\n      indefinite: false,\n      ...opts,\n    }\n    const len = obj.length\n    if (opts.indefinite) {\n      if (!gen._pushUInt8((MT.ARRAY << 5) | NUMBYTES.INDEFINITE)) {\n        return false\n      }\n    } else if (!gen._pushInt(len, MT.ARRAY)) {\n      return false\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen.pushAny(obj[j])) {\n        return false\n      }\n    }\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * Remove the loop detector WeakSet for this Encoder.\n   *\n   * @returns {boolean} True when the Encoder was reset, else false.\n   */\n  removeLoopDetectors() {\n    if (!this.detectLoops) {\n      return false\n    }\n    this.detectLoops = new WeakSet()\n    return true\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Date} obj Date to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushDate(gen, obj) {\n    switch (gen.dateType) {\n      case 'string':\n        return gen._pushTag(TAG.DATE_STRING) &&\n          gen._pushString(obj.toISOString())\n      case 'int':\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen._pushIntNum(Math.round(obj.getTime() / 1000))\n      case 'float':\n        // Force float\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen._pushFloat(obj.getTime() / 1000)\n      case 'number':\n      default:\n        // If we happen to have an integral number of seconds,\n        // use integer.  Otherwise, use float.\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen.pushAny(obj.getTime() / 1000)\n    }\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Buffer} obj Buffer to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushBuffer(gen, obj) {\n    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj)\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {NoFilter} obj Buffer to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushNoFilter(gen, obj) {\n    return Encoder._pushBuffer(gen, /** @type {Buffer} */ (obj.slice()))\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {RegExp} obj RegExp to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushRegexp(gen, obj) {\n    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source)\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Set} obj Set to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushSet(gen, obj) {\n    if (!gen._pushTag(TAG.SET)) {\n      return false\n    }\n    if (!gen._pushInt(obj.size, MT.ARRAY)) {\n      return false\n    }\n    for (const x of obj) {\n      if (!gen.pushAny(x)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {URL} obj URL to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushURL(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString())\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {object} obj Boxed String, Number, or Boolean object to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushBoxed(gen, obj) {\n    return gen.pushAny(obj.valueOf())\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Map} obj Map to encode.\n   * @returns {boolean} True on success.\n   * @throws {Error} Map key that is undefined.\n   * @ignore\n   */\n  static _pushMap(gen, obj, opts) {\n    opts = {\n      indefinite: false,\n      ...opts,\n    }\n    let entries = [...obj.entries()]\n    if (gen.omitUndefinedProperties) {\n      entries = entries.filter(([k, v]) => v !== undefined)\n    }\n    if (opts.indefinite) {\n      if (!gen._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {\n        return false\n      }\n    } else if (!gen._pushInt(entries.length, MT.MAP)) {\n      return false\n    }\n    // Memoizing the cbor only helps in certain cases, and hurts in most\n    // others.  Just avoid it.\n    if (gen.canonical) {\n      // Keep the key/value pairs together, so we don't have to do odd\n      // gets with object keys later\n      const enc = new Encoder({\n        genTypes: gen.semanticTypes,\n        canonical: gen.canonical,\n        detectLoops: Boolean(gen.detectLoops), // Give enc its own loop detector\n        dateType: gen.dateType,\n        disallowUndefinedKeys: gen.disallowUndefinedKeys,\n        collapseBigIntegers: gen.collapseBigIntegers,\n      })\n      const bs = new NoFilter({highWaterMark: gen.readableHighWaterMark})\n      enc.pipe(bs)\n      entries.sort(([a], [b]) => {\n        // Both a and b are the keys\n        enc.pushAny(a)\n        const a_cbor = bs.read()\n        enc.pushAny(b)\n        const b_cbor = bs.read()\n        return a_cbor.compare(b_cbor)\n      })\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {\n          throw new Error('Invalid Map key: undefined')\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false\n        }\n      }\n    } else {\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {\n          throw new Error('Invalid Map key: undefined')\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false\n        }\n      }\n    }\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {NodeJS.TypedArray} obj Array to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushTypedArray(gen, obj) {\n    // See https://tools.ietf.org/html/rfc8746\n\n    let typ = 0b01000000\n    let sz = obj.BYTES_PER_ELEMENT\n    const {name} = obj.constructor\n\n    if (name.startsWith('Float')) {\n      typ |= 0b00010000\n      sz /= 2\n    } else if (!name.includes('U')) {\n      typ |= 0b00001000\n    }\n    if (name.includes('Clamped') || ((sz !== 1) && !utils.isBigEndian())) {\n      typ |= 0b00000100\n    }\n    typ |= {\n      1: 0b00,\n      2: 0b01,\n      4: 0b10,\n      8: 0b11,\n    }[sz]\n    if (!gen._pushTag(typ)) {\n      return false\n    }\n    return Encoder._pushBuffer(\n      gen,\n      Buffer.from(obj.buffer, obj.byteOffset, obj.byteLength)\n    )\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param { ArrayBuffer } obj Array to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushArrayBuffer(gen, obj) {\n    return Encoder._pushBuffer(gen, Buffer.from(obj))\n  }\n\n  /**\n   * Encode the given object with indefinite length.  There are apparently\n   * some (IMO) broken implementations of poorly-specified protocols that\n   * REQUIRE indefinite-encoding.  See the example for how to add this as an\n   * `encodeCBOR` function to an object or class to get indefinite encoding.\n   *\n   * @param {Encoder} gen The encoder to use.\n   * @param {string|Buffer|Array|Map|object} [obj] The object to encode.  If\n   *   null, use \"this\" instead.\n   * @param {EncodingOptions} [options={}] Options for encoding.\n   * @returns {boolean} True on success.\n   * @throws {Error} No object to encode or invalid indefinite encoding.\n   * @example <caption>Force indefinite encoding:</caption>\n   * const o = {\n   *   a: true,\n   *   encodeCBOR: cbor.Encoder.encodeIndefinite,\n   * }\n   * const m = []\n   * m.encodeCBOR = cbor.Encoder.encodeIndefinite\n   * cbor.encodeOne([o, m])\n   */\n  static encodeIndefinite(gen, obj, options = {}) {\n    if (obj == null) {\n      if (this == null) {\n        throw new Error('No object to encode')\n      }\n      obj = this\n    }\n\n    // TODO: consider other options\n    const {chunkSize = 4096} = options\n\n    let ret = true\n    const objType = typeof obj\n    let buf = null\n    if (objType === 'string') {\n      // TODO: make sure not to split surrogate pairs at the edges of chunks,\n      // since such half-surrogates cannot be legally encoded as UTF-8.\n      ret = ret && gen._pushUInt8((MT.UTF8_STRING << 5) | NUMBYTES.INDEFINITE)\n      let offset = 0\n      while (offset < obj.length) {\n        const endIndex = offset + chunkSize\n        ret = ret && gen._pushString(obj.slice(offset, endIndex))\n        offset = endIndex\n      }\n      ret = ret && gen.push(BREAK)\n    } else if ((buf = utils.bufferishToBuffer(obj))) {\n      ret = ret && gen._pushUInt8((MT.BYTE_STRING << 5) | NUMBYTES.INDEFINITE)\n      let offset = 0\n      while (offset < buf.length) {\n        const endIndex = offset + chunkSize\n        ret = ret && Encoder._pushBuffer(gen, buf.slice(offset, endIndex))\n        offset = endIndex\n      }\n      ret = ret && gen.push(BREAK)\n    } else if (Array.isArray(obj)) {\n      ret = ret && Encoder.pushArray(gen, obj, {\n        indefinite: true,\n      })\n    } else if (obj instanceof Map) {\n      ret = ret && Encoder._pushMap(gen, obj, {\n        indefinite: true,\n      })\n    } else {\n      if (objType !== 'object') {\n        throw new Error('Invalid indefinite encoding')\n      }\n      ret = ret && gen._pushObject(obj, {\n        indefinite: true,\n        skipTypes: true,\n      })\n    }\n    return ret\n  }\n\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encode(...objs) {\n    return new Encoder()._encodeAll(objs)\n  }\n\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encodeCanonical(...objs) {\n    return new Encoder({\n      canonical: true,\n    })._encodeAll(objs)\n  }\n\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @param {any} obj The object to encode.\n   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.\n   * @returns {Buffer} The encoded objects.\n   * @static\n   */\n  static encodeOne(obj, options) {\n    return new Encoder(options)._encodeAll([obj])\n  }\n\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this\n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj The object to encode.\n   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.\n   * @returns {Promise<Buffer>} A promise for the encoded buffer.\n   */\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      const bufs = []\n      const enc = new Encoder(options)\n      enc.on('data', buf => bufs.push(buf))\n      enc.on('error', reject)\n      enc.on('finish', () => resolve(Buffer.concat(bufs)))\n      enc.pushAny(obj)\n      enc.end()\n    })\n  }\n\n  /**\n   * The currently supported set of semantic types.  May be modified by plugins.\n   *\n   * @type {SemanticMap}\n   */\n  static get SEMANTIC_TYPES() {\n    return current_SEMANTIC_TYPES\n  }\n\n  static set SEMANTIC_TYPES(val) {\n    current_SEMANTIC_TYPES = val\n  }\n\n  /**\n   * Reset the supported semantic types to the original set, before any\n   * plugins modified the list.\n   */\n  static reset() {\n    Encoder.SEMANTIC_TYPES = {...SEMANTIC_TYPES}\n  }\n}\n\nObject.assign(SEMANTIC_TYPES, {\n  Array: Encoder.pushArray,\n  Date: Encoder._pushDate,\n  Buffer: Encoder._pushBuffer,\n  [Buffer.name]: Encoder._pushBuffer, // Might be mangled\n  Map: Encoder._pushMap,\n  NoFilter: Encoder._pushNoFilter,\n  [NoFilter.name]: Encoder._pushNoFilter, // Mßight be mangled\n  RegExp: Encoder._pushRegexp,\n  Set: Encoder._pushSet,\n  ArrayBuffer: Encoder._pushArrayBuffer,\n  Uint8ClampedArray: Encoder._pushTypedArray,\n  Uint8Array: Encoder._pushTypedArray,\n  Uint16Array: Encoder._pushTypedArray,\n  Uint32Array: Encoder._pushTypedArray,\n  Int8Array: Encoder._pushTypedArray,\n  Int16Array: Encoder._pushTypedArray,\n  Int32Array: Encoder._pushTypedArray,\n  Float32Array: Encoder._pushTypedArray,\n  Float64Array: Encoder._pushTypedArray,\n  URL: Encoder._pushURL,\n  Boolean: Encoder._pushBoxed,\n  Number: Encoder._pushBoxed,\n  String: Encoder._pushBoxed,\n})\n\n// Safari needs to get better.\nif (typeof BigUint64Array !== 'undefined') {\n  SEMANTIC_TYPES[BigUint64Array.name] = Encoder._pushTypedArray\n}\nif (typeof BigInt64Array !== 'undefined') {\n  SEMANTIC_TYPES[BigInt64Array.name] = Encoder._pushTypedArray\n}\n\nEncoder.reset()\nmodule.exports = Encoder\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}