{"ast":null,"code":"// Tweaked version of nathan7's binary-parse-stream\n// (see https://github.com/nathan7/binary-parse-stream)\n// Uses NoFilter instead of the readable in the original.  Removes\n// the ability to read -1, which was odd and un-needed.\n// License for binary-parse-stream: MIT\n\n// binary-parse-stream is now unmaintained, so I have rewritten it as\n// more modern JS so I can get tsc to help check types.\n\n'use strict';\n\nconst stream = require('stream');\nconst NoFilter = require('nofilter');\n\n/**\n * BinaryParseStream is a TransformStream that consumes buffers and outputs\n * objects on the other end.  It expects your subclass to implement a `_parse`\n * method that is a generator.  When your generator yields a number, it'll be\n * fed a buffer of that length from the input.  When your generator returns,\n * the return value will be pushed to the output side.\n *\n * @extends stream.Transform\n */\nclass BinaryParseStream extends stream.Transform {\n  /**\n   * Creates an instance of BinaryParseStream.\n   *\n   * @memberof BinaryParseStream\n   * @param {stream.TransformOptions} options Stream options.\n   */\n  constructor(options) {\n    super(options);\n    // Doesn't work to pass these in as opts, for some reason\n    // also, work around typescript not knowing TransformStream internals\n    // eslint-disable-next-line dot-notation\n    this['_writableState'].objectMode = false;\n    // eslint-disable-next-line dot-notation\n    this['_readableState'].objectMode = true;\n    this.bs = new NoFilter();\n    this.__restart();\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, encoding, cb) {\n    this.bs.write(fresh);\n    while (this.bs.length >= this.__needed) {\n      let ret = null;\n      const chunk = this.__needed === null ? undefined : this.bs.read(this.__needed);\n      try {\n        ret = this.__parser.next(chunk);\n      } catch (e) {\n        return cb(e);\n      }\n      if (this.__needed) {\n        this.__fresh = false;\n      }\n      if (ret.done) {\n        this.push(ret.value);\n        this.__restart();\n      } else {\n        this.__needed = ret.value || Infinity;\n      }\n    }\n    return cb();\n  }\n\n  /**\n   * Subclasses must override this to set their parsing behavior.  Yield a\n   * number to receive a Buffer of that many bytes.\n   *\n   * @abstract\n   * @returns {Generator<number, any, Buffer>}\n   */\n  /* istanbul ignore next */\n  *_parse() {\n    // eslint-disable-line class-methods-use-this, require-yield\n    throw new Error('Must be implemented in subclass');\n  }\n  __restart() {\n    this.__needed = null;\n    this.__parser = this._parse();\n    this.__fresh = true;\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _flush(cb) {\n    cb(this.__fresh ? null : new Error('unexpected end of input'));\n  }\n}\nmodule.exports = BinaryParseStream;","map":{"version":3,"names":["stream","require","NoFilter","BinaryParseStream","Transform","constructor","options","objectMode","bs","__restart","_transform","fresh","encoding","cb","write","length","__needed","ret","chunk","undefined","read","__parser","next","e","__fresh","done","push","value","Infinity","_parse","Error","_flush","module","exports"],"sources":["/Users/peterchen/Dropbox/Hexlink/pwa-demo/node_modules/cbor/vendor/binary-parse-stream/index.js"],"sourcesContent":["// Tweaked version of nathan7's binary-parse-stream\n// (see https://github.com/nathan7/binary-parse-stream)\n// Uses NoFilter instead of the readable in the original.  Removes\n// the ability to read -1, which was odd and un-needed.\n// License for binary-parse-stream: MIT\n\n// binary-parse-stream is now unmaintained, so I have rewritten it as\n// more modern JS so I can get tsc to help check types.\n\n'use strict'\nconst stream = require('stream')\nconst NoFilter = require('nofilter')\n\n/**\n * BinaryParseStream is a TransformStream that consumes buffers and outputs\n * objects on the other end.  It expects your subclass to implement a `_parse`\n * method that is a generator.  When your generator yields a number, it'll be\n * fed a buffer of that length from the input.  When your generator returns,\n * the return value will be pushed to the output side.\n *\n * @extends stream.Transform\n */\nclass BinaryParseStream extends stream.Transform {\n  /**\n   * Creates an instance of BinaryParseStream.\n   *\n   * @memberof BinaryParseStream\n   * @param {stream.TransformOptions} options Stream options.\n   */\n  constructor(options) {\n    super(options)\n    // Doesn't work to pass these in as opts, for some reason\n    // also, work around typescript not knowing TransformStream internals\n    // eslint-disable-next-line dot-notation\n    this['_writableState'].objectMode = false\n    // eslint-disable-next-line dot-notation\n    this['_readableState'].objectMode = true\n\n    this.bs = new NoFilter()\n    this.__restart()\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, encoding, cb) {\n    this.bs.write(fresh)\n\n    while (this.bs.length >= this.__needed) {\n      let ret = null\n      const chunk = (this.__needed === null) ?\n        undefined :\n        this.bs.read(this.__needed)\n\n      try {\n        ret = this.__parser.next(chunk)\n      } catch (e) {\n        return cb(e)\n      }\n\n      if (this.__needed) {\n        this.__fresh = false\n      }\n\n      if (ret.done) {\n        this.push(ret.value)\n        this.__restart()\n      } else {\n        this.__needed = ret.value || Infinity\n      }\n    }\n\n    return cb()\n  }\n\n  /**\n   * Subclasses must override this to set their parsing behavior.  Yield a\n   * number to receive a Buffer of that many bytes.\n   *\n   * @abstract\n   * @returns {Generator<number, any, Buffer>}\n   */\n  /* istanbul ignore next */\n  *_parse() { // eslint-disable-line class-methods-use-this, require-yield\n    throw new Error('Must be implemented in subclass')\n  }\n\n  __restart() {\n    this.__needed = null\n    this.__parser = this._parse()\n    this.__fresh = true\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _flush(cb) {\n    cb(this.__fresh ? null : new Error('unexpected end of input'))\n  }\n}\n\nmodule.exports = BinaryParseStream\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,YAAY;;AACZ,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMC,QAAQ,GAAGD,OAAO,CAAC,UAAU,CAAC;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,iBAAiB,SAASH,MAAM,CAACI,SAAS,CAAC;EAC/C;AACF;AACA;AACA;AACA;AACA;EACEC,WAAWA,CAACC,OAAO,EAAE;IACnB,KAAK,CAACA,OAAO,CAAC;IACd;IACA;IACA;IACA,IAAI,CAAC,gBAAgB,CAAC,CAACC,UAAU,GAAG,KAAK;IACzC;IACA,IAAI,CAAC,gBAAgB,CAAC,CAACA,UAAU,GAAG,IAAI;IAExC,IAAI,CAACC,EAAE,GAAG,IAAIN,QAAQ,CAAC,CAAC;IACxB,IAAI,CAACO,SAAS,CAAC,CAAC;EAClB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,UAAUA,CAACC,KAAK,EAAEC,QAAQ,EAAEC,EAAE,EAAE;IAC9B,IAAI,CAACL,EAAE,CAACM,KAAK,CAACH,KAAK,CAAC;IAEpB,OAAO,IAAI,CAACH,EAAE,CAACO,MAAM,IAAI,IAAI,CAACC,QAAQ,EAAE;MACtC,IAAIC,GAAG,GAAG,IAAI;MACd,MAAMC,KAAK,GAAI,IAAI,CAACF,QAAQ,KAAK,IAAI,GACnCG,SAAS,GACT,IAAI,CAACX,EAAE,CAACY,IAAI,CAAC,IAAI,CAACJ,QAAQ,CAAC;MAE7B,IAAI;QACFC,GAAG,GAAG,IAAI,CAACI,QAAQ,CAACC,IAAI,CAACJ,KAAK,CAAC;MACjC,CAAC,CAAC,OAAOK,CAAC,EAAE;QACV,OAAOV,EAAE,CAACU,CAAC,CAAC;MACd;MAEA,IAAI,IAAI,CAACP,QAAQ,EAAE;QACjB,IAAI,CAACQ,OAAO,GAAG,KAAK;MACtB;MAEA,IAAIP,GAAG,CAACQ,IAAI,EAAE;QACZ,IAAI,CAACC,IAAI,CAACT,GAAG,CAACU,KAAK,CAAC;QACpB,IAAI,CAAClB,SAAS,CAAC,CAAC;MAClB,CAAC,MAAM;QACL,IAAI,CAACO,QAAQ,GAAGC,GAAG,CAACU,KAAK,IAAIC,QAAQ;MACvC;IACF;IAEA,OAAOf,EAAE,CAAC,CAAC;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE;EACA,CAACgB,MAAMA,CAAA,EAAG;IAAE;IACV,MAAM,IAAIC,KAAK,CAAC,iCAAiC,CAAC;EACpD;EAEArB,SAASA,CAAA,EAAG;IACV,IAAI,CAACO,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACK,QAAQ,GAAG,IAAI,CAACQ,MAAM,CAAC,CAAC;IAC7B,IAAI,CAACL,OAAO,GAAG,IAAI;EACrB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEO,MAAMA,CAAClB,EAAE,EAAE;IACTA,EAAE,CAAC,IAAI,CAACW,OAAO,GAAG,IAAI,GAAG,IAAIM,KAAK,CAAC,yBAAyB,CAAC,CAAC;EAChE;AACF;AAEAE,MAAM,CAACC,OAAO,GAAG9B,iBAAiB"},"metadata":{},"sourceType":"script","externalDependencies":[]}