{"ast":null,"code":"'use strict';\n\nconst {\n  MT,\n  SIMPLE,\n  SYMS\n} = require('./constants');\n\n/**\n * A CBOR Simple Value that does not map onto a known constant.\n */\nclass Simple {\n  /**\n   * Creates an instance of Simple.\n   *\n   * @param {number} value The simple value's integer value.\n   */\n  constructor(value) {\n    if (typeof value !== 'number') {\n      throw new Error(`Invalid Simple type: ${typeof value}`);\n    }\n    if (value < 0 || value > 255 || (value | 0) !== value) {\n      throw new Error(`value must be a small positive integer: ${value}`);\n    }\n    this.value = value;\n  }\n\n  /**\n   * Debug string for simple value.\n   *\n   * @returns {string} Formated string of `simple(value)`.\n   */\n  toString() {\n    return `simple(${this.value})`;\n  }\n\n  /**\n   * Debug string for simple value.\n   *\n   * @param {number} depth How deep are we?\n   * @param {object} opts Options.\n   * @returns {string} Formatted string of `simple(value)`.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, opts) {\n    return `simple(${this.value})`;\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    return gen._pushInt(this.value, MT.SIMPLE_FLOAT);\n  }\n\n  /**\n   * Is the given object a Simple?\n   *\n   * @param {any} obj Object to test.\n   * @returns {boolean} Is it Simple?\n   */\n  static isSimple(obj) {\n    return obj instanceof Simple;\n  }\n\n  /**\n   * Decode from the CBOR additional information into a JavaScript value.\n   * If the CBOR item has no parent, return a \"safe\" symbol instead of\n   * `null` or `undefined`, so that the value can be passed through a\n   * stream in object mode.\n   *\n   * @param {number} val The CBOR additional info to convert.\n   * @param {boolean} [has_parent=true] Does the CBOR item have a parent?\n   * @param {boolean} [parent_indefinite=false] Is the parent element\n   *   indefinitely encoded?\n   * @returns {(null|undefined|boolean|symbol|Simple)} The decoded value.\n   * @throws {Error} Invalid BREAK.\n   */\n  static decode(val, has_parent = true, parent_indefinite = false) {\n    switch (val) {\n      case SIMPLE.FALSE:\n        return false;\n      case SIMPLE.TRUE:\n        return true;\n      case SIMPLE.NULL:\n        if (has_parent) {\n          return null;\n        }\n        return SYMS.NULL;\n      case SIMPLE.UNDEFINED:\n        if (has_parent) {\n          return undefined;\n        }\n        return SYMS.UNDEFINED;\n      case -1:\n        if (!has_parent || !parent_indefinite) {\n          throw new Error('Invalid BREAK');\n        }\n        return SYMS.BREAK;\n      default:\n        return new Simple(val);\n    }\n  }\n}\nmodule.exports = Simple;","map":{"version":3,"names":["MT","SIMPLE","SYMS","require","Simple","constructor","value","Error","toString","Symbol","for","depth","opts","encodeCBOR","gen","_pushInt","SIMPLE_FLOAT","isSimple","obj","decode","val","has_parent","parent_indefinite","FALSE","TRUE","NULL","UNDEFINED","undefined","BREAK","module","exports"],"sources":["/Users/peterchen/Dropbox/Hexlink/pwa-demo/node_modules/cbor/lib/simple.js"],"sourcesContent":["'use strict'\n\nconst {MT, SIMPLE, SYMS} = require('./constants')\n\n/**\n * A CBOR Simple Value that does not map onto a known constant.\n */\nclass Simple {\n  /**\n   * Creates an instance of Simple.\n   *\n   * @param {number} value The simple value's integer value.\n   */\n  constructor(value) {\n    if (typeof value !== 'number') {\n      throw new Error(`Invalid Simple type: ${typeof value}`)\n    }\n    if ((value < 0) || (value > 255) || ((value | 0) !== value)) {\n      throw new Error(`value must be a small positive integer: ${value}`)\n    }\n    this.value = value\n  }\n\n  /**\n   * Debug string for simple value.\n   *\n   * @returns {string} Formated string of `simple(value)`.\n   */\n  toString() {\n    return `simple(${this.value})`\n  }\n\n  /**\n   * Debug string for simple value.\n   *\n   * @param {number} depth How deep are we?\n   * @param {object} opts Options.\n   * @returns {string} Formatted string of `simple(value)`.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, opts) {\n    return `simple(${this.value})`\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    return gen._pushInt(this.value, MT.SIMPLE_FLOAT)\n  }\n\n  /**\n   * Is the given object a Simple?\n   *\n   * @param {any} obj Object to test.\n   * @returns {boolean} Is it Simple?\n   */\n  static isSimple(obj) {\n    return obj instanceof Simple\n  }\n\n  /**\n   * Decode from the CBOR additional information into a JavaScript value.\n   * If the CBOR item has no parent, return a \"safe\" symbol instead of\n   * `null` or `undefined`, so that the value can be passed through a\n   * stream in object mode.\n   *\n   * @param {number} val The CBOR additional info to convert.\n   * @param {boolean} [has_parent=true] Does the CBOR item have a parent?\n   * @param {boolean} [parent_indefinite=false] Is the parent element\n   *   indefinitely encoded?\n   * @returns {(null|undefined|boolean|symbol|Simple)} The decoded value.\n   * @throws {Error} Invalid BREAK.\n   */\n  static decode(val, has_parent = true, parent_indefinite = false) {\n    switch (val) {\n      case SIMPLE.FALSE:\n        return false\n      case SIMPLE.TRUE:\n        return true\n      case SIMPLE.NULL:\n        if (has_parent) {\n          return null\n        }\n        return SYMS.NULL\n      case SIMPLE.UNDEFINED:\n        if (has_parent) {\n          return undefined\n        }\n        return SYMS.UNDEFINED\n      case -1:\n        if (!has_parent || !parent_indefinite) {\n          throw new Error('Invalid BREAK')\n        }\n        return SYMS.BREAK\n      default:\n        return new Simple(val)\n    }\n  }\n}\n\nmodule.exports = Simple\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAM;EAACA,EAAE;EAAEC,MAAM;EAAEC;AAAI,CAAC,GAAGC,OAAO,CAAC,aAAa,CAAC;;AAEjD;AACA;AACA;AACA,MAAMC,MAAM,CAAC;EACX;AACF;AACA;AACA;AACA;EACEC,WAAWA,CAACC,KAAK,EAAE;IACjB,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC7B,MAAM,IAAIC,KAAK,CAAE,wBAAuB,OAAOD,KAAM,EAAC,CAAC;IACzD;IACA,IAAKA,KAAK,GAAG,CAAC,IAAMA,KAAK,GAAG,GAAI,IAAK,CAACA,KAAK,GAAG,CAAC,MAAMA,KAAM,EAAE;MAC3D,MAAM,IAAIC,KAAK,CAAE,2CAA0CD,KAAM,EAAC,CAAC;IACrE;IACA,IAAI,CAACA,KAAK,GAAGA,KAAK;EACpB;;EAEA;AACF;AACA;AACA;AACA;EACEE,QAAQA,CAAA,EAAG;IACT,OAAQ,UAAS,IAAI,CAACF,KAAM,GAAE;EAChC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,CAACG,MAAM,CAACC,GAAG,CAAC,4BAA4B,CAAC,EAAEC,KAAK,EAAEC,IAAI,EAAE;IACtD,OAAQ,UAAS,IAAI,CAACN,KAAM,GAAE;EAChC;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEO,UAAUA,CAACC,GAAG,EAAE;IACd,OAAOA,GAAG,CAACC,QAAQ,CAAC,IAAI,CAACT,KAAK,EAAEN,EAAE,CAACgB,YAAY,CAAC;EAClD;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,OAAOC,QAAQA,CAACC,GAAG,EAAE;IACnB,OAAOA,GAAG,YAAYd,MAAM;EAC9B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOe,MAAMA,CAACC,GAAG,EAAEC,UAAU,GAAG,IAAI,EAAEC,iBAAiB,GAAG,KAAK,EAAE;IAC/D,QAAQF,GAAG;MACT,KAAKnB,MAAM,CAACsB,KAAK;QACf,OAAO,KAAK;MACd,KAAKtB,MAAM,CAACuB,IAAI;QACd,OAAO,IAAI;MACb,KAAKvB,MAAM,CAACwB,IAAI;QACd,IAAIJ,UAAU,EAAE;UACd,OAAO,IAAI;QACb;QACA,OAAOnB,IAAI,CAACuB,IAAI;MAClB,KAAKxB,MAAM,CAACyB,SAAS;QACnB,IAAIL,UAAU,EAAE;UACd,OAAOM,SAAS;QAClB;QACA,OAAOzB,IAAI,CAACwB,SAAS;MACvB,KAAK,CAAC,CAAC;QACL,IAAI,CAACL,UAAU,IAAI,CAACC,iBAAiB,EAAE;UACrC,MAAM,IAAIf,KAAK,CAAC,eAAe,CAAC;QAClC;QACA,OAAOL,IAAI,CAAC0B,KAAK;MACnB;QACE,OAAO,IAAIxB,MAAM,CAACgB,GAAG,CAAC;IAC1B;EACF;AACF;AAEAS,MAAM,CAACC,OAAO,GAAG1B,MAAM"},"metadata":{},"sourceType":"script","externalDependencies":[]}