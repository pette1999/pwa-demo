{"ast":null,"code":"import * as asn1js from \"asn1js\";\nimport { AsnPropTypes, AsnTypeTypes } from \"./enums\";\nimport * as converters from \"./converters\";\nimport { AsnSchemaValidationError } from \"./errors\";\nimport { isConvertible, isTypeOfArray } from \"./helper\";\nimport { schemaStorage } from \"./storage\";\nexport class AsnParser {\n  static parse(data, target) {\n    const asn1Parsed = asn1js.fromBER(data);\n    if (asn1Parsed.result.error) {\n      throw new Error(asn1Parsed.result.error);\n    }\n    const res = this.fromASN(asn1Parsed.result, target);\n    return res;\n  }\n  static fromASN(asn1Schema, target) {\n    var _a;\n    try {\n      if (isConvertible(target)) {\n        const value = new target();\n        return value.fromASN(asn1Schema);\n      }\n      const schema = schemaStorage.get(target);\n      schemaStorage.cache(target);\n      let targetSchema = schema.schema;\n      if (asn1Schema.constructor === asn1js.Constructed && schema.type !== AsnTypeTypes.Choice) {\n        targetSchema = new asn1js.Constructed({\n          idBlock: {\n            tagClass: 3,\n            tagNumber: asn1Schema.idBlock.tagNumber\n          },\n          value: schema.schema.valueBlock.value\n        });\n        for (const key in schema.items) {\n          delete asn1Schema[key];\n        }\n      }\n      const asn1ComparedSchema = asn1js.compareSchema({}, asn1Schema, targetSchema);\n      if (!asn1ComparedSchema.verified) {\n        throw new AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);\n      }\n      const res = new target();\n      if (isTypeOfArray(target)) {\n        if (!(\"value\" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value))) {\n          throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);\n        }\n        const itemType = schema.itemType;\n        if (typeof itemType === \"number\") {\n          const converter = converters.defaultConverter(itemType);\n          if (!converter) {\n            throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);\n          }\n          return target.from(asn1Schema.valueBlock.value, element => converter.fromASN(element));\n        } else {\n          return target.from(asn1Schema.valueBlock.value, element => this.fromASN(element, itemType));\n        }\n      }\n      for (const key in schema.items) {\n        const asn1SchemaValue = asn1ComparedSchema.result[key];\n        if (!asn1SchemaValue) {\n          continue;\n        }\n        const schemaItem = schema.items[key];\n        const schemaItemType = schemaItem.type;\n        if (typeof schemaItemType === \"number\" || isConvertible(schemaItemType)) {\n          const converter = (_a = schemaItem.converter) !== null && _a !== void 0 ? _a : isConvertible(schemaItemType) ? new schemaItemType() : null;\n          if (!converter) {\n            throw new Error(\"Converter is empty\");\n          }\n          if (schemaItem.repeated) {\n            if (schemaItem.implicit) {\n              const Container = schemaItem.repeated === \"sequence\" ? asn1js.Sequence : asn1js.Set;\n              const newItem = new Container();\n              newItem.valueBlock = asn1SchemaValue.valueBlock;\n              const newItemAsn = asn1js.fromBER(newItem.toBER(false));\n              if (newItemAsn.offset === -1) {\n                throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);\n              }\n              if (!(\"value\" in newItemAsn.result.valueBlock && Array.isArray(newItemAsn.result.valueBlock.value))) {\n                throw new Error(\"Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.\");\n              }\n              const value = newItemAsn.result.valueBlock.value;\n              res[key] = Array.from(value, element => converter.fromASN(element));\n            } else {\n              res[key] = Array.from(asn1SchemaValue, element => converter.fromASN(element));\n            }\n          } else {\n            let value = asn1SchemaValue;\n            if (schemaItem.implicit) {\n              let newItem;\n              if (isConvertible(schemaItemType)) {\n                newItem = new schemaItemType().toSchema(\"\");\n              } else {\n                const Asn1TypeName = AsnPropTypes[schemaItemType];\n                const Asn1Type = asn1js[Asn1TypeName];\n                if (!Asn1Type) {\n                  throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);\n                }\n                newItem = new Asn1Type();\n              }\n              newItem.valueBlock = value.valueBlock;\n              value = asn1js.fromBER(newItem.toBER(false)).result;\n            }\n            res[key] = converter.fromASN(value);\n          }\n        } else {\n          if (schemaItem.repeated) {\n            if (!Array.isArray(asn1SchemaValue)) {\n              throw new Error(\"Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.\");\n            }\n            res[key] = Array.from(asn1SchemaValue, element => this.fromASN(element, schemaItemType));\n          } else {\n            res[key] = this.fromASN(asn1SchemaValue, schemaItemType);\n          }\n        }\n      }\n      return res;\n    } catch (error) {\n      if (error instanceof AsnSchemaValidationError) {\n        error.schemas.push(target.name);\n      }\n      throw error;\n    }\n  }\n}","map":{"version":3,"names":["asn1js","AsnPropTypes","AsnTypeTypes","converters","AsnSchemaValidationError","isConvertible","isTypeOfArray","schemaStorage","AsnParser","parse","data","target","asn1Parsed","fromBER","result","error","Error","res","fromASN","asn1Schema","_a","value","schema","get","cache","targetSchema","constructor","Constructed","type","Choice","idBlock","tagClass","tagNumber","valueBlock","key","items","asn1ComparedSchema","compareSchema","verified","name","Array","isArray","itemType","converter","defaultConverter","from","element","asn1SchemaValue","schemaItem","schemaItemType","repeated","implicit","Container","Sequence","Set","newItem","newItemAsn","toBER","offset","toSchema","Asn1TypeName","Asn1Type","schemas","push"],"sources":["/Users/peterchen/Dropbox/Hexlink/Projects/pwa-demo/node_modules/@peculiar/asn1-x509/node_modules/@peculiar/asn1-schema/build/es2015/parser.js"],"sourcesContent":["import * as asn1js from \"asn1js\";\nimport { AsnPropTypes, AsnTypeTypes } from \"./enums\";\nimport * as converters from \"./converters\";\nimport { AsnSchemaValidationError } from \"./errors\";\nimport { isConvertible, isTypeOfArray } from \"./helper\";\nimport { schemaStorage } from \"./storage\";\nexport class AsnParser {\n    static parse(data, target) {\n        const asn1Parsed = asn1js.fromBER(data);\n        if (asn1Parsed.result.error) {\n            throw new Error(asn1Parsed.result.error);\n        }\n        const res = this.fromASN(asn1Parsed.result, target);\n        return res;\n    }\n    static fromASN(asn1Schema, target) {\n        var _a;\n        try {\n            if (isConvertible(target)) {\n                const value = new target();\n                return value.fromASN(asn1Schema);\n            }\n            const schema = schemaStorage.get(target);\n            schemaStorage.cache(target);\n            let targetSchema = schema.schema;\n            if (asn1Schema.constructor === asn1js.Constructed && schema.type !== AsnTypeTypes.Choice) {\n                targetSchema = new asn1js.Constructed({\n                    idBlock: {\n                        tagClass: 3,\n                        tagNumber: asn1Schema.idBlock.tagNumber,\n                    },\n                    value: schema.schema.valueBlock.value,\n                });\n                for (const key in schema.items) {\n                    delete asn1Schema[key];\n                }\n            }\n            const asn1ComparedSchema = asn1js.compareSchema({}, asn1Schema, targetSchema);\n            if (!asn1ComparedSchema.verified) {\n                throw new AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);\n            }\n            const res = new target();\n            if (isTypeOfArray(target)) {\n                if (!(\"value\" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value))) {\n                    throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);\n                }\n                const itemType = schema.itemType;\n                if (typeof itemType === \"number\") {\n                    const converter = converters.defaultConverter(itemType);\n                    if (!converter) {\n                        throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);\n                    }\n                    return target.from(asn1Schema.valueBlock.value, (element) => converter.fromASN(element));\n                }\n                else {\n                    return target.from(asn1Schema.valueBlock.value, (element) => this.fromASN(element, itemType));\n                }\n            }\n            for (const key in schema.items) {\n                const asn1SchemaValue = asn1ComparedSchema.result[key];\n                if (!asn1SchemaValue) {\n                    continue;\n                }\n                const schemaItem = schema.items[key];\n                const schemaItemType = schemaItem.type;\n                if (typeof schemaItemType === \"number\" || isConvertible(schemaItemType)) {\n                    const converter = (_a = schemaItem.converter) !== null && _a !== void 0 ? _a : (isConvertible(schemaItemType)\n                        ? new schemaItemType()\n                        : null);\n                    if (!converter) {\n                        throw new Error(\"Converter is empty\");\n                    }\n                    if (schemaItem.repeated) {\n                        if (schemaItem.implicit) {\n                            const Container = schemaItem.repeated === \"sequence\"\n                                ? asn1js.Sequence\n                                : asn1js.Set;\n                            const newItem = new Container();\n                            newItem.valueBlock = asn1SchemaValue.valueBlock;\n                            const newItemAsn = asn1js.fromBER(newItem.toBER(false));\n                            if (newItemAsn.offset === -1) {\n                                throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);\n                            }\n                            if (!(\"value\" in newItemAsn.result.valueBlock && Array.isArray(newItemAsn.result.valueBlock.value))) {\n                                throw new Error(\"Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.\");\n                            }\n                            const value = newItemAsn.result.valueBlock.value;\n                            res[key] = Array.from(value, (element) => converter.fromASN(element));\n                        }\n                        else {\n                            res[key] = Array.from(asn1SchemaValue, (element) => converter.fromASN(element));\n                        }\n                    }\n                    else {\n                        let value = asn1SchemaValue;\n                        if (schemaItem.implicit) {\n                            let newItem;\n                            if (isConvertible(schemaItemType)) {\n                                newItem = new schemaItemType().toSchema(\"\");\n                            }\n                            else {\n                                const Asn1TypeName = AsnPropTypes[schemaItemType];\n                                const Asn1Type = asn1js[Asn1TypeName];\n                                if (!Asn1Type) {\n                                    throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);\n                                }\n                                newItem = new Asn1Type();\n                            }\n                            newItem.valueBlock = value.valueBlock;\n                            value = asn1js.fromBER(newItem.toBER(false)).result;\n                        }\n                        res[key] = converter.fromASN(value);\n                    }\n                }\n                else {\n                    if (schemaItem.repeated) {\n                        if (!Array.isArray(asn1SchemaValue)) {\n                            throw new Error(\"Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.\");\n                        }\n                        res[key] = Array.from(asn1SchemaValue, (element) => this.fromASN(element, schemaItemType));\n                    }\n                    else {\n                        res[key] = this.fromASN(asn1SchemaValue, schemaItemType);\n                    }\n                }\n            }\n            return res;\n        }\n        catch (error) {\n            if (error instanceof AsnSchemaValidationError) {\n                error.schemas.push(target.name);\n            }\n            throw error;\n        }\n    }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,MAAM,MAAM,QAAQ;AAChC,SAASC,YAAY,EAAEC,YAAY,QAAQ,SAAS;AACpD,OAAO,KAAKC,UAAU,MAAM,cAAc;AAC1C,SAASC,wBAAwB,QAAQ,UAAU;AACnD,SAASC,aAAa,EAAEC,aAAa,QAAQ,UAAU;AACvD,SAASC,aAAa,QAAQ,WAAW;AACzC,OAAO,MAAMC,SAAS,CAAC;EACnB,OAAOC,KAAKA,CAACC,IAAI,EAAEC,MAAM,EAAE;IACvB,MAAMC,UAAU,GAAGZ,MAAM,CAACa,OAAO,CAACH,IAAI,CAAC;IACvC,IAAIE,UAAU,CAACE,MAAM,CAACC,KAAK,EAAE;MACzB,MAAM,IAAIC,KAAK,CAACJ,UAAU,CAACE,MAAM,CAACC,KAAK,CAAC;IAC5C;IACA,MAAME,GAAG,GAAG,IAAI,CAACC,OAAO,CAACN,UAAU,CAACE,MAAM,EAAEH,MAAM,CAAC;IACnD,OAAOM,GAAG;EACd;EACA,OAAOC,OAAOA,CAACC,UAAU,EAAER,MAAM,EAAE;IAC/B,IAAIS,EAAE;IACN,IAAI;MACA,IAAIf,aAAa,CAACM,MAAM,CAAC,EAAE;QACvB,MAAMU,KAAK,GAAG,IAAIV,MAAM,CAAC,CAAC;QAC1B,OAAOU,KAAK,CAACH,OAAO,CAACC,UAAU,CAAC;MACpC;MACA,MAAMG,MAAM,GAAGf,aAAa,CAACgB,GAAG,CAACZ,MAAM,CAAC;MACxCJ,aAAa,CAACiB,KAAK,CAACb,MAAM,CAAC;MAC3B,IAAIc,YAAY,GAAGH,MAAM,CAACA,MAAM;MAChC,IAAIH,UAAU,CAACO,WAAW,KAAK1B,MAAM,CAAC2B,WAAW,IAAIL,MAAM,CAACM,IAAI,KAAK1B,YAAY,CAAC2B,MAAM,EAAE;QACtFJ,YAAY,GAAG,IAAIzB,MAAM,CAAC2B,WAAW,CAAC;UAClCG,OAAO,EAAE;YACLC,QAAQ,EAAE,CAAC;YACXC,SAAS,EAAEb,UAAU,CAACW,OAAO,CAACE;UAClC,CAAC;UACDX,KAAK,EAAEC,MAAM,CAACA,MAAM,CAACW,UAAU,CAACZ;QACpC,CAAC,CAAC;QACF,KAAK,MAAMa,GAAG,IAAIZ,MAAM,CAACa,KAAK,EAAE;UAC5B,OAAOhB,UAAU,CAACe,GAAG,CAAC;QAC1B;MACJ;MACA,MAAME,kBAAkB,GAAGpC,MAAM,CAACqC,aAAa,CAAC,CAAC,CAAC,EAAElB,UAAU,EAAEM,YAAY,CAAC;MAC7E,IAAI,CAACW,kBAAkB,CAACE,QAAQ,EAAE;QAC9B,MAAM,IAAIlC,wBAAwB,CAAE,0BAAyBO,MAAM,CAAC4B,IAAK,iBAAgBH,kBAAkB,CAACtB,MAAM,CAACC,KAAM,EAAC,CAAC;MAC/H;MACA,MAAME,GAAG,GAAG,IAAIN,MAAM,CAAC,CAAC;MACxB,IAAIL,aAAa,CAACK,MAAM,CAAC,EAAE;QACvB,IAAI,EAAE,OAAO,IAAIQ,UAAU,CAACc,UAAU,IAAIO,KAAK,CAACC,OAAO,CAACtB,UAAU,CAACc,UAAU,CAACZ,KAAK,CAAC,CAAC,EAAE;UACnF,MAAM,IAAIL,KAAK,CAAE,gFAA+E,CAAC;QACrG;QACA,MAAM0B,QAAQ,GAAGpB,MAAM,CAACoB,QAAQ;QAChC,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;UAC9B,MAAMC,SAAS,GAAGxC,UAAU,CAACyC,gBAAgB,CAACF,QAAQ,CAAC;UACvD,IAAI,CAACC,SAAS,EAAE;YACZ,MAAM,IAAI3B,KAAK,CAAE,kDAAiDL,MAAM,CAAC4B,IAAK,cAAa,CAAC;UAChG;UACA,OAAO5B,MAAM,CAACkC,IAAI,CAAC1B,UAAU,CAACc,UAAU,CAACZ,KAAK,EAAGyB,OAAO,IAAKH,SAAS,CAACzB,OAAO,CAAC4B,OAAO,CAAC,CAAC;QAC5F,CAAC,MACI;UACD,OAAOnC,MAAM,CAACkC,IAAI,CAAC1B,UAAU,CAACc,UAAU,CAACZ,KAAK,EAAGyB,OAAO,IAAK,IAAI,CAAC5B,OAAO,CAAC4B,OAAO,EAAEJ,QAAQ,CAAC,CAAC;QACjG;MACJ;MACA,KAAK,MAAMR,GAAG,IAAIZ,MAAM,CAACa,KAAK,EAAE;QAC5B,MAAMY,eAAe,GAAGX,kBAAkB,CAACtB,MAAM,CAACoB,GAAG,CAAC;QACtD,IAAI,CAACa,eAAe,EAAE;UAClB;QACJ;QACA,MAAMC,UAAU,GAAG1B,MAAM,CAACa,KAAK,CAACD,GAAG,CAAC;QACpC,MAAMe,cAAc,GAAGD,UAAU,CAACpB,IAAI;QACtC,IAAI,OAAOqB,cAAc,KAAK,QAAQ,IAAI5C,aAAa,CAAC4C,cAAc,CAAC,EAAE;UACrE,MAAMN,SAAS,GAAG,CAACvB,EAAE,GAAG4B,UAAU,CAACL,SAAS,MAAM,IAAI,IAAIvB,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAIf,aAAa,CAAC4C,cAAc,CAAC,GACvG,IAAIA,cAAc,CAAC,CAAC,GACpB,IAAK;UACX,IAAI,CAACN,SAAS,EAAE;YACZ,MAAM,IAAI3B,KAAK,CAAC,oBAAoB,CAAC;UACzC;UACA,IAAIgC,UAAU,CAACE,QAAQ,EAAE;YACrB,IAAIF,UAAU,CAACG,QAAQ,EAAE;cACrB,MAAMC,SAAS,GAAGJ,UAAU,CAACE,QAAQ,KAAK,UAAU,GAC9ClD,MAAM,CAACqD,QAAQ,GACfrD,MAAM,CAACsD,GAAG;cAChB,MAAMC,OAAO,GAAG,IAAIH,SAAS,CAAC,CAAC;cAC/BG,OAAO,CAACtB,UAAU,GAAGc,eAAe,CAACd,UAAU;cAC/C,MAAMuB,UAAU,GAAGxD,MAAM,CAACa,OAAO,CAAC0C,OAAO,CAACE,KAAK,CAAC,KAAK,CAAC,CAAC;cACvD,IAAID,UAAU,CAACE,MAAM,KAAK,CAAC,CAAC,EAAE;gBAC1B,MAAM,IAAI1C,KAAK,CAAE,gCAA+BwC,UAAU,CAAC1C,MAAM,CAACC,KAAM,EAAC,CAAC;cAC9E;cACA,IAAI,EAAE,OAAO,IAAIyC,UAAU,CAAC1C,MAAM,CAACmB,UAAU,IAAIO,KAAK,CAACC,OAAO,CAACe,UAAU,CAAC1C,MAAM,CAACmB,UAAU,CAACZ,KAAK,CAAC,CAAC,EAAE;gBACjG,MAAM,IAAIL,KAAK,CAAC,gFAAgF,CAAC;cACrG;cACA,MAAMK,KAAK,GAAGmC,UAAU,CAAC1C,MAAM,CAACmB,UAAU,CAACZ,KAAK;cAChDJ,GAAG,CAACiB,GAAG,CAAC,GAAGM,KAAK,CAACK,IAAI,CAACxB,KAAK,EAAGyB,OAAO,IAAKH,SAAS,CAACzB,OAAO,CAAC4B,OAAO,CAAC,CAAC;YACzE,CAAC,MACI;cACD7B,GAAG,CAACiB,GAAG,CAAC,GAAGM,KAAK,CAACK,IAAI,CAACE,eAAe,EAAGD,OAAO,IAAKH,SAAS,CAACzB,OAAO,CAAC4B,OAAO,CAAC,CAAC;YACnF;UACJ,CAAC,MACI;YACD,IAAIzB,KAAK,GAAG0B,eAAe;YAC3B,IAAIC,UAAU,CAACG,QAAQ,EAAE;cACrB,IAAII,OAAO;cACX,IAAIlD,aAAa,CAAC4C,cAAc,CAAC,EAAE;gBAC/BM,OAAO,GAAG,IAAIN,cAAc,CAAC,CAAC,CAACU,QAAQ,CAAC,EAAE,CAAC;cAC/C,CAAC,MACI;gBACD,MAAMC,YAAY,GAAG3D,YAAY,CAACgD,cAAc,CAAC;gBACjD,MAAMY,QAAQ,GAAG7D,MAAM,CAAC4D,YAAY,CAAC;gBACrC,IAAI,CAACC,QAAQ,EAAE;kBACX,MAAM,IAAI7C,KAAK,CAAE,eAAc4C,YAAa,4BAA2B,CAAC;gBAC5E;gBACAL,OAAO,GAAG,IAAIM,QAAQ,CAAC,CAAC;cAC5B;cACAN,OAAO,CAACtB,UAAU,GAAGZ,KAAK,CAACY,UAAU;cACrCZ,KAAK,GAAGrB,MAAM,CAACa,OAAO,CAAC0C,OAAO,CAACE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC3C,MAAM;YACvD;YACAG,GAAG,CAACiB,GAAG,CAAC,GAAGS,SAAS,CAACzB,OAAO,CAACG,KAAK,CAAC;UACvC;QACJ,CAAC,MACI;UACD,IAAI2B,UAAU,CAACE,QAAQ,EAAE;YACrB,IAAI,CAACV,KAAK,CAACC,OAAO,CAACM,eAAe,CAAC,EAAE;cACjC,MAAM,IAAI/B,KAAK,CAAC,uFAAuF,CAAC;YAC5G;YACAC,GAAG,CAACiB,GAAG,CAAC,GAAGM,KAAK,CAACK,IAAI,CAACE,eAAe,EAAGD,OAAO,IAAK,IAAI,CAAC5B,OAAO,CAAC4B,OAAO,EAAEG,cAAc,CAAC,CAAC;UAC9F,CAAC,MACI;YACDhC,GAAG,CAACiB,GAAG,CAAC,GAAG,IAAI,CAAChB,OAAO,CAAC6B,eAAe,EAAEE,cAAc,CAAC;UAC5D;QACJ;MACJ;MACA,OAAOhC,GAAG;IACd,CAAC,CACD,OAAOF,KAAK,EAAE;MACV,IAAIA,KAAK,YAAYX,wBAAwB,EAAE;QAC3CW,KAAK,CAAC+C,OAAO,CAACC,IAAI,CAACpD,MAAM,CAAC4B,IAAI,CAAC;MACnC;MACA,MAAMxB,KAAK;IACf;EACJ;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}