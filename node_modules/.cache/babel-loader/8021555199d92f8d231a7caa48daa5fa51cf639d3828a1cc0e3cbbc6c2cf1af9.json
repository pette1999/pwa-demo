{"ast":null,"code":"import * as ip from \"ipaddr.js\";\nimport { Convert } from \"pvtsutils\";\nexport class IpConverter {\n  static decodeIP(value) {\n    if (value.length === 64 && parseInt(value, 16) === 0) {\n      return \"::/0\";\n    }\n    if (value.length !== 16) {\n      return value;\n    }\n    const mask = parseInt(value.slice(8), 16).toString(2).split('').reduce((a, k) => a + +k, 0);\n    let ip = value.slice(0, 8).replace(/(.{2})/g, match => `${parseInt(match, 16)}.`);\n    ip = ip.slice(0, -1);\n    return `${ip}/${mask}`;\n  }\n  static toString(buf) {\n    if (buf.byteLength === 4 || buf.byteLength === 16) {\n      const uint8 = new Uint8Array(buf);\n      const addr = ip.fromByteArray(Array.from(uint8));\n      return addr.toString();\n    }\n    return this.decodeIP(Convert.ToHex(buf));\n  }\n  static fromString(text) {\n    const addr = ip.parse(text);\n    return new Uint8Array(addr.toByteArray()).buffer;\n  }\n}","map":{"version":3,"names":["ip","Convert","IpConverter","decodeIP","value","length","parseInt","mask","slice","toString","split","reduce","a","k","replace","match","buf","byteLength","uint8","Uint8Array","addr","fromByteArray","Array","from","ToHex","fromString","text","parse","toByteArray","buffer"],"sources":["/Users/peterchen/Dropbox/Hexlink/Projects/pwa-demo/node_modules/@peculiar/asn1-x509/build/es2015/ip_converter.js"],"sourcesContent":["import * as ip from \"ipaddr.js\";\nimport { Convert } from \"pvtsutils\";\nexport class IpConverter {\n    static decodeIP(value) {\n        if (value.length === 64 && parseInt(value, 16) === 0) {\n            return \"::/0\";\n        }\n        if (value.length !== 16) {\n            return value;\n        }\n        const mask = parseInt(value.slice(8), 16)\n            .toString(2)\n            .split('')\n            .reduce((a, k) => a + (+k), 0);\n        let ip = value.slice(0, 8)\n            .replace(/(.{2})/g, match => `${parseInt(match, 16)}.`);\n        ip = ip.slice(0, -1);\n        return `${ip}/${mask}`;\n    }\n    static toString(buf) {\n        if (buf.byteLength === 4 || buf.byteLength === 16) {\n            const uint8 = new Uint8Array(buf);\n            const addr = ip.fromByteArray(Array.from(uint8));\n            return addr.toString();\n        }\n        return this.decodeIP(Convert.ToHex(buf));\n    }\n    static fromString(text) {\n        const addr = ip.parse(text);\n        return new Uint8Array(addr.toByteArray()).buffer;\n    }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,EAAE,MAAM,WAAW;AAC/B,SAASC,OAAO,QAAQ,WAAW;AACnC,OAAO,MAAMC,WAAW,CAAC;EACrB,OAAOC,QAAQA,CAACC,KAAK,EAAE;IACnB,IAAIA,KAAK,CAACC,MAAM,KAAK,EAAE,IAAIC,QAAQ,CAACF,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,EAAE;MAClD,OAAO,MAAM;IACjB;IACA,IAAIA,KAAK,CAACC,MAAM,KAAK,EAAE,EAAE;MACrB,OAAOD,KAAK;IAChB;IACA,MAAMG,IAAI,GAAGD,QAAQ,CAACF,KAAK,CAACI,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CACpCC,QAAQ,CAAC,CAAC,CAAC,CACXC,KAAK,CAAC,EAAE,CAAC,CACTC,MAAM,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAI,CAACC,CAAE,EAAE,CAAC,CAAC;IAClC,IAAIb,EAAE,GAAGI,KAAK,CAACI,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CACrBM,OAAO,CAAC,SAAS,EAAEC,KAAK,IAAK,GAAET,QAAQ,CAACS,KAAK,EAAE,EAAE,CAAE,GAAE,CAAC;IAC3Df,EAAE,GAAGA,EAAE,CAACQ,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACpB,OAAQ,GAAER,EAAG,IAAGO,IAAK,EAAC;EAC1B;EACA,OAAOE,QAAQA,CAACO,GAAG,EAAE;IACjB,IAAIA,GAAG,CAACC,UAAU,KAAK,CAAC,IAAID,GAAG,CAACC,UAAU,KAAK,EAAE,EAAE;MAC/C,MAAMC,KAAK,GAAG,IAAIC,UAAU,CAACH,GAAG,CAAC;MACjC,MAAMI,IAAI,GAAGpB,EAAE,CAACqB,aAAa,CAACC,KAAK,CAACC,IAAI,CAACL,KAAK,CAAC,CAAC;MAChD,OAAOE,IAAI,CAACX,QAAQ,CAAC,CAAC;IAC1B;IACA,OAAO,IAAI,CAACN,QAAQ,CAACF,OAAO,CAACuB,KAAK,CAACR,GAAG,CAAC,CAAC;EAC5C;EACA,OAAOS,UAAUA,CAACC,IAAI,EAAE;IACpB,MAAMN,IAAI,GAAGpB,EAAE,CAAC2B,KAAK,CAACD,IAAI,CAAC;IAC3B,OAAO,IAAIP,UAAU,CAACC,IAAI,CAACQ,WAAW,CAAC,CAAC,CAAC,CAACC,MAAM;EACpD;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}