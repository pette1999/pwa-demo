{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\nconst {\n  Buffer\n} = require('buffer');\nconst td = new TextDecoder('utf8', {\n  fatal: true,\n  ignoreBOM: true\n});\n\n/**\n * @typedef {object} NoFilterOptions\n * @property {string|Buffer} [input=null] Input source data.\n * @property {BufferEncoding} [inputEncoding=null] Encoding name for input,\n *   ignored if input is not a String.\n * @property {number} [highWaterMark=16384] The maximum number of bytes to\n *   store in the internal buffer before ceasing to read from the underlying\n *   resource. Default=16kb, or 16 for objectMode streams.\n * @property {BufferEncoding} [encoding=null] If specified, then buffers\n *   will be decoded to strings using the specified encoding.\n * @property {boolean} [objectMode=false] Whether this stream should behave\n *   as a stream of objects. Meaning that stream.read(n) returns a single\n *   value instead of a Buffer of size n.\n * @property {boolean} [decodeStrings=true] Whether or not to decode\n *   strings into Buffers before passing them to _write().\n * @property {boolean} [watchPipe=true] Whether to watch for 'pipe' events,\n *   setting this stream's objectMode based on the objectMode of the input\n *   stream.\n * @property {boolean} [readError=false] If true, when a read() underflows,\n *   throw an error.\n * @property {boolean} [allowHalfOpen=true] If set to false, then the\n *   stream will automatically end the writable side when the readable side\n *   ends.\n * @property {boolean} [autoDestroy=true] Whether this stream should\n *   automatically call .destroy() on itself after ending.\n * @property {BufferEncoding} [defaultEncoding='utf8'] The default encoding\n *   that is used when no encoding is specified as an argument to\n *   stream.write().\n * @property {boolean} [emitClose=true] Whether or not the stream should\n *   emit 'close' after it has been destroyed.\n * @property {number} [readableHighWaterMark] Sets highWaterMark for the\n *   readable side of the stream. Has no effect if highWaterMark is provided.\n * @property {boolean} [readableObjectMode=false] Sets objectMode for\n *   readable side of the stream. Has no effect if objectMode is true.\n * @property {number} [writableHighWaterMark] Sets highWaterMark for the\n *   writable side of the stream. Has no effect if highWaterMark is provided.\n * @property {boolean} [writableObjectMode=false] Sets objectMode for\n *   writable side of the stream. Has no effect if objectMode is true.\n */\n\n/**\n * NoFilter stream.  Can be used to sink or source data to and from\n * other node streams.  Implemented as the \"identity\" Transform stream\n * (hence the name), but allows for inspecting data that is in-flight.\n *\n * Allows passing in source data (input, inputEncoding) at creation\n * time.  Source data can also be passed in the options object.\n *\n * @example <caption>source and sink</caption>\n * const source = new NoFilter('Zm9v', 'base64')\n * source.pipe(process.stdout)\n * const sink = new Nofilter()\n * // NOTE: 'finish' fires when the input is done writing\n * sink.on('finish', () => console.log(n.toString('base64')))\n * process.stdin.pipe(sink)\n */\nclass NoFilter extends stream.Transform {\n  /**\n   * Create an instance of NoFilter.\n   *\n   * @param {string|Buffer|BufferEncoding|NoFilterOptions} [input] Source data.\n   * @param {BufferEncoding|NoFilterOptions} [inputEncoding] Encoding\n   *   name for input, ignored if input is not a String.\n   * @param {NoFilterOptions} [options] Other options.\n   */\n  constructor(input, inputEncoding, options = {}) {\n    let inp = null;\n    let inpE = /** @type {BufferEncoding?} */null;\n    switch (typeof input) {\n      case 'object':\n        if (Buffer.isBuffer(input)) {\n          inp = input;\n        } else if (input) {\n          options = input;\n        }\n        break;\n      case 'string':\n        inp = input;\n        break;\n      case 'undefined':\n        break;\n      default:\n        throw new TypeError('Invalid input');\n    }\n    switch (typeof inputEncoding) {\n      case 'object':\n        if (inputEncoding) {\n          options = inputEncoding;\n        }\n        break;\n      case 'string':\n        inpE = /** @type {BufferEncoding} */inputEncoding;\n        break;\n      case 'undefined':\n        break;\n      default:\n        throw new TypeError('Invalid inputEncoding');\n    }\n    if (!options || typeof options !== 'object') {\n      throw new TypeError('Invalid options');\n    }\n    if (inp == null) {\n      inp = options.input;\n    }\n    if (inpE == null) {\n      inpE = options.inputEncoding;\n    }\n    delete options.input;\n    delete options.inputEncoding;\n    const watchPipe = options.watchPipe == null ? true : options.watchPipe;\n    delete options.watchPipe;\n    const readError = Boolean(options.readError);\n    delete options.readError;\n    super(options);\n    this.readError = readError;\n    if (watchPipe) {\n      this.on('pipe', readable => {\n        // @ts-ignore: TS2339 (using internal interface)\n        const om = readable._readableState.objectMode;\n        // @ts-ignore: TS2339 (using internal interface)\n        if (this.length > 0 && om !== this._readableState.objectMode) {\n          throw new Error('Do not switch objectMode in the middle of the stream');\n        }\n\n        // @ts-ignore: TS2339 (using internal interface)\n        this._readableState.objectMode = om;\n        // @ts-ignore: TS2339 (using internal interface)\n        this._writableState.objectMode = om;\n      });\n    }\n    if (inp != null) {\n      this.end(inp, inpE);\n    }\n  }\n\n  /**\n   * Is the given object a {NoFilter}?\n   *\n   * @param {object} obj The object to test.\n   * @returns {boolean} True if obj is a NoFilter.\n   */\n  static isNoFilter(obj) {\n    return obj instanceof this;\n  }\n\n  /**\n   * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.\n   *\n   * @param {NoFilter} nf1 The first object to compare.\n   * @param {NoFilter} nf2 The second object to compare.\n   * @returns {number} -1, 0, 1 for less, equal, greater.\n   * @throws {TypeError} Arguments not NoFilter instances.\n   * @example\n   * const arr = [new NoFilter('1234'), new NoFilter('0123')]\n   * arr.sort(NoFilter.compare)\n   */\n  static compare(nf1, nf2) {\n    if (!(nf1 instanceof this)) {\n      throw new TypeError('Arguments must be NoFilters');\n    }\n    if (nf1 === nf2) {\n      return 0;\n    }\n    return nf1.compare(nf2);\n  }\n\n  /**\n   * Returns a buffer which is the result of concatenating all the\n   * NoFilters in the list together. If the list has no items, or if\n   * the totalLength is 0, then it returns a zero-length buffer.\n   *\n   * If length is not provided, it is read from the buffers in the\n   * list. However, this adds an additional loop to the function, so\n   * it is faster to provide the length explicitly if you already know it.\n   *\n   * @param {Array<NoFilter>} list Inputs.  Must not be all either in object\n   *   mode, or all not in object mode.\n   * @param {number} [length=null] Number of bytes or objects to read.\n   * @returns {Buffer|Array} The concatenated values as an array if in object\n   *   mode, otherwise a Buffer.\n   * @throws {TypeError} List not array of NoFilters.\n   */\n  static concat(list, length) {\n    if (!Array.isArray(list)) {\n      throw new TypeError('list argument must be an Array of NoFilters');\n    }\n    if (list.length === 0 || length === 0) {\n      return Buffer.alloc(0);\n    }\n    if (length == null) {\n      length = list.reduce((tot, nf) => {\n        if (!(nf instanceof NoFilter)) {\n          throw new TypeError('list argument must be an Array of NoFilters');\n        }\n        return tot + nf.length;\n      }, 0);\n    }\n    let allBufs = true;\n    let allObjs = true;\n    const bufs = list.map(nf => {\n      if (!(nf instanceof NoFilter)) {\n        throw new TypeError('list argument must be an Array of NoFilters');\n      }\n      const buf = nf.slice();\n      if (Buffer.isBuffer(buf)) {\n        allObjs = false;\n      } else {\n        allBufs = false;\n      }\n      return buf;\n    });\n    if (allBufs) {\n      // @ts-ignore: TS2322, tsc can't see the type checking above\n      return Buffer.concat(bufs, length);\n    }\n    if (allObjs) {\n      return [].concat(...bufs).slice(0, length);\n    }\n    // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays\n    // counting objects?  I can't imagine why that would be useful.\n    throw new Error('Concatenating mixed object and byte streams not supported');\n  }\n\n  /**\n   * @ignore\n   */\n  _transform(chunk, encoding, callback) {\n    // @ts-ignore: TS2339 (using internal interface)\n    if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {\n      chunk = Buffer.from(chunk, encoding);\n    }\n    this.push(chunk);\n    callback();\n  }\n\n  /**\n   * @returns {Buffer[]} The current internal buffers.  They are layed out\n   *   end to end.\n   * @ignore\n   */\n  _bufArray() {\n    // @ts-ignore: TS2339 (using internal interface)\n    let bufs = this._readableState.buffer;\n    // HACK: replace with something else one day.  This is what I get for\n    // relying on internals.\n    if (!Array.isArray(bufs)) {\n      let b = bufs.head;\n      bufs = [];\n      while (b != null) {\n        bufs.push(b.data);\n        b = b.next;\n      }\n    }\n    return bufs;\n  }\n\n  /**\n   * Pulls some data out of the internal buffer and returns it.\n   * If there is no data available, then it will return null.\n   *\n   * If you pass in a size argument, then it will return that many bytes. If\n   * size bytes are not available, then it will return null, unless we've\n   * ended, in which case it will return the data remaining in the buffer.\n   *\n   * If you do not specify a size argument, then it will return all the data in\n   * the internal buffer.\n   *\n   * @param {number} [size=null] Number of bytes to read.\n   * @returns {string|Buffer|null} If no data or not enough data, null.  If\n   *   decoding output a string, otherwise a Buffer.\n   * @throws Error If readError is true and there was underflow.\n   * @fires NoFilter#read When read from.\n   */\n  read(size) {\n    const buf = super.read(size);\n    if (buf != null) {\n      /**\n       * Read event. Fired whenever anything is read from the stream.\n       *\n       * @event NoFilter#read\n       * @param {Buffer|string|object} buf What was read.\n       */\n      this.emit('read', buf);\n      if (this.readError && buf.length < size) {\n        throw new Error(`Read ${buf.length}, wanted ${size}`);\n      }\n    } else if (this.readError) {\n      throw new Error(`No data available, wanted ${size}`);\n    }\n    return buf;\n  }\n\n  /**\n   * Read the full number of bytes asked for, no matter how long it takes.\n   * Fail if an error occurs in the meantime, or if the stream finishes before\n   * enough data is available.\n   *\n   * Note: This function won't work fully correctly if you are using\n   * stream-browserify (for example, on the Web).\n   *\n   * @param {number} size The number of bytes to read.\n   * @returns {Promise<string|Buffer>} A promise for the data read.\n   */\n  readFull(size) {\n    let onReadable = null;\n    let onFinish = null;\n    let onError = null;\n    return new Promise((resolve, reject) => {\n      if (this.length >= size) {\n        resolve(this.read(size));\n        return;\n      }\n\n      // Added in Node 12.19.  This won't work with stream-browserify yet.\n      // If it's needed, file a bug, and I'll do a work-around.\n      if (this.writableFinished) {\n        // Already finished writing, so no more coming.\n        reject(new Error(`Stream finished before ${size} bytes were available`));\n        return;\n      }\n      onReadable = chunk => {\n        if (this.length >= size) {\n          resolve(this.read(size));\n        }\n      };\n      onFinish = () => {\n        reject(new Error(`Stream finished before ${size} bytes were available`));\n      };\n      onError = reject;\n      this.on('readable', onReadable);\n      this.on('error', onError);\n      this.on('finish', onFinish);\n    }).finally(() => {\n      if (onReadable) {\n        this.removeListener('readable', onReadable);\n        this.removeListener('error', onError);\n        this.removeListener('finish', onFinish);\n      }\n    });\n  }\n\n  /**\n   * Return a promise fulfilled with the full contents, after the 'finish'\n   * event fires.  Errors on the stream cause the promise to be rejected.\n   *\n   * @param {Function} [cb=null] Finished/error callback used in *addition*\n   *   to the promise.\n   * @returns {Promise<Buffer|string>} Fulfilled when complete.\n   */\n  promise(cb) {\n    let done = false;\n    return new Promise((resolve, reject) => {\n      this.on('finish', () => {\n        const data = this.read();\n        if (cb != null && !done) {\n          done = true;\n          cb(null, data);\n        }\n        resolve(data);\n      });\n      this.on('error', er => {\n        if (cb != null && !done) {\n          done = true;\n          cb(er);\n        }\n        reject(er);\n      });\n    });\n  }\n\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other NoFilter in sort order.\n   *\n   * @param {NoFilter} other The other object to compare.\n   * @returns {number} -1, 0, 1 for less, equal, greater.\n   * @throws {TypeError} Arguments must be NoFilters.\n   */\n  compare(other) {\n    if (!(other instanceof NoFilter)) {\n      throw new TypeError('Arguments must be NoFilters');\n    }\n    if (this === other) {\n      return 0;\n    }\n    const buf1 = this.slice();\n    const buf2 = other.slice();\n    // These will both be buffers because of the check above.\n    if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {\n      return buf1.compare(buf2);\n    }\n    throw new Error('Cannot compare streams in object mode');\n  }\n\n  /**\n   * Do these NoFilter's contain the same bytes?  Doesn't work if either is\n   * in object mode.\n   *\n   * @param {NoFilter} other Other NoFilter to compare against.\n   * @returns {boolean} Equal?\n   */\n  equals(other) {\n    return this.compare(other) === 0;\n  }\n\n  /**\n   * Read bytes or objects without consuming them.  Useful for diagnostics.\n   * Note: as a side-effect, concatenates multiple writes together into what\n   * looks like a single write, so that this concat doesn't have to happen\n   * multiple times when you're futzing with the same NoFilter.\n   *\n   * @param {number} [start=0] Beginning offset.\n   * @param {number} [end=length] Ending offset.\n   * @returns {Buffer|Array} If in object mode, an array of objects.  Otherwise,\n   *   concatenated array of contents.\n   */\n  slice(start, end) {\n    // @ts-ignore: TS2339 (using internal interface)\n    if (this._readableState.objectMode) {\n      return this._bufArray().slice(start, end);\n    }\n    const bufs = this._bufArray();\n    switch (bufs.length) {\n      case 0:\n        return Buffer.alloc(0);\n      case 1:\n        return bufs[0].slice(start, end);\n      default:\n        {\n          const b = Buffer.concat(bufs);\n          // TODO: store the concatented bufs back\n          // @_readableState.buffer = [b]\n          return b.slice(start, end);\n        }\n    }\n  }\n\n  /**\n   * Get a byte by offset.  I didn't want to get into metaprogramming\n   * to give you the `NoFilter[0]` syntax.\n   *\n   * @param {number} index The byte to retrieve.\n   * @returns {number} 0-255.\n   */\n  get(index) {\n    return this.slice()[index];\n  }\n\n  /**\n   * Return an object compatible with Buffer's toJSON implementation, so that\n   * round-tripping will produce a Buffer.\n   *\n   * @returns {string|Array|{type: 'Buffer',data: number[]}} If in object mode,\n   *   the objects.  Otherwise, JSON text.\n   * @example <caption>output for 'foo', not in object mode</caption>\n   * ({\n   *   type: 'Buffer',\n   *   data: [102, 111, 111],\n   * })\n   */\n  toJSON() {\n    const b = this.slice();\n    if (Buffer.isBuffer(b)) {\n      return b.toJSON();\n    }\n    return b;\n  }\n\n  /**\n   * Decodes and returns a string from buffer data encoded using the specified\n   * character set encoding. If encoding is undefined or null, then encoding\n   * defaults to 'utf8'. The start and end parameters default to 0 and\n   * NoFilter.length when undefined.\n   *\n   * @param {BufferEncoding} [encoding='utf8'] Which to use for decoding?\n   * @param {number} [start=0] Start offset.\n   * @param {number} [end=length] End offset.\n   * @returns {string} String version of the contents.\n   */\n  toString(encoding, start, end) {\n    const buf = this.slice(start, end);\n    if (!Buffer.isBuffer(buf)) {\n      return JSON.stringify(buf);\n    }\n    if (!encoding || encoding === 'utf8') {\n      return td.decode(buf);\n    }\n    return buf.toString(encoding);\n  }\n\n  /**\n   * @ignore\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options) {\n    const bufs = this._bufArray();\n    const hex = bufs.map(b => {\n      if (Buffer.isBuffer(b)) {\n        return options.stylize(b.toString('hex'), 'string');\n      }\n      return JSON.stringify(b);\n    }).join(', ');\n    return `${this.constructor.name} [${hex}]`;\n  }\n\n  /**\n   * Current readable length, in bytes.\n   *\n   * @returns {number} Length of the contents.\n   */\n  get length() {\n    // @ts-ignore: TS2339 (using internal interface)\n    return this._readableState.length;\n  }\n\n  /**\n   * Write a JavaScript BigInt to the stream.  Negative numbers will be\n   * written as their 2's complement version.\n   *\n   * @param {bigint} val The value to write.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt(val) {\n    let str = val.toString(16);\n    if (val < 0) {\n      // Two's complement\n      // Note: str always starts with '-' here.\n      const sz = BigInt(Math.floor(str.length / 2));\n      const mask = BigInt(1) << sz * BigInt(8);\n      val = mask + val;\n      str = val.toString(16);\n    }\n    if (str.length % 2) {\n      str = `0${str}`;\n    }\n    return this.push(Buffer.from(str, 'hex'));\n  }\n\n  /**\n   * Read a variable-sized JavaScript unsigned BigInt from the stream.\n   *\n   * @param {number} [len=null] Number of bytes to read or all remaining\n   *   if null.\n   * @returns {bigint} A BigInt.\n   */\n  readUBigInt(len) {\n    const b = this.read(len);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return BigInt(`0x${b.toString('hex')}`);\n  }\n\n  /**\n   * Read a variable-sized JavaScript signed BigInt from the stream in 2's\n   * complement format.\n   *\n   * @param {number} [len=null] Number of bytes to read or all remaining\n   *   if null.\n   * @returns {bigint} A BigInt.\n   */\n  readBigInt(len) {\n    const b = this.read(len);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    let ret = BigInt(`0x${b.toString('hex')}`);\n    // Negative?\n    if (b[0] & 0x80) {\n      // Two's complement\n      const mask = BigInt(1) << BigInt(b.length) * BigInt(8);\n      ret -= mask;\n    }\n    return ret;\n  }\n\n  /**\n   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.\n   *\n   * @param {number} value 0..255.\n   * @returns {boolean} True on success.\n   */\n  writeUInt8(value) {\n    const b = Buffer.from([value]);\n    return this.push(b);\n  }\n\n  /**\n   * Write a little-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @param {number} value 0..65535.\n   * @returns {boolean} True on success.\n   */\n  writeUInt16LE(value) {\n    const b = Buffer.alloc(2);\n    b.writeUInt16LE(value);\n    return this.push(b);\n  }\n\n  /**\n   * Write a big-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @param {number} value 0..65535.\n   * @returns {boolean} True on success.\n   */\n  writeUInt16BE(value) {\n    const b = Buffer.alloc(2);\n    b.writeUInt16BE(value);\n    return this.push(b);\n  }\n\n  /**\n   * Write a little-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @param {number} value 0..2**32-1.\n   * @returns {boolean} True on success.\n   */\n  writeUInt32LE(value) {\n    const b = Buffer.alloc(4);\n    b.writeUInt32LE(value);\n    return this.push(b);\n  }\n\n  /**\n   * Write a big-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @param {number} value 0..2**32-1.\n   * @returns {boolean} True on success.\n   */\n  writeUInt32BE(value) {\n    const b = Buffer.alloc(4);\n    b.writeUInt32BE(value);\n    return this.push(b);\n  }\n\n  /**\n   * Write a signed 8-bit integer to the stream.  Adds 1 byte.\n   *\n   * @param {number} value (-128)..127.\n   * @returns {boolean} True on success.\n   */\n  writeInt8(value) {\n    const b = Buffer.from([value]);\n    return this.push(b);\n  }\n\n  /**\n   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @param {number} value (-32768)..32767.\n   * @returns {boolean} True on success.\n   */\n  writeInt16LE(value) {\n    const b = Buffer.alloc(2);\n    b.writeUInt16LE(value);\n    return this.push(b);\n  }\n\n  /**\n   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @param {number} value (-32768)..32767.\n   * @returns {boolean} True on success.\n   */\n  writeInt16BE(value) {\n    const b = Buffer.alloc(2);\n    b.writeUInt16BE(value);\n    return this.push(b);\n  }\n\n  /**\n   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value (-2**31)..(2**31-1).\n   * @returns {boolean} True on success.\n   */\n  writeInt32LE(value) {\n    const b = Buffer.alloc(4);\n    b.writeUInt32LE(value);\n    return this.push(b);\n  }\n\n  /**\n   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value (-2**31)..(2**31-1).\n   * @returns {boolean} True on success.\n   */\n  writeInt32BE(value) {\n    const b = Buffer.alloc(4);\n    b.writeUInt32BE(value);\n    return this.push(b);\n  }\n\n  /**\n   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value 32-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeFloatLE(value) {\n    const b = Buffer.alloc(4);\n    b.writeFloatLE(value);\n    return this.push(b);\n  }\n\n  /**\n   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value 32-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeFloatBE(value) {\n    const b = Buffer.alloc(4);\n    b.writeFloatBE(value);\n    return this.push(b);\n  }\n\n  /**\n   * Write a little-endian 64-bit double to the stream.  Adds 8 bytes.\n   *\n   * @param {number} value 64-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeDoubleLE(value) {\n    const b = Buffer.alloc(8);\n    b.writeDoubleLE(value);\n    return this.push(b);\n  }\n\n  /**\n   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @param {number} value 64-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeDoubleBE(value) {\n    const b = Buffer.alloc(8);\n    b.writeDoubleBE(value);\n    return this.push(b);\n  }\n\n  /**\n   * Write a signed little-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt64LE(value) {\n    const b = Buffer.alloc(8);\n    b.writeBigInt64LE(value);\n    return this.push(b);\n  }\n\n  /**\n   * Write a signed big-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt64BE(value) {\n    const b = Buffer.alloc(8);\n    b.writeBigInt64BE(value);\n    return this.push(b);\n  }\n\n  /**\n   * Write an unsigned little-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value Non-negative BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigUInt64LE(value) {\n    const b = Buffer.alloc(8);\n    b.writeBigUInt64LE(value);\n    return this.push(b);\n  }\n\n  /**\n   * Write an unsigned big-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value Non-negative BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigUInt64BE(value) {\n    const b = Buffer.alloc(8);\n    b.writeBigUInt64BE(value);\n    return this.push(b);\n  }\n\n  /**\n   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt8() {\n    const b = this.read(1);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return b.readUInt8();\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt16LE() {\n    const b = this.read(2);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return b.readUInt16LE();\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt16BE() {\n    const b = this.read(2);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return b.readUInt16BE();\n  }\n\n  /**\n   * Read a little-endian unsigned 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt32LE() {\n    const b = this.read(4);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return b.readUInt32LE();\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt32BE() {\n    const b = this.read(4);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return b.readUInt32BE();\n  }\n\n  /**\n   * Read a signed 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @returns {number} Value read.\n   */\n  readInt8() {\n    const b = this.read(1);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return b.readInt8();\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt16LE() {\n    const b = this.read(2);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return b.readInt16LE();\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt16BE() {\n    const b = this.read(2);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return b.readInt16BE();\n  }\n\n  /**\n   * Read a little-endian signed 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt32LE() {\n    const b = this.read(4);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return b.readInt32LE();\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt32BE() {\n    const b = this.read(4);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return b.readInt32BE();\n  }\n\n  /**\n   * Read a 32-bit little-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readFloatLE() {\n    const b = this.read(4);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return b.readFloatLE();\n  }\n\n  /**\n   * Read a 32-bit big-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readFloatBE() {\n    const b = this.read(4);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return b.readFloatBE();\n  }\n\n  /**\n   * Read a 64-bit little-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readDoubleLE() {\n    const b = this.read(8);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return b.readDoubleLE();\n  }\n\n  /**\n   * Read a 64-bit big-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readDoubleBE() {\n    const b = this.read(8);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return b.readDoubleBE();\n  }\n\n  /**\n   * Read a signed 64-bit little-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigInt64LE() {\n    const b = this.read(8);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return b.readBigInt64LE();\n  }\n\n  /**\n   * Read a signed 64-bit big-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigInt64BE() {\n    const b = this.read(8);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return b.readBigInt64BE();\n  }\n\n  /**\n   * Read an unsigned 64-bit little-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigUInt64LE() {\n    const b = this.read(8);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return b.readBigUInt64LE();\n  }\n\n  /**\n   * Read an unsigned 64-bit big-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigUInt64BE() {\n    const b = this.read(8);\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n    return b.readBigUInt64BE();\n  }\n}\nmodule.exports = NoFilter;","map":{"version":3,"names":["stream","require","Buffer","td","TextDecoder","fatal","ignoreBOM","NoFilter","Transform","constructor","input","inputEncoding","options","inp","inpE","isBuffer","TypeError","watchPipe","readError","Boolean","on","readable","om","_readableState","objectMode","length","Error","_writableState","end","isNoFilter","obj","compare","nf1","nf2","concat","list","Array","isArray","alloc","reduce","tot","nf","allBufs","allObjs","bufs","map","buf","slice","_transform","chunk","encoding","callback","from","push","_bufArray","buffer","b","head","data","next","read","size","emit","readFull","onReadable","onFinish","onError","Promise","resolve","reject","writableFinished","finally","removeListener","promise","cb","done","er","other","buf1","buf2","equals","start","get","index","toJSON","toString","JSON","stringify","decode","Symbol","for","depth","hex","stylize","join","name","writeBigInt","val","str","sz","BigInt","Math","floor","mask","readUBigInt","len","readBigInt","ret","writeUInt8","value","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","writeBigInt64LE","writeBigInt64BE","writeBigUInt64LE","writeBigUInt64BE","readUInt8","readUInt16LE","readUInt16BE","readUInt32LE","readUInt32BE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","readBigInt64LE","readBigInt64BE","readBigUInt64LE","readBigUInt64BE","module","exports"],"sources":["/Users/peterchen/Dropbox/Hexlink/pwa-demo/node_modules/nofilter/lib/index.js"],"sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst {Buffer} = require('buffer')\nconst td = new TextDecoder('utf8', {fatal: true, ignoreBOM: true})\n\n/**\n * @typedef {object} NoFilterOptions\n * @property {string|Buffer} [input=null] Input source data.\n * @property {BufferEncoding} [inputEncoding=null] Encoding name for input,\n *   ignored if input is not a String.\n * @property {number} [highWaterMark=16384] The maximum number of bytes to\n *   store in the internal buffer before ceasing to read from the underlying\n *   resource. Default=16kb, or 16 for objectMode streams.\n * @property {BufferEncoding} [encoding=null] If specified, then buffers\n *   will be decoded to strings using the specified encoding.\n * @property {boolean} [objectMode=false] Whether this stream should behave\n *   as a stream of objects. Meaning that stream.read(n) returns a single\n *   value instead of a Buffer of size n.\n * @property {boolean} [decodeStrings=true] Whether or not to decode\n *   strings into Buffers before passing them to _write().\n * @property {boolean} [watchPipe=true] Whether to watch for 'pipe' events,\n *   setting this stream's objectMode based on the objectMode of the input\n *   stream.\n * @property {boolean} [readError=false] If true, when a read() underflows,\n *   throw an error.\n * @property {boolean} [allowHalfOpen=true] If set to false, then the\n *   stream will automatically end the writable side when the readable side\n *   ends.\n * @property {boolean} [autoDestroy=true] Whether this stream should\n *   automatically call .destroy() on itself after ending.\n * @property {BufferEncoding} [defaultEncoding='utf8'] The default encoding\n *   that is used when no encoding is specified as an argument to\n *   stream.write().\n * @property {boolean} [emitClose=true] Whether or not the stream should\n *   emit 'close' after it has been destroyed.\n * @property {number} [readableHighWaterMark] Sets highWaterMark for the\n *   readable side of the stream. Has no effect if highWaterMark is provided.\n * @property {boolean} [readableObjectMode=false] Sets objectMode for\n *   readable side of the stream. Has no effect if objectMode is true.\n * @property {number} [writableHighWaterMark] Sets highWaterMark for the\n *   writable side of the stream. Has no effect if highWaterMark is provided.\n * @property {boolean} [writableObjectMode=false] Sets objectMode for\n *   writable side of the stream. Has no effect if objectMode is true.\n */\n\n/**\n * NoFilter stream.  Can be used to sink or source data to and from\n * other node streams.  Implemented as the \"identity\" Transform stream\n * (hence the name), but allows for inspecting data that is in-flight.\n *\n * Allows passing in source data (input, inputEncoding) at creation\n * time.  Source data can also be passed in the options object.\n *\n * @example <caption>source and sink</caption>\n * const source = new NoFilter('Zm9v', 'base64')\n * source.pipe(process.stdout)\n * const sink = new Nofilter()\n * // NOTE: 'finish' fires when the input is done writing\n * sink.on('finish', () => console.log(n.toString('base64')))\n * process.stdin.pipe(sink)\n */\nclass NoFilter extends stream.Transform {\n  /**\n   * Create an instance of NoFilter.\n   *\n   * @param {string|Buffer|BufferEncoding|NoFilterOptions} [input] Source data.\n   * @param {BufferEncoding|NoFilterOptions} [inputEncoding] Encoding\n   *   name for input, ignored if input is not a String.\n   * @param {NoFilterOptions} [options] Other options.\n   */\n  constructor(input, inputEncoding, options = {}) {\n    let inp = null\n    let inpE = /** @type {BufferEncoding?} */ (null)\n    switch (typeof input) {\n      case 'object':\n        if (Buffer.isBuffer(input)) {\n          inp = input\n        } else if (input) {\n          options = input\n        }\n        break\n      case 'string':\n        inp = input\n        break\n      case 'undefined':\n        break\n      default:\n        throw new TypeError('Invalid input')\n    }\n    switch (typeof inputEncoding) {\n      case 'object':\n        if (inputEncoding) {\n          options = inputEncoding\n        }\n        break\n      case 'string':\n        inpE = /** @type {BufferEncoding} */ (inputEncoding)\n        break\n      case 'undefined':\n        break\n      default:\n        throw new TypeError('Invalid inputEncoding')\n    }\n    if (!options || typeof options !== 'object') {\n      throw new TypeError('Invalid options')\n    }\n    if (inp == null) {\n      inp = options.input\n    }\n    if (inpE == null) {\n      inpE = options.inputEncoding\n    }\n    delete options.input\n    delete options.inputEncoding\n    const watchPipe = options.watchPipe == null ? true : options.watchPipe\n    delete options.watchPipe\n    const readError = Boolean(options.readError)\n    delete options.readError\n    super(options)\n\n    this.readError = readError\n\n    if (watchPipe) {\n      this.on('pipe', readable => {\n        // @ts-ignore: TS2339 (using internal interface)\n        const om = readable._readableState.objectMode\n        // @ts-ignore: TS2339 (using internal interface)\n        if ((this.length > 0) && (om !== this._readableState.objectMode)) {\n          throw new Error(\n            'Do not switch objectMode in the middle of the stream'\n          )\n        }\n\n        // @ts-ignore: TS2339 (using internal interface)\n        this._readableState.objectMode = om\n        // @ts-ignore: TS2339 (using internal interface)\n        this._writableState.objectMode = om\n      })\n    }\n\n    if (inp != null) {\n      this.end(inp, inpE)\n    }\n  }\n\n  /**\n   * Is the given object a {NoFilter}?\n   *\n   * @param {object} obj The object to test.\n   * @returns {boolean} True if obj is a NoFilter.\n   */\n  static isNoFilter(obj) {\n    return obj instanceof this\n  }\n\n  /**\n   * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.\n   *\n   * @param {NoFilter} nf1 The first object to compare.\n   * @param {NoFilter} nf2 The second object to compare.\n   * @returns {number} -1, 0, 1 for less, equal, greater.\n   * @throws {TypeError} Arguments not NoFilter instances.\n   * @example\n   * const arr = [new NoFilter('1234'), new NoFilter('0123')]\n   * arr.sort(NoFilter.compare)\n   */\n  static compare(nf1, nf2) {\n    if (!(nf1 instanceof this)) {\n      throw new TypeError('Arguments must be NoFilters')\n    }\n    if (nf1 === nf2) {\n      return 0\n    }\n    return nf1.compare(nf2)\n  }\n\n  /**\n   * Returns a buffer which is the result of concatenating all the\n   * NoFilters in the list together. If the list has no items, or if\n   * the totalLength is 0, then it returns a zero-length buffer.\n   *\n   * If length is not provided, it is read from the buffers in the\n   * list. However, this adds an additional loop to the function, so\n   * it is faster to provide the length explicitly if you already know it.\n   *\n   * @param {Array<NoFilter>} list Inputs.  Must not be all either in object\n   *   mode, or all not in object mode.\n   * @param {number} [length=null] Number of bytes or objects to read.\n   * @returns {Buffer|Array} The concatenated values as an array if in object\n   *   mode, otherwise a Buffer.\n   * @throws {TypeError} List not array of NoFilters.\n   */\n  static concat(list, length) {\n    if (!Array.isArray(list)) {\n      throw new TypeError('list argument must be an Array of NoFilters')\n    }\n    if ((list.length === 0) || (length === 0)) {\n      return Buffer.alloc(0)\n    }\n    if ((length == null)) {\n      length = list.reduce((tot, nf) => {\n        if (!(nf instanceof NoFilter)) {\n          throw new TypeError('list argument must be an Array of NoFilters')\n        }\n        return tot + nf.length\n      }, 0)\n    }\n    let allBufs = true\n    let allObjs = true\n    const bufs = list.map(nf => {\n      if (!(nf instanceof NoFilter)) {\n        throw new TypeError('list argument must be an Array of NoFilters')\n      }\n      const buf = nf.slice()\n      if (Buffer.isBuffer(buf)) {\n        allObjs = false\n      } else {\n        allBufs = false\n      }\n      return buf\n    })\n    if (allBufs) {\n      // @ts-ignore: TS2322, tsc can't see the type checking above\n      return Buffer.concat(bufs, length)\n    }\n    if (allObjs) {\n      return [].concat(...bufs).slice(0, length)\n    }\n    // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays\n    // counting objects?  I can't imagine why that would be useful.\n    throw new Error('Concatenating mixed object and byte streams not supported')\n  }\n\n  /**\n   * @ignore\n   */\n  _transform(chunk, encoding, callback) {\n    // @ts-ignore: TS2339 (using internal interface)\n    if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n    this.push(chunk)\n    callback()\n  }\n\n  /**\n   * @returns {Buffer[]} The current internal buffers.  They are layed out\n   *   end to end.\n   * @ignore\n   */\n  _bufArray() {\n    // @ts-ignore: TS2339 (using internal interface)\n    let bufs = this._readableState.buffer\n    // HACK: replace with something else one day.  This is what I get for\n    // relying on internals.\n    if (!Array.isArray(bufs)) {\n      let b = bufs.head\n      bufs = []\n      while (b != null) {\n        bufs.push(b.data)\n        b = b.next\n      }\n    }\n    return bufs\n  }\n\n  /**\n   * Pulls some data out of the internal buffer and returns it.\n   * If there is no data available, then it will return null.\n   *\n   * If you pass in a size argument, then it will return that many bytes. If\n   * size bytes are not available, then it will return null, unless we've\n   * ended, in which case it will return the data remaining in the buffer.\n   *\n   * If you do not specify a size argument, then it will return all the data in\n   * the internal buffer.\n   *\n   * @param {number} [size=null] Number of bytes to read.\n   * @returns {string|Buffer|null} If no data or not enough data, null.  If\n   *   decoding output a string, otherwise a Buffer.\n   * @throws Error If readError is true and there was underflow.\n   * @fires NoFilter#read When read from.\n   */\n  read(size) {\n    const buf = super.read(size)\n    if (buf != null) {\n      /**\n       * Read event. Fired whenever anything is read from the stream.\n       *\n       * @event NoFilter#read\n       * @param {Buffer|string|object} buf What was read.\n       */\n      this.emit('read', buf)\n      if (this.readError && (buf.length < size)) {\n        throw new Error(`Read ${buf.length}, wanted ${size}`)\n      }\n    } else if (this.readError) {\n      throw new Error(`No data available, wanted ${size}`)\n    }\n    return buf\n  }\n\n  /**\n   * Read the full number of bytes asked for, no matter how long it takes.\n   * Fail if an error occurs in the meantime, or if the stream finishes before\n   * enough data is available.\n   *\n   * Note: This function won't work fully correctly if you are using\n   * stream-browserify (for example, on the Web).\n   *\n   * @param {number} size The number of bytes to read.\n   * @returns {Promise<string|Buffer>} A promise for the data read.\n   */\n  readFull(size) {\n    let onReadable = null\n    let onFinish = null\n    let onError = null\n    return new Promise((resolve, reject) => {\n      if (this.length >= size) {\n        resolve(this.read(size))\n        return\n      }\n\n      // Added in Node 12.19.  This won't work with stream-browserify yet.\n      // If it's needed, file a bug, and I'll do a work-around.\n      if (this.writableFinished) {\n        // Already finished writing, so no more coming.\n        reject(new Error(`Stream finished before ${size} bytes were available`))\n        return\n      }\n\n      onReadable = chunk => {\n        if (this.length >= size) {\n          resolve(this.read(size))\n        }\n      }\n      onFinish = () => {\n        reject(new Error(`Stream finished before ${size} bytes were available`))\n      }\n      onError = reject\n      this.on('readable', onReadable)\n      this.on('error', onError)\n      this.on('finish', onFinish)\n    }).finally(() => {\n      if (onReadable) {\n        this.removeListener('readable', onReadable)\n        this.removeListener('error', onError)\n        this.removeListener('finish', onFinish)\n      }\n    })\n  }\n\n  /**\n   * Return a promise fulfilled with the full contents, after the 'finish'\n   * event fires.  Errors on the stream cause the promise to be rejected.\n   *\n   * @param {Function} [cb=null] Finished/error callback used in *addition*\n   *   to the promise.\n   * @returns {Promise<Buffer|string>} Fulfilled when complete.\n   */\n  promise(cb) {\n    let done = false\n    return new Promise((resolve, reject) => {\n      this.on('finish', () => {\n        const data = this.read()\n        if ((cb != null) && !done) {\n          done = true\n          cb(null, data)\n        }\n        resolve(data)\n      })\n      this.on('error', er => {\n        if ((cb != null) && !done) {\n          done = true\n          cb(er)\n        }\n        reject(er)\n      })\n    })\n  }\n\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other NoFilter in sort order.\n   *\n   * @param {NoFilter} other The other object to compare.\n   * @returns {number} -1, 0, 1 for less, equal, greater.\n   * @throws {TypeError} Arguments must be NoFilters.\n   */\n  compare(other) {\n    if (!(other instanceof NoFilter)) {\n      throw new TypeError('Arguments must be NoFilters')\n    }\n    if (this === other) {\n      return 0\n    }\n\n    const buf1 = this.slice()\n    const buf2 = other.slice()\n    // These will both be buffers because of the check above.\n    if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {\n      return buf1.compare(buf2)\n    }\n    throw new Error('Cannot compare streams in object mode')\n  }\n\n  /**\n   * Do these NoFilter's contain the same bytes?  Doesn't work if either is\n   * in object mode.\n   *\n   * @param {NoFilter} other Other NoFilter to compare against.\n   * @returns {boolean} Equal?\n   */\n  equals(other) {\n    return this.compare(other) === 0\n  }\n\n  /**\n   * Read bytes or objects without consuming them.  Useful for diagnostics.\n   * Note: as a side-effect, concatenates multiple writes together into what\n   * looks like a single write, so that this concat doesn't have to happen\n   * multiple times when you're futzing with the same NoFilter.\n   *\n   * @param {number} [start=0] Beginning offset.\n   * @param {number} [end=length] Ending offset.\n   * @returns {Buffer|Array} If in object mode, an array of objects.  Otherwise,\n   *   concatenated array of contents.\n   */\n  slice(start, end) {\n    // @ts-ignore: TS2339 (using internal interface)\n    if (this._readableState.objectMode) {\n      return this._bufArray().slice(start, end)\n    }\n    const bufs = this._bufArray()\n    switch (bufs.length) {\n      case 0: return Buffer.alloc(0)\n      case 1: return bufs[0].slice(start, end)\n      default: {\n        const b = Buffer.concat(bufs)\n        // TODO: store the concatented bufs back\n        // @_readableState.buffer = [b]\n        return b.slice(start, end)\n      }\n    }\n  }\n\n  /**\n   * Get a byte by offset.  I didn't want to get into metaprogramming\n   * to give you the `NoFilter[0]` syntax.\n   *\n   * @param {number} index The byte to retrieve.\n   * @returns {number} 0-255.\n   */\n  get(index) {\n    return this.slice()[index]\n  }\n\n  /**\n   * Return an object compatible with Buffer's toJSON implementation, so that\n   * round-tripping will produce a Buffer.\n   *\n   * @returns {string|Array|{type: 'Buffer',data: number[]}} If in object mode,\n   *   the objects.  Otherwise, JSON text.\n   * @example <caption>output for 'foo', not in object mode</caption>\n   * ({\n   *   type: 'Buffer',\n   *   data: [102, 111, 111],\n   * })\n   */\n  toJSON() {\n    const b = this.slice()\n    if (Buffer.isBuffer(b)) {\n      return b.toJSON()\n    }\n    return b\n  }\n\n  /**\n   * Decodes and returns a string from buffer data encoded using the specified\n   * character set encoding. If encoding is undefined or null, then encoding\n   * defaults to 'utf8'. The start and end parameters default to 0 and\n   * NoFilter.length when undefined.\n   *\n   * @param {BufferEncoding} [encoding='utf8'] Which to use for decoding?\n   * @param {number} [start=0] Start offset.\n   * @param {number} [end=length] End offset.\n   * @returns {string} String version of the contents.\n   */\n  toString(encoding, start, end) {\n    const buf = this.slice(start, end)\n    if (!Buffer.isBuffer(buf)) {\n      return JSON.stringify(buf)\n    }\n    if (!encoding || (encoding === 'utf8')) {\n      return td.decode(buf)\n    }\n    return buf.toString(encoding)\n  }\n\n  /**\n   * @ignore\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options) {\n    const bufs = this._bufArray()\n    const hex = bufs.map(b => {\n      if (Buffer.isBuffer(b)) {\n        return options.stylize(b.toString('hex'), 'string')\n      }\n      return JSON.stringify(b)\n    }).join(', ')\n    return `${this.constructor.name} [${hex}]`\n  }\n\n  /**\n   * Current readable length, in bytes.\n   *\n   * @returns {number} Length of the contents.\n   */\n  get length() {\n    // @ts-ignore: TS2339 (using internal interface)\n    return this._readableState.length\n  }\n\n  /**\n   * Write a JavaScript BigInt to the stream.  Negative numbers will be\n   * written as their 2's complement version.\n   *\n   * @param {bigint} val The value to write.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt(val) {\n    let str = val.toString(16)\n    if (val < 0) {\n      // Two's complement\n      // Note: str always starts with '-' here.\n      const sz = BigInt(Math.floor(str.length / 2))\n      const mask = BigInt(1) << (sz * BigInt(8))\n      val = mask + val\n      str = val.toString(16)\n    }\n    if (str.length % 2) {\n      str = `0${str}`\n    }\n    return this.push(Buffer.from(str, 'hex'))\n  }\n\n  /**\n   * Read a variable-sized JavaScript unsigned BigInt from the stream.\n   *\n   * @param {number} [len=null] Number of bytes to read or all remaining\n   *   if null.\n   * @returns {bigint} A BigInt.\n   */\n  readUBigInt(len) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return BigInt(`0x${b.toString('hex')}`)\n  }\n\n  /**\n   * Read a variable-sized JavaScript signed BigInt from the stream in 2's\n   * complement format.\n   *\n   * @param {number} [len=null] Number of bytes to read or all remaining\n   *   if null.\n   * @returns {bigint} A BigInt.\n   */\n  readBigInt(len) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    let ret = BigInt(`0x${b.toString('hex')}`)\n    // Negative?\n    if (b[0] & 0x80) {\n      // Two's complement\n      const mask = BigInt(1) << (BigInt(b.length) * BigInt(8))\n      ret -= mask\n    }\n    return ret\n  }\n\n  /**\n   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.\n   *\n   * @param {number} value 0..255.\n   * @returns {boolean} True on success.\n   */\n  writeUInt8(value) {\n    const b = Buffer.from([value])\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @param {number} value 0..65535.\n   * @returns {boolean} True on success.\n   */\n  writeUInt16LE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @param {number} value 0..65535.\n   * @returns {boolean} True on success.\n   */\n  writeUInt16BE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @param {number} value 0..2**32-1.\n   * @returns {boolean} True on success.\n   */\n  writeUInt32LE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @param {number} value 0..2**32-1.\n   * @returns {boolean} True on success.\n   */\n  writeUInt32BE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed 8-bit integer to the stream.  Adds 1 byte.\n   *\n   * @param {number} value (-128)..127.\n   * @returns {boolean} True on success.\n   */\n  writeInt8(value) {\n    const b = Buffer.from([value])\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @param {number} value (-32768)..32767.\n   * @returns {boolean} True on success.\n   */\n  writeInt16LE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @param {number} value (-32768)..32767.\n   * @returns {boolean} True on success.\n   */\n  writeInt16BE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value (-2**31)..(2**31-1).\n   * @returns {boolean} True on success.\n   */\n  writeInt32LE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value (-2**31)..(2**31-1).\n   * @returns {boolean} True on success.\n   */\n  writeInt32BE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value 32-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeFloatLE(value) {\n    const b = Buffer.alloc(4)\n    b.writeFloatLE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value 32-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeFloatBE(value) {\n    const b = Buffer.alloc(4)\n    b.writeFloatBE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 64-bit double to the stream.  Adds 8 bytes.\n   *\n   * @param {number} value 64-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeDoubleLE(value) {\n    const b = Buffer.alloc(8)\n    b.writeDoubleLE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @param {number} value 64-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeDoubleBE(value) {\n    const b = Buffer.alloc(8)\n    b.writeDoubleBE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed little-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt64LE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigInt64LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed big-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt64BE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigInt64BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write an unsigned little-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value Non-negative BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigUInt64LE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigUInt64LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write an unsigned big-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value Non-negative BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigUInt64BE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigUInt64BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt8() {\n    const b = this.read(1)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt8()\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt16LE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt16LE()\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt16BE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt16BE()\n  }\n\n  /**\n   * Read a little-endian unsigned 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt32LE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt32LE()\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt32BE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt32BE()\n  }\n\n  /**\n   * Read a signed 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @returns {number} Value read.\n   */\n  readInt8() {\n    const b = this.read(1)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt8()\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt16LE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt16LE()\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt16BE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt16BE()\n  }\n\n  /**\n   * Read a little-endian signed 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt32LE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt32LE()\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt32BE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt32BE()\n  }\n\n  /**\n   * Read a 32-bit little-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readFloatLE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readFloatLE()\n  }\n\n  /**\n   * Read a 32-bit big-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readFloatBE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readFloatBE()\n  }\n\n  /**\n   * Read a 64-bit little-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readDoubleLE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readDoubleLE()\n  }\n\n  /**\n   * Read a 64-bit big-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readDoubleBE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readDoubleBE()\n  }\n\n  /**\n   * Read a signed 64-bit little-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigInt64LE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigInt64LE()\n  }\n\n  /**\n   * Read a signed 64-bit big-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigInt64BE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigInt64BE()\n  }\n\n  /**\n   * Read an unsigned 64-bit little-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigUInt64LE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigUInt64LE()\n  }\n\n  /**\n   * Read an unsigned 64-bit big-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigUInt64BE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigUInt64BE()\n  }\n}\n\nmodule.exports = NoFilter\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}