{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\nconst utils = require('./utils');\nconst Decoder = require('./decoder');\nconst NoFilter = require('nofilter');\nconst {\n  MT,\n  NUMBYTES,\n  SYMS\n} = require('./constants');\nconst {\n  Buffer\n} = require('buffer');\nfunction plural(c) {\n  if (c > 1) {\n    return 's';\n  }\n  return '';\n}\n\n/**\n * @typedef CommentOptions\n * @property {number} [max_depth=10] How many times to indent\n *   the dashes.\n * @property {number} [depth=1] Initial indentation depth.\n * @property {boolean} [no_summary=false] If true, omit the summary\n *   of the full bytes read at the end.\n * @property {object} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] Encoding to use for input, if it\n *   is a string.\n */\n/**\n * @callback commentCallback\n * @param {Error} [error] If one was generated.\n * @param {string} [commented] The comment string.\n * @returns {void}\n */\n/**\n * Normalize inputs to the static functions.\n *\n * @param {CommentOptions|commentCallback|string|number} opts Encoding,\n *   max_depth, or callback.\n * @param {commentCallback} [cb] Called on completion.\n * @returns {{options: CommentOptions, cb: commentCallback}} Normalized value.\n * @throws {TypeError} Unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {\n        options: {},\n        cb: /** @type {commentCallback} */opts\n      };\n    case 'string':\n      return {\n        options: {\n          encoding: /** @type {BufferEncoding} */opts\n        },\n        cb\n      };\n    case 'number':\n      return {\n        options: {\n          max_depth: opts\n        },\n        cb\n      };\n    case 'object':\n      return {\n        options: opts || {},\n        cb\n      };\n    default:\n      throw new TypeError('Unknown option type');\n  }\n}\n\n/**\n * Generate the expanded format of RFC 8949, section 3.2.2.\n *\n * @extends stream.Transform\n */\nclass Commented extends stream.Transform {\n  /**\n   * Create a CBOR commenter.\n   *\n   * @param {CommentOptions} [options={}] Stream options.\n   */\n  constructor(options = {}) {\n    const {\n      depth = 1,\n      max_depth = 10,\n      no_summary = false,\n      // Decoder options\n      tags = {},\n      preferWeb,\n      encoding,\n      // Stream.Transform options\n      ...superOpts\n    } = options;\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: false\n    });\n    this.depth = depth;\n    this.max_depth = max_depth;\n    this.all = new NoFilter();\n    if (!tags[24]) {\n      tags[24] = this._tag_24.bind(this);\n    }\n    this.parser = new Decoder({\n      tags,\n      max_depth,\n      preferWeb,\n      encoding\n    });\n    this.parser.on('value', this._on_value.bind(this));\n    this.parser.on('start', this._on_start.bind(this));\n    this.parser.on('start-string', this._on_start_string.bind(this));\n    this.parser.on('stop', this._on_stop.bind(this));\n    this.parser.on('more-bytes', this._on_more.bind(this));\n    this.parser.on('error', this._on_error.bind(this));\n    if (!no_summary) {\n      this.parser.on('data', this._on_data.bind(this));\n    }\n    this.parser.bs.on('read', this._on_read.bind(this));\n  }\n\n  /**\n   * @param {Buffer} v Descend into embedded CBOR.\n   * @private\n   */\n  _tag_24(v) {\n    const c = new Commented({\n      depth: this.depth + 1,\n      no_summary: true\n    });\n    c.on('data', b => this.push(b));\n    c.on('error', er => this.emit('error', er));\n    c.end(v);\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, encoding, cb) {\n    this.parser.write(fresh, encoding, cb);\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _flush(cb) {\n    // TODO: find the test that covers this, and look at the return value\n    return this.parser._flush(cb);\n  }\n\n  /**\n   * Comment on an input Buffer or string, creating a string passed to the\n   * callback.  If callback not specified, a promise is returned.\n   *\n   * @param {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n   *   |DataView|stream.Readable} input Something to parse.\n   * @param {CommentOptions|commentCallback|string|number} [options={}]\n   *   Encoding, max_depth, or callback.\n   * @param {commentCallback} [cb] If specified, called on completion.\n   * @returns {Promise} If cb not specified.\n   * @throws {Error} Input required.\n   * @static\n   */\n  static comment(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new Error('input required');\n    }\n    ({\n      options,\n      cb\n    } = normalizeOptions(options, cb));\n    const bs = new NoFilter();\n    const {\n      encoding = 'hex',\n      ...opts\n    } = options;\n    const d = new Commented(opts);\n    let p = null;\n    if (typeof cb === 'function') {\n      d.on('end', () => {\n        cb(null, bs.toString('utf8'));\n      });\n      d.on('error', cb);\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => {\n          resolve(bs.toString('utf8'));\n        });\n        d.on('error', reject);\n      });\n    }\n    d.pipe(bs);\n    utils.guessEncoding(input, encoding).pipe(d);\n    return p;\n  }\n\n  /**\n   * @ignore\n   */\n  _on_error(er) {\n    this.push('ERROR: ');\n    this.push(er.toString());\n    this.push('\\n');\n  }\n\n  /**\n   * @ignore\n   */\n  _on_read(buf) {\n    this.all.write(buf);\n    const hex = buf.toString('hex');\n    this.push(new Array(this.depth + 1).join('  '));\n    this.push(hex);\n    let ind = (this.max_depth - this.depth) * 2 - hex.length;\n    if (ind < 1) {\n      ind = 1;\n    }\n    this.push(new Array(ind + 1).join(' '));\n    this.push('-- ');\n  }\n\n  /**\n   * @ignore\n   */\n  _on_more(mt, len, parent_mt, pos) {\n    let desc = '';\n    this.depth++;\n    switch (mt) {\n      case MT.POS_INT:\n        desc = 'Positive number,';\n        break;\n      case MT.NEG_INT:\n        desc = 'Negative number,';\n        break;\n      case MT.ARRAY:\n        desc = 'Array, length';\n        break;\n      case MT.MAP:\n        desc = 'Map, count';\n        break;\n      case MT.BYTE_STRING:\n        desc = 'Bytes, length';\n        break;\n      case MT.UTF8_STRING:\n        desc = 'String, length';\n        break;\n      case MT.SIMPLE_FLOAT:\n        if (len === 1) {\n          desc = 'Simple value,';\n        } else {\n          desc = 'Float,';\n        }\n        break;\n    }\n    this.push(`${desc} next ${len} byte${plural(len)}\\n`);\n  }\n\n  /**\n   * @ignore\n   */\n  _on_start_string(mt, len, parent_mt, pos) {\n    let desc = '';\n    this.depth++;\n    switch (mt) {\n      case MT.BYTE_STRING:\n        desc = `Bytes, length: ${len}`;\n        break;\n      case MT.UTF8_STRING:\n        desc = `String, length: ${len.toString()}`;\n        break;\n    }\n    this.push(`${desc}\\n`);\n  }\n\n  /**\n   * @ignore\n   */\n  _on_start(mt, tag, parent_mt, pos) {\n    this.depth++;\n    switch (parent_mt) {\n      case MT.ARRAY:\n        this.push(`[${pos}], `);\n        break;\n      case MT.MAP:\n        if (pos % 2) {\n          this.push(`{Val:${Math.floor(pos / 2)}}, `);\n        } else {\n          this.push(`{Key:${Math.floor(pos / 2)}}, `);\n        }\n        break;\n    }\n    switch (mt) {\n      case MT.TAG:\n        this.push(`Tag #${tag}`);\n        if (tag === 24) {\n          this.push(' Encoded CBOR data item');\n        }\n        break;\n      case MT.ARRAY:\n        if (tag === SYMS.STREAM) {\n          this.push('Array (streaming)');\n        } else {\n          this.push(`Array, ${tag} item${plural(tag)}`);\n        }\n        break;\n      case MT.MAP:\n        if (tag === SYMS.STREAM) {\n          this.push('Map (streaming)');\n        } else {\n          this.push(`Map, ${tag} pair${plural(tag)}`);\n        }\n        break;\n      case MT.BYTE_STRING:\n        this.push('Bytes (streaming)');\n        break;\n      case MT.UTF8_STRING:\n        this.push('String (streaming)');\n        break;\n    }\n    this.push('\\n');\n  }\n\n  /**\n   * @ignore\n   */\n  _on_stop(mt) {\n    this.depth--;\n  }\n\n  /**\n   * @private\n   */\n  _on_value(val, parent_mt, pos, ai) {\n    if (val !== SYMS.BREAK) {\n      switch (parent_mt) {\n        case MT.ARRAY:\n          this.push(`[${pos}], `);\n          break;\n        case MT.MAP:\n          if (pos % 2) {\n            this.push(`{Val:${Math.floor(pos / 2)}}, `);\n          } else {\n            this.push(`{Key:${Math.floor(pos / 2)}}, `);\n          }\n          break;\n      }\n    }\n    const str = utils.cborValueToString(val, -Infinity);\n    if (typeof val === 'string' || Buffer.isBuffer(val)) {\n      if (val.length > 0) {\n        this.push(str);\n        this.push('\\n');\n      }\n      this.depth--;\n    } else {\n      this.push(str);\n      this.push('\\n');\n    }\n    switch (ai) {\n      case NUMBYTES.ONE:\n      case NUMBYTES.TWO:\n      case NUMBYTES.FOUR:\n      case NUMBYTES.EIGHT:\n        this.depth--;\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  _on_data() {\n    this.push('0x');\n    this.push(this.all.read().toString('hex'));\n    this.push('\\n');\n  }\n}\nmodule.exports = Commented;","map":{"version":3,"names":["stream","require","utils","Decoder","NoFilter","MT","NUMBYTES","SYMS","Buffer","plural","c","normalizeOptions","opts","cb","options","encoding","max_depth","TypeError","Commented","Transform","constructor","depth","no_summary","tags","preferWeb","superOpts","readableObjectMode","writableObjectMode","all","_tag_24","bind","parser","on","_on_value","_on_start","_on_start_string","_on_stop","_on_more","_on_error","_on_data","bs","_on_read","v","b","push","er","emit","end","_transform","fresh","write","_flush","comment","input","Error","d","p","toString","Promise","resolve","reject","pipe","guessEncoding","buf","hex","Array","join","ind","length","mt","len","parent_mt","pos","desc","POS_INT","NEG_INT","ARRAY","MAP","BYTE_STRING","UTF8_STRING","SIMPLE_FLOAT","tag","Math","floor","TAG","STREAM","val","ai","BREAK","str","cborValueToString","Infinity","isBuffer","ONE","TWO","FOUR","EIGHT","read","module","exports"],"sources":["/Users/peterchen/Dropbox/Hexlink/pwa-demo/node_modules/cbor/lib/commented.js"],"sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst utils = require('./utils')\nconst Decoder = require('./decoder')\nconst NoFilter = require('nofilter')\nconst {MT, NUMBYTES, SYMS} = require('./constants')\nconst {Buffer} = require('buffer')\n\nfunction plural(c) {\n  if (c > 1) {\n    return 's'\n  }\n  return ''\n}\n\n/**\n * @typedef CommentOptions\n * @property {number} [max_depth=10] How many times to indent\n *   the dashes.\n * @property {number} [depth=1] Initial indentation depth.\n * @property {boolean} [no_summary=false] If true, omit the summary\n *   of the full bytes read at the end.\n * @property {object} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] Encoding to use for input, if it\n *   is a string.\n */\n/**\n * @callback commentCallback\n * @param {Error} [error] If one was generated.\n * @param {string} [commented] The comment string.\n * @returns {void}\n */\n/**\n * Normalize inputs to the static functions.\n *\n * @param {CommentOptions|commentCallback|string|number} opts Encoding,\n *   max_depth, or callback.\n * @param {commentCallback} [cb] Called on completion.\n * @returns {{options: CommentOptions, cb: commentCallback}} Normalized value.\n * @throws {TypeError} Unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {commentCallback} */ (opts)}\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb}\n    case 'number':\n      return {options: {max_depth: opts}, cb}\n    case 'object':\n      return {options: opts || {}, cb}\n    default:\n      throw new TypeError('Unknown option type')\n  }\n}\n\n/**\n * Generate the expanded format of RFC 8949, section 3.2.2.\n *\n * @extends stream.Transform\n */\nclass Commented extends stream.Transform {\n  /**\n   * Create a CBOR commenter.\n   *\n   * @param {CommentOptions} [options={}] Stream options.\n   */\n  constructor(options = {}) {\n    const {\n      depth = 1,\n      max_depth = 10,\n      no_summary = false,\n      // Decoder options\n      tags = {},\n      preferWeb,\n      encoding,\n      // Stream.Transform options\n      ...superOpts\n    } = options\n\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: false,\n    })\n\n    this.depth = depth\n    this.max_depth = max_depth\n    this.all = new NoFilter()\n\n    if (!tags[24]) {\n      tags[24] = this._tag_24.bind(this)\n    }\n    this.parser = new Decoder({\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n    })\n    this.parser.on('value', this._on_value.bind(this))\n    this.parser.on('start', this._on_start.bind(this))\n    this.parser.on('start-string', this._on_start_string.bind(this))\n    this.parser.on('stop', this._on_stop.bind(this))\n    this.parser.on('more-bytes', this._on_more.bind(this))\n    this.parser.on('error', this._on_error.bind(this))\n    if (!no_summary) {\n      this.parser.on('data', this._on_data.bind(this))\n    }\n    this.parser.bs.on('read', this._on_read.bind(this))\n  }\n\n  /**\n   * @param {Buffer} v Descend into embedded CBOR.\n   * @private\n   */\n  _tag_24(v) {\n    const c = new Commented({depth: this.depth + 1, no_summary: true})\n\n    c.on('data', b => this.push(b))\n    c.on('error', er => this.emit('error', er))\n    c.end(v)\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, encoding, cb) {\n    this.parser.write(fresh, encoding, cb)\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _flush(cb) {\n    // TODO: find the test that covers this, and look at the return value\n    return this.parser._flush(cb)\n  }\n\n  /**\n   * Comment on an input Buffer or string, creating a string passed to the\n   * callback.  If callback not specified, a promise is returned.\n   *\n   * @param {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n   *   |DataView|stream.Readable} input Something to parse.\n   * @param {CommentOptions|commentCallback|string|number} [options={}]\n   *   Encoding, max_depth, or callback.\n   * @param {commentCallback} [cb] If specified, called on completion.\n   * @returns {Promise} If cb not specified.\n   * @throws {Error} Input required.\n   * @static\n   */\n  static comment(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new Error('input required')\n    }\n    ({options, cb} = normalizeOptions(options, cb))\n    const bs = new NoFilter()\n    const {encoding = 'hex', ...opts} = options\n    const d = new Commented(opts)\n    let p = null\n\n    if (typeof cb === 'function') {\n      d.on('end', () => {\n        cb(null, bs.toString('utf8'))\n      })\n      d.on('error', cb)\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => {\n          resolve(bs.toString('utf8'))\n        })\n        d.on('error', reject)\n      })\n    }\n    d.pipe(bs)\n    utils.guessEncoding(input, encoding).pipe(d)\n    return p\n  }\n\n  /**\n   * @ignore\n   */\n  _on_error(er) {\n    this.push('ERROR: ')\n    this.push(er.toString())\n    this.push('\\n')\n  }\n\n  /**\n   * @ignore\n   */\n  _on_read(buf) {\n    this.all.write(buf)\n    const hex = buf.toString('hex')\n\n    this.push(new Array(this.depth + 1).join('  '))\n    this.push(hex)\n\n    let ind = ((this.max_depth - this.depth) * 2) - hex.length\n    if (ind < 1) {\n      ind = 1\n    }\n    this.push(new Array(ind + 1).join(' '))\n    this.push('-- ')\n  }\n\n  /**\n   * @ignore\n   */\n  _on_more(mt, len, parent_mt, pos) {\n    let desc = ''\n\n    this.depth++\n    switch (mt) {\n      case MT.POS_INT:\n        desc = 'Positive number,'\n        break\n      case MT.NEG_INT:\n        desc = 'Negative number,'\n        break\n      case MT.ARRAY:\n        desc = 'Array, length'\n        break\n      case MT.MAP:\n        desc = 'Map, count'\n        break\n      case MT.BYTE_STRING:\n        desc = 'Bytes, length'\n        break\n      case MT.UTF8_STRING:\n        desc = 'String, length'\n        break\n      case MT.SIMPLE_FLOAT:\n        if (len === 1) {\n          desc = 'Simple value,'\n        } else {\n          desc = 'Float,'\n        }\n        break\n    }\n    this.push(`${desc} next ${len} byte${plural(len)}\\n`)\n  }\n\n  /**\n   * @ignore\n   */\n  _on_start_string(mt, len, parent_mt, pos) {\n    let desc = ''\n\n    this.depth++\n    switch (mt) {\n      case MT.BYTE_STRING:\n        desc = `Bytes, length: ${len}`\n        break\n      case MT.UTF8_STRING:\n        desc = `String, length: ${len.toString()}`\n        break\n    }\n    this.push(`${desc}\\n`)\n  }\n\n  /**\n   * @ignore\n   */\n  _on_start(mt, tag, parent_mt, pos) {\n    this.depth++\n    switch (parent_mt) {\n      case MT.ARRAY:\n        this.push(`[${pos}], `)\n        break\n      case MT.MAP:\n        if (pos % 2) {\n          this.push(`{Val:${Math.floor(pos / 2)}}, `)\n        } else {\n          this.push(`{Key:${Math.floor(pos / 2)}}, `)\n        }\n        break\n    }\n    switch (mt) {\n      case MT.TAG:\n        this.push(`Tag #${tag}`)\n        if (tag === 24) {\n          this.push(' Encoded CBOR data item')\n        }\n        break\n      case MT.ARRAY:\n        if (tag === SYMS.STREAM) {\n          this.push('Array (streaming)')\n        } else {\n          this.push(`Array, ${tag} item${plural(tag)}`)\n        }\n        break\n      case MT.MAP:\n        if (tag === SYMS.STREAM) {\n          this.push('Map (streaming)')\n        } else {\n          this.push(`Map, ${tag} pair${plural(tag)}`)\n        }\n        break\n      case MT.BYTE_STRING:\n        this.push('Bytes (streaming)')\n        break\n      case MT.UTF8_STRING:\n        this.push('String (streaming)')\n        break\n    }\n    this.push('\\n')\n  }\n\n  /**\n   * @ignore\n   */\n  _on_stop(mt) {\n    this.depth--\n  }\n\n  /**\n   * @private\n   */\n  _on_value(val, parent_mt, pos, ai) {\n    if (val !== SYMS.BREAK) {\n      switch (parent_mt) {\n        case MT.ARRAY:\n          this.push(`[${pos}], `)\n          break\n        case MT.MAP:\n          if (pos % 2) {\n            this.push(`{Val:${Math.floor(pos / 2)}}, `)\n          } else {\n            this.push(`{Key:${Math.floor(pos / 2)}}, `)\n          }\n          break\n      }\n    }\n    const str = utils.cborValueToString(val, -Infinity)\n\n    if ((typeof val === 'string') ||\n        (Buffer.isBuffer(val))) {\n      if (val.length > 0) {\n        this.push(str)\n        this.push('\\n')\n      }\n      this.depth--\n    } else {\n      this.push(str)\n      this.push('\\n')\n    }\n\n    switch (ai) {\n      case NUMBYTES.ONE:\n      case NUMBYTES.TWO:\n      case NUMBYTES.FOUR:\n      case NUMBYTES.EIGHT:\n        this.depth--\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  _on_data() {\n    this.push('0x')\n    this.push(this.all.read().toString('hex'))\n    this.push('\\n')\n  }\n}\n\nmodule.exports = Commented\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}