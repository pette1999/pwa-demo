{"ast":null,"code":"import * as asn1js from \"asn1js\";\nimport * as converters from \"./converters\";\nimport { AsnPropTypes, AsnTypeTypes } from \"./enums\";\nimport { isConvertible, isArrayEqual } from \"./helper\";\nimport { schemaStorage } from \"./storage\";\nexport class AsnSerializer {\n  static serialize(obj) {\n    if (obj instanceof asn1js.BaseBlock) {\n      return obj.toBER(false);\n    }\n    return this.toASN(obj).toBER(false);\n  }\n  static toASN(obj) {\n    if (obj && typeof obj === \"object\" && isConvertible(obj)) {\n      return obj.toASN();\n    }\n    if (!(obj && typeof obj === \"object\")) {\n      throw new TypeError(\"Parameter 1 should be type of Object.\");\n    }\n    const target = obj.constructor;\n    const schema = schemaStorage.get(target);\n    schemaStorage.cache(target);\n    let asn1Value = [];\n    if (schema.itemType) {\n      if (!Array.isArray(obj)) {\n        throw new TypeError(\"Parameter 1 should be type of Array.\");\n      }\n      if (typeof schema.itemType === \"number\") {\n        const converter = converters.defaultConverter(schema.itemType);\n        if (!converter) {\n          throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);\n        }\n        asn1Value = obj.map(o => converter.toASN(o));\n      } else {\n        asn1Value = obj.map(o => this.toAsnItem({\n          type: schema.itemType\n        }, \"[]\", target, o));\n      }\n    } else {\n      for (const key in schema.items) {\n        const schemaItem = schema.items[key];\n        const objProp = obj[key];\n        if (objProp === undefined || schemaItem.defaultValue === objProp || typeof schemaItem.defaultValue === \"object\" && typeof objProp === \"object\" && isArrayEqual(this.serialize(schemaItem.defaultValue), this.serialize(objProp))) {\n          continue;\n        }\n        const asn1Item = AsnSerializer.toAsnItem(schemaItem, key, target, objProp);\n        if (typeof schemaItem.context === \"number\") {\n          if (schemaItem.implicit) {\n            if (!schemaItem.repeated && (typeof schemaItem.type === \"number\" || isConvertible(schemaItem.type))) {\n              const value = {};\n              value.valueHex = asn1Item instanceof asn1js.Null ? asn1Item.valueBeforeDecodeView : asn1Item.valueBlock.toBER();\n              asn1Value.push(new asn1js.Primitive({\n                optional: schemaItem.optional,\n                idBlock: {\n                  tagClass: 3,\n                  tagNumber: schemaItem.context\n                },\n                ...value\n              }));\n            } else {\n              asn1Value.push(new asn1js.Constructed({\n                optional: schemaItem.optional,\n                idBlock: {\n                  tagClass: 3,\n                  tagNumber: schemaItem.context\n                },\n                value: asn1Item.valueBlock.value\n              }));\n            }\n          } else {\n            asn1Value.push(new asn1js.Constructed({\n              optional: schemaItem.optional,\n              idBlock: {\n                tagClass: 3,\n                tagNumber: schemaItem.context\n              },\n              value: [asn1Item]\n            }));\n          }\n        } else if (schemaItem.repeated) {\n          asn1Value = asn1Value.concat(asn1Item);\n        } else {\n          asn1Value.push(asn1Item);\n        }\n      }\n    }\n    let asnSchema;\n    switch (schema.type) {\n      case AsnTypeTypes.Sequence:\n        asnSchema = new asn1js.Sequence({\n          value: asn1Value\n        });\n        break;\n      case AsnTypeTypes.Set:\n        asnSchema = new asn1js.Set({\n          value: asn1Value\n        });\n        break;\n      case AsnTypeTypes.Choice:\n        if (!asn1Value[0]) {\n          throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);\n        }\n        asnSchema = asn1Value[0];\n        break;\n    }\n    return asnSchema;\n  }\n  static toAsnItem(schemaItem, key, target, objProp) {\n    let asn1Item;\n    if (typeof schemaItem.type === \"number\") {\n      const converter = schemaItem.converter;\n      if (!converter) {\n        throw new Error(`Property '${key}' doesn't have converter for type ${AsnPropTypes[schemaItem.type]} in schema '${target.name}'`);\n      }\n      if (schemaItem.repeated) {\n        if (!Array.isArray(objProp)) {\n          throw new TypeError(\"Parameter 'objProp' should be type of Array.\");\n        }\n        const items = Array.from(objProp, element => converter.toASN(element));\n        const Container = schemaItem.repeated === \"sequence\" ? asn1js.Sequence : asn1js.Set;\n        asn1Item = new Container({\n          value: items\n        });\n      } else {\n        asn1Item = converter.toASN(objProp);\n      }\n    } else {\n      if (schemaItem.repeated) {\n        if (!Array.isArray(objProp)) {\n          throw new TypeError(\"Parameter 'objProp' should be type of Array.\");\n        }\n        const items = Array.from(objProp, element => this.toASN(element));\n        const Container = schemaItem.repeated === \"sequence\" ? asn1js.Sequence : asn1js.Set;\n        asn1Item = new Container({\n          value: items\n        });\n      } else {\n        asn1Item = this.toASN(objProp);\n      }\n    }\n    return asn1Item;\n  }\n}","map":{"version":3,"names":["asn1js","converters","AsnPropTypes","AsnTypeTypes","isConvertible","isArrayEqual","schemaStorage","AsnSerializer","serialize","obj","BaseBlock","toBER","toASN","TypeError","target","constructor","schema","get","cache","asn1Value","itemType","Array","isArray","converter","defaultConverter","Error","name","map","o","toAsnItem","type","key","items","schemaItem","objProp","undefined","defaultValue","asn1Item","context","implicit","repeated","value","valueHex","Null","valueBeforeDecodeView","valueBlock","push","Primitive","optional","idBlock","tagClass","tagNumber","Constructed","concat","asnSchema","Sequence","Set","Choice","from","element","Container"],"sources":["/Users/peterchen/Dropbox/Hexlink/Projects/pwa-demo/node_modules/@peculiar/asn1-x509/node_modules/@peculiar/asn1-schema/build/es2015/serializer.js"],"sourcesContent":["import * as asn1js from \"asn1js\";\nimport * as converters from \"./converters\";\nimport { AsnPropTypes, AsnTypeTypes } from \"./enums\";\nimport { isConvertible, isArrayEqual } from \"./helper\";\nimport { schemaStorage } from \"./storage\";\nexport class AsnSerializer {\n    static serialize(obj) {\n        if (obj instanceof asn1js.BaseBlock) {\n            return obj.toBER(false);\n        }\n        return this.toASN(obj).toBER(false);\n    }\n    static toASN(obj) {\n        if (obj && typeof obj === \"object\" && isConvertible(obj)) {\n            return obj.toASN();\n        }\n        if (!(obj && typeof obj === \"object\")) {\n            throw new TypeError(\"Parameter 1 should be type of Object.\");\n        }\n        const target = obj.constructor;\n        const schema = schemaStorage.get(target);\n        schemaStorage.cache(target);\n        let asn1Value = [];\n        if (schema.itemType) {\n            if (!Array.isArray(obj)) {\n                throw new TypeError(\"Parameter 1 should be type of Array.\");\n            }\n            if (typeof schema.itemType === \"number\") {\n                const converter = converters.defaultConverter(schema.itemType);\n                if (!converter) {\n                    throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);\n                }\n                asn1Value = obj.map((o) => converter.toASN(o));\n            }\n            else {\n                asn1Value = obj.map((o) => this.toAsnItem({ type: schema.itemType }, \"[]\", target, o));\n            }\n        }\n        else {\n            for (const key in schema.items) {\n                const schemaItem = schema.items[key];\n                const objProp = obj[key];\n                if (objProp === undefined\n                    || schemaItem.defaultValue === objProp\n                    || (typeof schemaItem.defaultValue === \"object\" && typeof objProp === \"object\"\n                        && isArrayEqual(this.serialize(schemaItem.defaultValue), this.serialize(objProp)))) {\n                    continue;\n                }\n                const asn1Item = AsnSerializer.toAsnItem(schemaItem, key, target, objProp);\n                if (typeof schemaItem.context === \"number\") {\n                    if (schemaItem.implicit) {\n                        if (!schemaItem.repeated\n                            && (typeof schemaItem.type === \"number\" || isConvertible(schemaItem.type))) {\n                            const value = {};\n                            value.valueHex = asn1Item instanceof asn1js.Null ? asn1Item.valueBeforeDecodeView : asn1Item.valueBlock.toBER();\n                            asn1Value.push(new asn1js.Primitive({\n                                optional: schemaItem.optional,\n                                idBlock: {\n                                    tagClass: 3,\n                                    tagNumber: schemaItem.context,\n                                },\n                                ...value,\n                            }));\n                        }\n                        else {\n                            asn1Value.push(new asn1js.Constructed({\n                                optional: schemaItem.optional,\n                                idBlock: {\n                                    tagClass: 3,\n                                    tagNumber: schemaItem.context,\n                                },\n                                value: asn1Item.valueBlock.value,\n                            }));\n                        }\n                    }\n                    else {\n                        asn1Value.push(new asn1js.Constructed({\n                            optional: schemaItem.optional,\n                            idBlock: {\n                                tagClass: 3,\n                                tagNumber: schemaItem.context,\n                            },\n                            value: [asn1Item],\n                        }));\n                    }\n                }\n                else if (schemaItem.repeated) {\n                    asn1Value = asn1Value.concat(asn1Item);\n                }\n                else {\n                    asn1Value.push(asn1Item);\n                }\n            }\n        }\n        let asnSchema;\n        switch (schema.type) {\n            case AsnTypeTypes.Sequence:\n                asnSchema = new asn1js.Sequence({ value: asn1Value });\n                break;\n            case AsnTypeTypes.Set:\n                asnSchema = new asn1js.Set({ value: asn1Value });\n                break;\n            case AsnTypeTypes.Choice:\n                if (!asn1Value[0]) {\n                    throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);\n                }\n                asnSchema = asn1Value[0];\n                break;\n        }\n        return asnSchema;\n    }\n    static toAsnItem(schemaItem, key, target, objProp) {\n        let asn1Item;\n        if (typeof (schemaItem.type) === \"number\") {\n            const converter = schemaItem.converter;\n            if (!converter) {\n                throw new Error(`Property '${key}' doesn't have converter for type ${AsnPropTypes[schemaItem.type]} in schema '${target.name}'`);\n            }\n            if (schemaItem.repeated) {\n                if (!Array.isArray(objProp)) {\n                    throw new TypeError(\"Parameter 'objProp' should be type of Array.\");\n                }\n                const items = Array.from(objProp, (element) => converter.toASN(element));\n                const Container = schemaItem.repeated === \"sequence\"\n                    ? asn1js.Sequence\n                    : asn1js.Set;\n                asn1Item = new Container({\n                    value: items,\n                });\n            }\n            else {\n                asn1Item = converter.toASN(objProp);\n            }\n        }\n        else {\n            if (schemaItem.repeated) {\n                if (!Array.isArray(objProp)) {\n                    throw new TypeError(\"Parameter 'objProp' should be type of Array.\");\n                }\n                const items = Array.from(objProp, (element) => this.toASN(element));\n                const Container = schemaItem.repeated === \"sequence\"\n                    ? asn1js.Sequence\n                    : asn1js.Set;\n                asn1Item = new Container({\n                    value: items,\n                });\n            }\n            else {\n                asn1Item = this.toASN(objProp);\n            }\n        }\n        return asn1Item;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}