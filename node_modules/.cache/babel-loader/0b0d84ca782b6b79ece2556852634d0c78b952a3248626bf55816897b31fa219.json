{"ast":null,"code":"'use strict';\n\nconst BinaryParseStream = require('../vendor/binary-parse-stream');\nconst Tagged = require('./tagged');\nconst Simple = require('./simple');\nconst utils = require('./utils');\nconst NoFilter = require('nofilter');\nconst stream = require('stream');\nconst constants = require('./constants');\nconst {\n  MT,\n  NUMBYTES,\n  SYMS,\n  BI\n} = constants;\nconst {\n  Buffer\n} = require('buffer');\nconst COUNT = Symbol('count');\nconst MAJOR = Symbol('major type');\nconst ERROR = Symbol('error');\nconst NOT_FOUND = Symbol('not found');\nfunction parentArray(parent, typ, count) {\n  const a = [];\n  a[COUNT] = count;\n  a[SYMS.PARENT] = parent;\n  a[MAJOR] = typ;\n  return a;\n}\nfunction parentBufferStream(parent, typ) {\n  const b = new NoFilter();\n  b[COUNT] = -1;\n  b[SYMS.PARENT] = parent;\n  b[MAJOR] = typ;\n  return b;\n}\nclass UnexpectedDataError extends Error {\n  constructor(byte, value) {\n    super(`Unexpected data: 0x${byte.toString(16)}`);\n    this.name = 'UnexpectedDataError';\n    this.byte = byte;\n    this.value = value;\n  }\n}\n\n/**\n * Things that can act as inputs, from which a NoFilter can be created.\n *\n * @typedef {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n *   |DataView|stream.Readable} BufferLike\n */\n/**\n * @typedef ExtendedResults\n * @property {any} value The value that was found.\n * @property {number} length The number of bytes of the original input that\n *   were read.\n * @property {Buffer} bytes The bytes of the original input that were used\n *   to produce the value.\n * @property {Buffer} [unused] The bytes that were left over from the original\n *   input.  This property only exists if {@linkcode Decoder.decodeFirst} or\n *   {@linkcode Decoder.decodeFirstSync} was called.\n */\n/**\n * @typedef DecoderOptions\n * @property {number} [max_depth=-1] The maximum depth to parse.\n *   Use -1 for \"until you run out of memory\".  Set this to a finite\n *   positive number for un-trusted inputs.  Most standard inputs won't nest\n *   more than 100 or so levels; I've tested into the millions before\n *   running out of memory.\n * @property {Tagged.TagMap} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] The encoding of the input.\n *   Ignored if input is a Buffer.\n * @property {boolean} [required=false] Should an error be thrown when no\n *   data is in the input?\n * @property {boolean} [extendedResults=false] If true, emit extended\n *   results, which will be an object with shape {@link ExtendedResults}.\n *   The value will already have been null-checked.\n * @property {boolean} [preventDuplicateKeys=false] If true, error is\n *   thrown if a map has duplicate keys.\n */\n/**\n * @callback decodeCallback\n * @param {Error} [error] If one was generated.\n * @param {any} [value] The decoded value.\n * @returns {void}\n */\n/**\n * @param {DecoderOptions|decodeCallback|string} opts Options,\n *   the callback, or input incoding.\n * @param {decodeCallback} [cb] Called on completion.\n * @returns {{options: DecoderOptions, cb: decodeCallback}} Normalized.\n * @throws {TypeError} On unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {\n        options: {},\n        cb: /** @type {decodeCallback} */opts\n      };\n    case 'string':\n      return {\n        options: {\n          encoding: /** @type {BufferEncoding} */opts\n        },\n        cb\n      };\n    case 'object':\n      return {\n        options: opts || {},\n        cb\n      };\n    default:\n      throw new TypeError('Unknown option type');\n  }\n}\n\n/**\n * Decode a stream of CBOR bytes by transforming them into equivalent\n * JavaScript data.  Because of the limitations of Node object streams,\n * special symbols are emitted instead of NULL or UNDEFINED.  Fix those\n * up by calling {@link Decoder.nullcheck}.\n *\n * @extends BinaryParseStream\n */\nclass Decoder extends BinaryParseStream {\n  /**\n   * Create a parsing stream.\n   *\n   * @param {DecoderOptions} [options={}] Options.\n   */\n  constructor(options = {}) {\n    const {\n      tags = {},\n      max_depth = -1,\n      preferWeb = false,\n      required = false,\n      encoding = 'hex',\n      extendedResults = false,\n      preventDuplicateKeys = false,\n      ...superOpts\n    } = options;\n    super({\n      defaultEncoding: encoding,\n      ...superOpts\n    });\n    this.running = true;\n    this.max_depth = max_depth;\n    this.tags = tags;\n    this.preferWeb = preferWeb;\n    this.extendedResults = extendedResults;\n    this.required = required;\n    this.preventDuplicateKeys = preventDuplicateKeys;\n    if (extendedResults) {\n      this.bs.on('read', this._onRead.bind(this));\n      this.valueBytes = /** @type {NoFilter} */new NoFilter();\n    }\n  }\n\n  /**\n   * Check the given value for a symbol encoding a NULL or UNDEFINED value in\n   * the CBOR stream.\n   *\n   * @param {any} val The value to check.\n   * @returns {any} The corrected value.\n   * @throws {Error} Nothing was found.\n   * @static\n   * @example\n   * myDecoder.on('data', val => {\n   *   val = Decoder.nullcheck(val)\n   *   // ...\n   * })\n   */\n  static nullcheck(val) {\n    switch (val) {\n      case SYMS.NULL:\n        return null;\n      case SYMS.UNDEFINED:\n        return undefined;\n      // Leaving this in for now as belt-and-suspenders, but I'm pretty sure\n      // it can't happen.\n      /* istanbul ignore next */\n      case NOT_FOUND:\n        /* istanbul ignore next */\n        throw new Error('Value not found');\n      default:\n        return val;\n    }\n  }\n\n  /**\n   * Decode the first CBOR item in the input, synchronously.  This will throw\n   * an exception if the input is not valid CBOR, or if there are more bytes\n   * left over at the end (if options.extendedResults is not true).\n   *\n   * @param {BufferLike} input If a Readable stream, must have\n   *   received the `readable` event already, or you will get an error\n   *   claiming \"Insufficient data\".\n   * @param {DecoderOptions|string} [options={}] Options or encoding for input.\n   * @returns {ExtendedResults|any} The decoded value.\n   * @throws {UnexpectedDataError} Data is left over after decoding.\n   * @throws {Error} Insufficient data.\n   * @static\n   */\n  static decodeFirstSync(input, options = {}) {\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n    ({\n      options\n    } = normalizeOptions(options));\n    const {\n      encoding = 'hex',\n      ...opts\n    } = options;\n    const c = new Decoder(opts);\n    const s = utils.guessEncoding(input, encoding);\n\n    // For/of doesn't work when you need to call next() with a value\n    // generator created by parser will be \"done\" after each CBOR entity\n    // parser will yield numbers of bytes that it wants\n    const parser = c._parse();\n    let state = parser.next();\n    while (!state.done) {\n      const b = s.read(state.value);\n      if (b == null || b.length !== state.value) {\n        throw new Error('Insufficient data');\n      }\n      if (c.extendedResults) {\n        c.valueBytes.write(b);\n      }\n      state = parser.next(b);\n    }\n    let val = null;\n    if (c.extendedResults) {\n      val = state.value;\n      val.unused = s.read();\n    } else {\n      val = Decoder.nullcheck(state.value);\n      if (s.length > 0) {\n        const nextByte = s.read(1);\n        s.unshift(nextByte);\n        throw new UnexpectedDataError(nextByte[0], val);\n      }\n    }\n    return val;\n  }\n\n  /**\n   * Decode all of the CBOR items in the input into an array.  This will throw\n   * an exception if the input is not valid CBOR; a zero-length input will\n   * return an empty array.\n   *\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|string} [options={}] Options or encoding\n   *   for input.\n   * @returns {Array<ExtendedResults>|Array<any>} Array of all found items.\n   * @throws {TypeError} No input provided.\n   * @throws {Error} Insufficient data provided.\n   * @static\n   */\n  static decodeAllSync(input, options = {}) {\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n    ({\n      options\n    } = normalizeOptions(options));\n    const {\n      encoding = 'hex',\n      ...opts\n    } = options;\n    const c = new Decoder(opts);\n    const s = utils.guessEncoding(input, encoding);\n    const res = [];\n    while (s.length > 0) {\n      const parser = c._parse();\n      let state = parser.next();\n      while (!state.done) {\n        const b = s.read(state.value);\n        if (b == null || b.length !== state.value) {\n          throw new Error('Insufficient data');\n        }\n        if (c.extendedResults) {\n          c.valueBytes.write(b);\n        }\n        state = parser.next(b);\n      }\n      res.push(Decoder.nullcheck(state.value));\n    }\n    return res;\n  }\n\n  /**\n   * Decode the first CBOR item in the input.  This will error if there are\n   * more bytes left over at the end (if options.extendedResults is not true),\n   * and optionally if there were no valid CBOR bytes in the input.  Emits the\n   * {Decoder.NOT_FOUND} Symbol in the callback if no data was found and the\n   * `required` option is false.\n   *\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|decodeCallback|string} [options={}] Options, the\n   *   callback, or input encoding.\n   * @param {decodeCallback} [cb] Callback.\n   * @returns {Promise<ExtendedResults|any>} Returned even if callback is\n   *   specified.\n   * @throws {TypeError} No input provided.\n   * @static\n   */\n  static decodeFirst(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n    ({\n      options,\n      cb\n    } = normalizeOptions(options, cb));\n    const {\n      encoding = 'hex',\n      required = false,\n      ...opts\n    } = options;\n    const c = new Decoder(opts);\n    let v = /** @type {any} */NOT_FOUND;\n    const s = utils.guessEncoding(input, encoding);\n    const p = new Promise((resolve, reject) => {\n      c.on('data', val => {\n        v = Decoder.nullcheck(val);\n        c.close();\n      });\n      c.once('error', er => {\n        if (c.extendedResults && er instanceof UnexpectedDataError) {\n          v.unused = c.bs.slice();\n          return resolve(v);\n        }\n        if (v !== NOT_FOUND) {\n          // Typescript work-around\n          // eslint-disable-next-line dot-notation\n          er['value'] = v;\n        }\n        v = ERROR;\n        c.close();\n        return reject(er);\n      });\n      c.once('end', () => {\n        switch (v) {\n          case NOT_FOUND:\n            if (required) {\n              return reject(new Error('No CBOR found'));\n            }\n            return resolve(v);\n          // Pretty sure this can't happen, but not *certain*.\n          /* istanbul ignore next */\n          case ERROR:\n            /* istanbul ignore next */\n            return undefined;\n          default:\n            return resolve(v);\n        }\n      });\n    });\n    if (typeof cb === 'function') {\n      p.then(val => cb(null, val), cb);\n    }\n    s.pipe(c);\n    return p;\n  }\n\n  /**\n   * @callback decodeAllCallback\n   * @param {Error} error If one was generated.\n   * @param {Array<ExtendedResults>|Array<any>} value All of the decoded\n   *   values, wrapped in an Array.\n   */\n\n  /**\n   * Decode all of the CBOR items in the input.  This will error if there are\n   * more bytes left over at the end.\n   *\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|decodeAllCallback|string} [options={}]\n   *   Decoding options, the callback, or the input encoding.\n   * @param {decodeAllCallback} [cb] Callback.\n   * @returns {Promise<Array<ExtendedResults>|Array<any>>} Even if callback\n   *   is specified.\n   * @throws {TypeError} No input specified.\n   * @static\n   */\n  static decodeAll(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n    ({\n      options,\n      cb\n    } = normalizeOptions(options, cb));\n    const {\n      encoding = 'hex',\n      ...opts\n    } = options;\n    const c = new Decoder(opts);\n    const vals = [];\n    c.on('data', val => vals.push(Decoder.nullcheck(val)));\n    const p = new Promise((resolve, reject) => {\n      c.on('error', reject);\n      c.on('end', () => resolve(vals));\n    });\n    if (typeof cb === 'function') {\n      p.then(v => cb(undefined, v), er => cb(er, undefined));\n    }\n    utils.guessEncoding(input, encoding).pipe(c);\n    return p;\n  }\n\n  /**\n   * Stop processing.\n   */\n  close() {\n    this.running = false;\n    this.__fresh = true;\n  }\n\n  /**\n   * Only called if extendedResults is true.\n   *\n   * @ignore\n   */\n  _onRead(data) {\n    this.valueBytes.write(data);\n  }\n\n  /**\n   * @returns {Generator<number, any, Buffer>} Yields a number of bytes,\n   *   returns anything, next returns a Buffer.\n   * @throws {Error} Maximum depth exceeded.\n   * @yields {number} Number of bytes to read.\n   * @ignore\n   */\n  *_parse() {\n    let parent = null;\n    let depth = 0;\n    let val = null;\n    while (true) {\n      if (this.max_depth >= 0 && depth > this.max_depth) {\n        throw new Error(`Maximum depth ${this.max_depth} exceeded`);\n      }\n      const [octet] = yield 1;\n      if (!this.running) {\n        this.bs.unshift(Buffer.from([octet]));\n        throw new UnexpectedDataError(octet);\n      }\n      const mt = octet >> 5;\n      const ai = octet & 0x1f;\n      const parent_major = parent == null ? undefined : parent[MAJOR];\n      const parent_length = parent == null ? undefined : parent.length;\n      switch (ai) {\n        case NUMBYTES.ONE:\n          this.emit('more-bytes', mt, 1, parent_major, parent_length);\n          [val] = yield 1;\n          break;\n        case NUMBYTES.TWO:\n        case NUMBYTES.FOUR:\n        case NUMBYTES.EIGHT:\n          {\n            const numbytes = 1 << ai - 24;\n            this.emit('more-bytes', mt, numbytes, parent_major, parent_length);\n            const buf = yield numbytes;\n            val = mt === MT.SIMPLE_FLOAT ? buf : utils.parseCBORint(ai, buf);\n            break;\n          }\n        case 28:\n        case 29:\n        case 30:\n          this.running = false;\n          throw new Error(`Additional info not implemented: ${ai}`);\n        case NUMBYTES.INDEFINITE:\n          switch (mt) {\n            case MT.POS_INT:\n            case MT.NEG_INT:\n            case MT.TAG:\n              throw new Error(`Invalid indefinite encoding for MT ${mt}`);\n          }\n          val = -1;\n          break;\n        default:\n          val = ai;\n      }\n      switch (mt) {\n        case MT.POS_INT:\n          // Val already decoded\n          break;\n        case MT.NEG_INT:\n          if (val === Number.MAX_SAFE_INTEGER) {\n            val = BI.NEG_MAX;\n          } else {\n            val = typeof val === 'bigint' ? BI.MINUS_ONE - val : -1 - val;\n          }\n          break;\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          switch (val) {\n            case 0:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n              if (mt === MT.UTF8_STRING) {\n                val = '';\n              } else {\n                val = this.preferWeb ? new Uint8Array(0) : Buffer.allocUnsafe(0);\n              }\n              break;\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentBufferStream(parent, mt);\n              depth++;\n              continue;\n            default:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n              val = yield val;\n              if (mt === MT.UTF8_STRING) {\n                val = utils.utf8(val);\n              } else if (this.preferWeb) {\n                val = new Uint8Array(val.buffer, val.byteOffset, val.length);\n              }\n          }\n          break;\n        case MT.ARRAY:\n        case MT.MAP:\n          switch (val) {\n            case 0:\n              val = mt === MT.MAP ? {} : [];\n              break;\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentArray(parent, mt, -1);\n              depth++;\n              continue;\n            default:\n              this.emit('start', mt, val, parent_major, parent_length);\n              parent = parentArray(parent, mt, val * (mt - 3));\n              depth++;\n              continue;\n          }\n          break;\n        case MT.TAG:\n          this.emit('start', mt, val, parent_major, parent_length);\n          parent = parentArray(parent, mt, 1);\n          parent.push(val);\n          depth++;\n          continue;\n        case MT.SIMPLE_FLOAT:\n          if (typeof val === 'number') {\n            if (ai === NUMBYTES.ONE && val < 32) {\n              throw new Error(`Invalid two-byte encoding of simple value ${val}`);\n            }\n            const hasParent = parent != null;\n            val = Simple.decode(val, hasParent, hasParent && parent[COUNT] < 0);\n          } else {\n            val = utils.parseCBORfloat(val);\n          }\n      }\n      this.emit('value', val, parent_major, parent_length, ai);\n      let again = false;\n      while (parent != null) {\n        if (val === SYMS.BREAK) {\n          parent[COUNT] = 1;\n        } else if (Array.isArray(parent)) {\n          parent.push(val);\n        } else {\n          // Assert: parent instanceof NoFilter\n          const pm = parent[MAJOR];\n          if (pm != null && pm !== mt) {\n            this.running = false;\n            throw new Error('Invalid major type in indefinite encoding');\n          }\n          parent.write(val);\n        }\n        if (--parent[COUNT] !== 0) {\n          again = true;\n          break;\n        }\n        --depth;\n        delete parent[COUNT];\n        if (Array.isArray(parent)) {\n          switch (parent[MAJOR]) {\n            case MT.ARRAY:\n              val = parent;\n              break;\n            case MT.MAP:\n              {\n                let allstrings = true;\n                if (parent.length % 2 !== 0) {\n                  throw new Error(`Invalid map length: ${parent.length}`);\n                }\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  if (typeof parent[i] !== 'string' || parent[i] === '__proto__') {\n                    allstrings = false;\n                    break;\n                  }\n                }\n                if (allstrings) {\n                  val = {};\n                  for (let i = 0, len = parent.length; i < len; i += 2) {\n                    if (this.preventDuplicateKeys && Object.prototype.hasOwnProperty.call(val, parent[i])) {\n                      throw new Error('Duplicate keys in a map');\n                    }\n                    val[parent[i]] = parent[i + 1];\n                  }\n                } else {\n                  val = new Map();\n                  for (let i = 0, len = parent.length; i < len; i += 2) {\n                    if (this.preventDuplicateKeys && val.has(parent[i])) {\n                      throw new Error('Duplicate keys in a map');\n                    }\n                    val.set(parent[i], parent[i + 1]);\n                  }\n                }\n                break;\n              }\n            case MT.TAG:\n              {\n                const t = new Tagged(parent[0], parent[1]);\n                val = t.convert(this.tags);\n                break;\n              }\n          }\n        } else /* istanbul ignore else */if (parent instanceof NoFilter) {\n            // Only parent types are Array and NoFilter for (Array/Map) and\n            // (bytes/string) respectively.\n            switch (parent[MAJOR]) {\n              case MT.BYTE_STRING:\n                val = parent.slice();\n                if (this.preferWeb) {\n                  val = new Uint8Array( /** @type {Buffer} */val.buffer, /** @type {Buffer} */val.byteOffset, /** @type {Buffer} */val.length);\n                }\n                break;\n              case MT.UTF8_STRING:\n                val = parent.toString('utf-8');\n                break;\n            }\n          }\n        this.emit('stop', parent[MAJOR]);\n        const old = parent;\n        parent = parent[SYMS.PARENT];\n        delete old[SYMS.PARENT];\n        delete old[MAJOR];\n      }\n      if (!again) {\n        if (this.extendedResults) {\n          const bytes = this.valueBytes.slice();\n          const ret = {\n            value: Decoder.nullcheck(val),\n            bytes,\n            length: bytes.length\n          };\n          this.valueBytes = new NoFilter();\n          return ret;\n        }\n        return val;\n      }\n    }\n  }\n}\nDecoder.NOT_FOUND = NOT_FOUND;\nmodule.exports = Decoder;","map":{"version":3,"names":["BinaryParseStream","require","Tagged","Simple","utils","NoFilter","stream","constants","MT","NUMBYTES","SYMS","BI","Buffer","COUNT","Symbol","MAJOR","ERROR","NOT_FOUND","parentArray","parent","typ","count","a","PARENT","parentBufferStream","b","UnexpectedDataError","Error","constructor","byte","value","toString","name","normalizeOptions","opts","cb","options","encoding","TypeError","Decoder","tags","max_depth","preferWeb","required","extendedResults","preventDuplicateKeys","superOpts","defaultEncoding","running","bs","on","_onRead","bind","valueBytes","nullcheck","val","NULL","UNDEFINED","undefined","decodeFirstSync","input","c","s","guessEncoding","parser","_parse","state","next","done","read","length","write","unused","nextByte","unshift","decodeAllSync","res","push","decodeFirst","v","p","Promise","resolve","reject","close","once","er","slice","then","pipe","decodeAll","vals","__fresh","data","depth","octet","from","mt","ai","parent_major","parent_length","ONE","emit","TWO","FOUR","EIGHT","numbytes","buf","SIMPLE_FLOAT","parseCBORint","INDEFINITE","POS_INT","NEG_INT","TAG","Number","MAX_SAFE_INTEGER","NEG_MAX","MINUS_ONE","BYTE_STRING","UTF8_STRING","Uint8Array","allocUnsafe","STREAM","utf8","buffer","byteOffset","ARRAY","MAP","hasParent","decode","parseCBORfloat","again","BREAK","Array","isArray","pm","allstrings","i","len","Object","prototype","hasOwnProperty","call","Map","has","set","t","convert","old","bytes","ret","module","exports"],"sources":["/Users/peterchen/Dropbox/Hexlink/pwa-demo/node_modules/cbor/lib/decoder.js"],"sourcesContent":["'use strict'\n\nconst BinaryParseStream = require('../vendor/binary-parse-stream')\nconst Tagged = require('./tagged')\nconst Simple = require('./simple')\nconst utils = require('./utils')\nconst NoFilter = require('nofilter')\nconst stream = require('stream')\nconst constants = require('./constants')\nconst {MT, NUMBYTES, SYMS, BI} = constants\nconst {Buffer} = require('buffer')\n\nconst COUNT = Symbol('count')\nconst MAJOR = Symbol('major type')\nconst ERROR = Symbol('error')\nconst NOT_FOUND = Symbol('not found')\n\nfunction parentArray(parent, typ, count) {\n  const a = []\n\n  a[COUNT] = count\n  a[SYMS.PARENT] = parent\n  a[MAJOR] = typ\n  return a\n}\n\nfunction parentBufferStream(parent, typ) {\n  const b = new NoFilter()\n\n  b[COUNT] = -1\n  b[SYMS.PARENT] = parent\n  b[MAJOR] = typ\n  return b\n}\n\nclass UnexpectedDataError extends Error {\n  constructor(byte, value) {\n    super(`Unexpected data: 0x${byte.toString(16)}`)\n    this.name = 'UnexpectedDataError'\n    this.byte = byte\n    this.value = value\n  }\n}\n\n/**\n * Things that can act as inputs, from which a NoFilter can be created.\n *\n * @typedef {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n *   |DataView|stream.Readable} BufferLike\n */\n/**\n * @typedef ExtendedResults\n * @property {any} value The value that was found.\n * @property {number} length The number of bytes of the original input that\n *   were read.\n * @property {Buffer} bytes The bytes of the original input that were used\n *   to produce the value.\n * @property {Buffer} [unused] The bytes that were left over from the original\n *   input.  This property only exists if {@linkcode Decoder.decodeFirst} or\n *   {@linkcode Decoder.decodeFirstSync} was called.\n */\n/**\n * @typedef DecoderOptions\n * @property {number} [max_depth=-1] The maximum depth to parse.\n *   Use -1 for \"until you run out of memory\".  Set this to a finite\n *   positive number for un-trusted inputs.  Most standard inputs won't nest\n *   more than 100 or so levels; I've tested into the millions before\n *   running out of memory.\n * @property {Tagged.TagMap} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] The encoding of the input.\n *   Ignored if input is a Buffer.\n * @property {boolean} [required=false] Should an error be thrown when no\n *   data is in the input?\n * @property {boolean} [extendedResults=false] If true, emit extended\n *   results, which will be an object with shape {@link ExtendedResults}.\n *   The value will already have been null-checked.\n * @property {boolean} [preventDuplicateKeys=false] If true, error is\n *   thrown if a map has duplicate keys.\n */\n/**\n * @callback decodeCallback\n * @param {Error} [error] If one was generated.\n * @param {any} [value] The decoded value.\n * @returns {void}\n */\n/**\n * @param {DecoderOptions|decodeCallback|string} opts Options,\n *   the callback, or input incoding.\n * @param {decodeCallback} [cb] Called on completion.\n * @returns {{options: DecoderOptions, cb: decodeCallback}} Normalized.\n * @throws {TypeError} On unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {decodeCallback} */ (opts)}\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb}\n    case 'object':\n      return {options: opts || {}, cb}\n    default:\n      throw new TypeError('Unknown option type')\n  }\n}\n\n/**\n * Decode a stream of CBOR bytes by transforming them into equivalent\n * JavaScript data.  Because of the limitations of Node object streams,\n * special symbols are emitted instead of NULL or UNDEFINED.  Fix those\n * up by calling {@link Decoder.nullcheck}.\n *\n * @extends BinaryParseStream\n */\nclass Decoder extends BinaryParseStream {\n  /**\n   * Create a parsing stream.\n   *\n   * @param {DecoderOptions} [options={}] Options.\n   */\n  constructor(options = {}) {\n    const {\n      tags = {},\n      max_depth = -1,\n      preferWeb = false,\n      required = false,\n      encoding = 'hex',\n      extendedResults = false,\n      preventDuplicateKeys = false,\n      ...superOpts\n    } = options\n\n    super({defaultEncoding: encoding, ...superOpts})\n\n    this.running = true\n    this.max_depth = max_depth\n    this.tags = tags\n    this.preferWeb = preferWeb\n    this.extendedResults = extendedResults\n    this.required = required\n    this.preventDuplicateKeys = preventDuplicateKeys\n\n    if (extendedResults) {\n      this.bs.on('read', this._onRead.bind(this))\n      this.valueBytes = /** @type {NoFilter} */ (new NoFilter())\n    }\n  }\n\n  /**\n   * Check the given value for a symbol encoding a NULL or UNDEFINED value in\n   * the CBOR stream.\n   *\n   * @param {any} val The value to check.\n   * @returns {any} The corrected value.\n   * @throws {Error} Nothing was found.\n   * @static\n   * @example\n   * myDecoder.on('data', val => {\n   *   val = Decoder.nullcheck(val)\n   *   // ...\n   * })\n   */\n  static nullcheck(val) {\n    switch (val) {\n      case SYMS.NULL:\n        return null\n      case SYMS.UNDEFINED:\n        return undefined\n      // Leaving this in for now as belt-and-suspenders, but I'm pretty sure\n      // it can't happen.\n      /* istanbul ignore next */\n      case NOT_FOUND:\n        /* istanbul ignore next */\n        throw new Error('Value not found')\n      default:\n        return val\n    }\n  }\n\n  /**\n   * Decode the first CBOR item in the input, synchronously.  This will throw\n   * an exception if the input is not valid CBOR, or if there are more bytes\n   * left over at the end (if options.extendedResults is not true).\n   *\n   * @param {BufferLike} input If a Readable stream, must have\n   *   received the `readable` event already, or you will get an error\n   *   claiming \"Insufficient data\".\n   * @param {DecoderOptions|string} [options={}] Options or encoding for input.\n   * @returns {ExtendedResults|any} The decoded value.\n   * @throws {UnexpectedDataError} Data is left over after decoding.\n   * @throws {Error} Insufficient data.\n   * @static\n   */\n  static decodeFirstSync(input, options = {}) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options} = normalizeOptions(options))\n    const {encoding = 'hex', ...opts} = options\n    const c = new Decoder(opts)\n    const s = utils.guessEncoding(input, encoding)\n\n    // For/of doesn't work when you need to call next() with a value\n    // generator created by parser will be \"done\" after each CBOR entity\n    // parser will yield numbers of bytes that it wants\n    const parser = c._parse()\n    let state = parser.next()\n\n    while (!state.done) {\n      const b = s.read(state.value)\n\n      if ((b == null) || (b.length !== state.value)) {\n        throw new Error('Insufficient data')\n      }\n      if (c.extendedResults) {\n        c.valueBytes.write(b)\n      }\n      state = parser.next(b)\n    }\n\n    let val = null\n    if (c.extendedResults) {\n      val = state.value\n      val.unused = s.read()\n    } else {\n      val = Decoder.nullcheck(state.value)\n      if (s.length > 0) {\n        const nextByte = s.read(1)\n\n        s.unshift(nextByte)\n        throw new UnexpectedDataError(nextByte[0], val)\n      }\n    }\n    return val\n  }\n\n  /**\n   * Decode all of the CBOR items in the input into an array.  This will throw\n   * an exception if the input is not valid CBOR; a zero-length input will\n   * return an empty array.\n   *\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|string} [options={}] Options or encoding\n   *   for input.\n   * @returns {Array<ExtendedResults>|Array<any>} Array of all found items.\n   * @throws {TypeError} No input provided.\n   * @throws {Error} Insufficient data provided.\n   * @static\n   */\n  static decodeAllSync(input, options = {}) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options} = normalizeOptions(options))\n    const {encoding = 'hex', ...opts} = options\n    const c = new Decoder(opts)\n    const s = utils.guessEncoding(input, encoding)\n    const res = []\n\n    while (s.length > 0) {\n      const parser = c._parse()\n      let state = parser.next()\n\n      while (!state.done) {\n        const b = s.read(state.value)\n\n        if ((b == null) || (b.length !== state.value)) {\n          throw new Error('Insufficient data')\n        }\n        if (c.extendedResults) {\n          c.valueBytes.write(b)\n        }\n        state = parser.next(b)\n      }\n      res.push(Decoder.nullcheck(state.value))\n    }\n    return res\n  }\n\n  /**\n   * Decode the first CBOR item in the input.  This will error if there are\n   * more bytes left over at the end (if options.extendedResults is not true),\n   * and optionally if there were no valid CBOR bytes in the input.  Emits the\n   * {Decoder.NOT_FOUND} Symbol in the callback if no data was found and the\n   * `required` option is false.\n   *\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|decodeCallback|string} [options={}] Options, the\n   *   callback, or input encoding.\n   * @param {decodeCallback} [cb] Callback.\n   * @returns {Promise<ExtendedResults|any>} Returned even if callback is\n   *   specified.\n   * @throws {TypeError} No input provided.\n   * @static\n   */\n  static decodeFirst(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options, cb} = normalizeOptions(options, cb))\n    const {encoding = 'hex', required = false, ...opts} = options\n\n    const c = new Decoder(opts)\n    let v = /** @type {any} */ (NOT_FOUND)\n    const s = utils.guessEncoding(input, encoding)\n    const p = new Promise((resolve, reject) => {\n      c.on('data', val => {\n        v = Decoder.nullcheck(val)\n        c.close()\n      })\n      c.once('error', er => {\n        if (c.extendedResults && (er instanceof UnexpectedDataError)) {\n          v.unused = c.bs.slice()\n          return resolve(v)\n        }\n        if (v !== NOT_FOUND) {\n          // Typescript work-around\n          // eslint-disable-next-line dot-notation\n          er['value'] = v\n        }\n        v = ERROR\n        c.close()\n        return reject(er)\n      })\n      c.once('end', () => {\n        switch (v) {\n          case NOT_FOUND:\n            if (required) {\n              return reject(new Error('No CBOR found'))\n            }\n            return resolve(v)\n          // Pretty sure this can't happen, but not *certain*.\n          /* istanbul ignore next */\n          case ERROR:\n            /* istanbul ignore next */\n            return undefined\n          default:\n            return resolve(v)\n        }\n      })\n    })\n\n    if (typeof cb === 'function') {\n      p.then(val => cb(null, val), cb)\n    }\n    s.pipe(c)\n    return p\n  }\n\n  /**\n   * @callback decodeAllCallback\n   * @param {Error} error If one was generated.\n   * @param {Array<ExtendedResults>|Array<any>} value All of the decoded\n   *   values, wrapped in an Array.\n   */\n\n  /**\n   * Decode all of the CBOR items in the input.  This will error if there are\n   * more bytes left over at the end.\n   *\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|decodeAllCallback|string} [options={}]\n   *   Decoding options, the callback, or the input encoding.\n   * @param {decodeAllCallback} [cb] Callback.\n   * @returns {Promise<Array<ExtendedResults>|Array<any>>} Even if callback\n   *   is specified.\n   * @throws {TypeError} No input specified.\n   * @static\n   */\n  static decodeAll(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options, cb} = normalizeOptions(options, cb))\n    const {encoding = 'hex', ...opts} = options\n\n    const c = new Decoder(opts)\n    const vals = []\n\n    c.on('data', val => vals.push(Decoder.nullcheck(val)))\n\n    const p = new Promise((resolve, reject) => {\n      c.on('error', reject)\n      c.on('end', () => resolve(vals))\n    })\n\n    if (typeof cb === 'function') {\n      p.then(v => cb(undefined, v), er => cb(er, undefined))\n    }\n    utils.guessEncoding(input, encoding).pipe(c)\n    return p\n  }\n\n  /**\n   * Stop processing.\n   */\n  close() {\n    this.running = false\n    this.__fresh = true\n  }\n\n  /**\n   * Only called if extendedResults is true.\n   *\n   * @ignore\n   */\n  _onRead(data) {\n    this.valueBytes.write(data)\n  }\n\n  /**\n   * @returns {Generator<number, any, Buffer>} Yields a number of bytes,\n   *   returns anything, next returns a Buffer.\n   * @throws {Error} Maximum depth exceeded.\n   * @yields {number} Number of bytes to read.\n   * @ignore\n   */\n  *_parse() {\n    let parent = null\n    let depth = 0\n    let val = null\n\n    while (true) {\n      if ((this.max_depth >= 0) && (depth > this.max_depth)) {\n        throw new Error(`Maximum depth ${this.max_depth} exceeded`)\n      }\n\n      const [octet] = yield 1\n      if (!this.running) {\n        this.bs.unshift(Buffer.from([octet]))\n        throw new UnexpectedDataError(octet)\n      }\n      const mt = octet >> 5\n      const ai = octet & 0x1f\n      const parent_major = (parent == null) ? undefined : parent[MAJOR]\n      const parent_length = (parent == null) ? undefined : parent.length\n\n      switch (ai) {\n        case NUMBYTES.ONE:\n          this.emit('more-bytes', mt, 1, parent_major, parent_length)\n          ;[val] = yield 1\n          break\n        case NUMBYTES.TWO:\n        case NUMBYTES.FOUR:\n        case NUMBYTES.EIGHT: {\n          const numbytes = 1 << (ai - 24)\n\n          this.emit('more-bytes', mt, numbytes, parent_major, parent_length)\n          const buf = yield numbytes\n          val = (mt === MT.SIMPLE_FLOAT) ?\n            buf :\n            utils.parseCBORint(ai, buf)\n          break\n        }\n        case 28:\n        case 29:\n        case 30:\n          this.running = false\n          throw new Error(`Additional info not implemented: ${ai}`)\n        case NUMBYTES.INDEFINITE:\n          switch (mt) {\n            case MT.POS_INT:\n            case MT.NEG_INT:\n            case MT.TAG:\n              throw new Error(`Invalid indefinite encoding for MT ${mt}`)\n          }\n          val = -1\n          break\n        default:\n          val = ai\n      }\n      switch (mt) {\n        case MT.POS_INT:\n          // Val already decoded\n          break\n        case MT.NEG_INT:\n          if (val === Number.MAX_SAFE_INTEGER) {\n            val = BI.NEG_MAX\n          } else {\n            val = (typeof val === 'bigint') ? BI.MINUS_ONE - val : -1 - val\n          }\n          break\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          switch (val) {\n            case 0:\n              this.emit('start-string', mt, val, parent_major, parent_length)\n              if (mt === MT.UTF8_STRING) {\n                val = ''\n              } else {\n                val = this.preferWeb ? new Uint8Array(0) : Buffer.allocUnsafe(0)\n              }\n              break\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length)\n              parent = parentBufferStream(parent, mt)\n              depth++\n              continue\n            default:\n              this.emit('start-string', mt, val, parent_major, parent_length)\n              val = yield val\n              if (mt === MT.UTF8_STRING) {\n                val = utils.utf8(val)\n              } else if (this.preferWeb) {\n                val = new Uint8Array(val.buffer, val.byteOffset, val.length)\n              }\n          }\n          break\n        case MT.ARRAY:\n        case MT.MAP:\n          switch (val) {\n            case 0:\n              val = (mt === MT.MAP) ? {} : []\n              break\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length)\n              parent = parentArray(parent, mt, -1)\n              depth++\n              continue\n            default:\n              this.emit('start', mt, val, parent_major, parent_length)\n              parent = parentArray(parent, mt, val * (mt - 3))\n              depth++\n              continue\n          }\n          break\n        case MT.TAG:\n          this.emit('start', mt, val, parent_major, parent_length)\n          parent = parentArray(parent, mt, 1)\n          parent.push(val)\n          depth++\n          continue\n        case MT.SIMPLE_FLOAT:\n          if (typeof val === 'number') {\n            if ((ai === NUMBYTES.ONE) && (val < 32)) {\n              throw new Error(\n                `Invalid two-byte encoding of simple value ${val}`\n              )\n            }\n            const hasParent = (parent != null)\n            val = Simple.decode(\n              val,\n              hasParent,\n              hasParent && (parent[COUNT] < 0)\n            )\n          } else {\n            val = utils.parseCBORfloat(val)\n          }\n      }\n      this.emit('value', val, parent_major, parent_length, ai)\n      let again = false\n      while (parent != null) {\n        if (val === SYMS.BREAK) {\n          parent[COUNT] = 1\n        } else if (Array.isArray(parent)) {\n          parent.push(val)\n        } else {\n          // Assert: parent instanceof NoFilter\n          const pm = parent[MAJOR]\n\n          if ((pm != null) && (pm !== mt)) {\n            this.running = false\n            throw new Error('Invalid major type in indefinite encoding')\n          }\n          parent.write(val)\n        }\n\n        if ((--parent[COUNT]) !== 0) {\n          again = true\n          break\n        }\n        --depth\n        delete parent[COUNT]\n\n        if (Array.isArray(parent)) {\n          switch (parent[MAJOR]) {\n            case MT.ARRAY:\n              val = parent\n              break\n            case MT.MAP: {\n              let allstrings = true\n\n              if ((parent.length % 2) !== 0) {\n                throw new Error(`Invalid map length: ${parent.length}`)\n              }\n              for (let i = 0, len = parent.length; i < len; i += 2) {\n                if ((typeof parent[i] !== 'string') ||\n                    (parent[i] === '__proto__')) {\n                  allstrings = false\n                  break\n                }\n              }\n              if (allstrings) {\n                val = {}\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  if (this.preventDuplicateKeys &&\n                    Object.prototype.hasOwnProperty.call(val, parent[i])) {\n                    throw new Error('Duplicate keys in a map')\n                  }\n                  val[parent[i]] = parent[i + 1]\n                }\n              } else {\n                val = new Map()\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  if (this.preventDuplicateKeys && val.has(parent[i])) {\n                    throw new Error('Duplicate keys in a map')\n                  }\n                  val.set(parent[i], parent[i + 1])\n                }\n              }\n              break\n            }\n            case MT.TAG: {\n              const t = new Tagged(parent[0], parent[1])\n\n              val = t.convert(this.tags)\n              break\n            }\n          }\n        } else /* istanbul ignore else */ if (parent instanceof NoFilter) {\n          // Only parent types are Array and NoFilter for (Array/Map) and\n          // (bytes/string) respectively.\n          switch (parent[MAJOR]) {\n            case MT.BYTE_STRING:\n              val = parent.slice()\n              if (this.preferWeb) {\n                val = new Uint8Array(\n                  /** @type {Buffer} */ (val).buffer,\n                  /** @type {Buffer} */ (val).byteOffset,\n                  /** @type {Buffer} */ (val).length\n                )\n              }\n              break\n            case MT.UTF8_STRING:\n              val = parent.toString('utf-8')\n              break\n          }\n        }\n        this.emit('stop', parent[MAJOR])\n\n        const old = parent\n        parent = parent[SYMS.PARENT]\n        delete old[SYMS.PARENT]\n        delete old[MAJOR]\n      }\n      if (!again) {\n        if (this.extendedResults) {\n          const bytes = this.valueBytes.slice()\n          const ret = {\n            value: Decoder.nullcheck(val),\n            bytes,\n            length: bytes.length,\n          }\n\n          this.valueBytes = new NoFilter()\n          return ret\n        }\n        return val\n      }\n    }\n  }\n}\n\nDecoder.NOT_FOUND = NOT_FOUND\nmodule.exports = Decoder\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}