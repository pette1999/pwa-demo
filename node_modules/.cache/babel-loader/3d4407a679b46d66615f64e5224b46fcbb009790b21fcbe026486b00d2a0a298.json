{"ast":null,"code":"import { ethers } from 'ethers';\nimport * as base64url from \"./base64url-arraybuffer\";\n// import base64url from \"base64url-ts2\";\nimport { ECDSASigValue } from '@peculiar/asn1-ecc';\nimport { AsnParser } from '@peculiar/asn1-schema';\nimport { Buffer } from 'buffer';\nimport * as asn1js from \"asn1js\";\nfunction shouldRemoveLeadingZero(bytes) {\n  return bytes[0] === 0x0 && (bytes[1] & 1 << 7) !== 0;\n}\n\n/**\n * Parse the WebAuthn data payload and to create the inputs to verify the secp256r1/p256 signatures\n * in the EllipticCurve.sol contract, see https://github.com/tdrerup/elliptic-curve-solidity\n */\nexport const authResponseToSigVerificationInput = (parsedCredentialPublicKey, authResponse) => {\n  const authDataBuffer = base64url.toBuffer(authResponse.authenticatorData);\n  const clientDataHash = Buffer.from(ethers.sha256(base64url.toBuffer(authResponse.clientDataJSON)).slice(2), 'hex');\n  const signatureBase = Buffer.concat([authDataBuffer, clientDataHash]);\n  const signatureA = base64url.toBuffer(authResponse.signature);\n  console.log(signatureA);\n  const asn1Parsed = asn1js.fromBER(signatureA);\n  console.log(asn1Parsed);\n  // See https://github.dev/MasterKale/SimpleWebAuthn/blob/master/packages/server/src/helpers/iso/isoCrypto/verifyEC2.ts\n  // for extraction of the r and s bytes from the raw signature buffer\n  const parsedSignature = AsnParser.parse(signatureA, ECDSASigValue);\n  let rBytes = new Uint8Array(parsedSignature.r);\n  let sBytes = new Uint8Array(parsedSignature.s);\n  if (shouldRemoveLeadingZero(rBytes)) {\n    rBytes = rBytes.slice(1);\n  }\n  if (shouldRemoveLeadingZero(sBytes)) {\n    sBytes = sBytes.slice(1);\n  }\n\n  // Message data in sha256 hash\n  const messageHash = ethers.sha256(signatureBase);\n  // r and s values\n  const signature = ['0x' + Buffer.from(rBytes).toString('hex'), '0x' + Buffer.from(sBytes).toString('hex')];\n  // x and y coordinates\n  const publicKeyCoordinates = ['0x' + base64url.toBuffer((parsedCredentialPublicKey === null || parsedCredentialPublicKey === void 0 ? void 0 : parsedCredentialPublicKey.x) || '').toString('hex'), '0x' + base64url.toBuffer((parsedCredentialPublicKey === null || parsedCredentialPublicKey === void 0 ? void 0 : parsedCredentialPublicKey.y) || '').toString('hex')];\n\n  // Pass the following data to the EllipticCurve.validateSignature smart contract function\n  return {\n    messageHash,\n    signature,\n    publicKeyCoordinates\n  };\n};","map":{"version":3,"names":["ethers","base64url","ECDSASigValue","AsnParser","Buffer","asn1js","shouldRemoveLeadingZero","bytes","authResponseToSigVerificationInput","parsedCredentialPublicKey","authResponse","authDataBuffer","toBuffer","authenticatorData","clientDataHash","from","sha256","clientDataJSON","slice","signatureBase","concat","signatureA","signature","console","log","asn1Parsed","fromBER","parsedSignature","parse","rBytes","Uint8Array","r","sBytes","s","messageHash","toString","publicKeyCoordinates","x","y"],"sources":["/Users/peterchen/Dropbox/Hexlink/Projects/pwa-demo/src/utils/passkey/shared/authResponseToSigVerificationInput.ts"],"sourcesContent":["import { ethers } from 'ethers';\nimport * as base64url from \"./base64url-arraybuffer\";\n// import base64url from \"base64url-ts2\";\nimport { ECDSASigValue } from '@peculiar/asn1-ecc';\nimport { AsnParser } from '@peculiar/asn1-schema';\nimport { AuthenticatorAssertionResponseJSON } from '@simplewebauthn/typescript-types';\nimport { Buffer } from 'buffer';\nimport * as asn1js from \"asn1js\";\n\nfunction shouldRemoveLeadingZero(bytes: Uint8Array): boolean {\n  return bytes[0] === 0x0 && (bytes[1] & (1 << 7)) !== 0;\n}\n\n/**\n * Parse the WebAuthn data payload and to create the inputs to verify the secp256r1/p256 signatures\n * in the EllipticCurve.sol contract, see https://github.com/tdrerup/elliptic-curve-solidity\n */\nexport const authResponseToSigVerificationInput = (\n  // Assumes the public key is on the secp256r1/p256 curve\n  parsedCredentialPublicKey: { x?: string; y?: string } | undefined,\n  authResponse: AuthenticatorAssertionResponseJSON,\n) => {\n  const authDataBuffer = base64url.toBuffer(authResponse.authenticatorData);\n  const clientDataHash = Buffer.from(\n    ethers.sha256(base64url.toBuffer(authResponse.clientDataJSON)).slice(2),\n    'hex',\n  );\n\n  const signatureBase = Buffer.concat([authDataBuffer, clientDataHash]);\n  const signatureA = base64url.toBuffer(authResponse.signature);\n  console.log(signatureA);\n\n  const asn1Parsed = asn1js.fromBER(signatureA);\n  console.log(asn1Parsed);\n  // See https://github.dev/MasterKale/SimpleWebAuthn/blob/master/packages/server/src/helpers/iso/isoCrypto/verifyEC2.ts\n  // for extraction of the r and s bytes from the raw signature buffer\n  const parsedSignature = AsnParser.parse(signatureA, ECDSASigValue);\n  let rBytes = new Uint8Array(parsedSignature.r);\n  let sBytes = new Uint8Array(parsedSignature.s);\n\n  if (shouldRemoveLeadingZero(rBytes)) {\n    rBytes = rBytes.slice(1);\n  }\n\n  if (shouldRemoveLeadingZero(sBytes)) {\n    sBytes = sBytes.slice(1);\n  }\n\n  // Message data in sha256 hash\n  const messageHash = ethers.sha256(signatureBase);\n  // r and s values\n  const signature = ['0x' + Buffer.from(rBytes).toString('hex'), '0x' + Buffer.from(sBytes).toString('hex')];\n  // x and y coordinates\n  const publicKeyCoordinates = [\n    '0x' + base64url.toBuffer(parsedCredentialPublicKey?.x || '').toString('hex'),\n    '0x' + base64url.toBuffer(parsedCredentialPublicKey?.y || '').toString('hex'),\n  ];\n\n  // Pass the following data to the EllipticCurve.validateSignature smart contract function\n  return {\n    messageHash,\n    signature,\n    publicKeyCoordinates,\n  };\n};\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,QAAQ;AAC/B,OAAO,KAAKC,SAAS,MAAM,yBAAyB;AACpD;AACA,SAASC,aAAa,QAAQ,oBAAoB;AAClD,SAASC,SAAS,QAAQ,uBAAuB;AAEjD,SAASC,MAAM,QAAQ,QAAQ;AAC/B,OAAO,KAAKC,MAAM,MAAM,QAAQ;AAEhC,SAASC,uBAAuBA,CAACC,KAAiB,EAAW;EAC3D,OAAOA,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC,CAAC,CAAC,GAAI,CAAC,IAAI,CAAE,MAAM,CAAC;AACxD;;AAEA;AACA;AACA;AACA;AACA,OAAO,MAAMC,kCAAkC,GAAGA,CAEhDC,yBAAiE,EACjEC,YAAgD,KAC7C;EACH,MAAMC,cAAc,GAAGV,SAAS,CAACW,QAAQ,CAACF,YAAY,CAACG,iBAAiB,CAAC;EACzE,MAAMC,cAAc,GAAGV,MAAM,CAACW,IAAI,CAChCf,MAAM,CAACgB,MAAM,CAACf,SAAS,CAACW,QAAQ,CAACF,YAAY,CAACO,cAAc,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC,CAAC,EACvE,KACF,CAAC;EAED,MAAMC,aAAa,GAAGf,MAAM,CAACgB,MAAM,CAAC,CAACT,cAAc,EAAEG,cAAc,CAAC,CAAC;EACrE,MAAMO,UAAU,GAAGpB,SAAS,CAACW,QAAQ,CAACF,YAAY,CAACY,SAAS,CAAC;EAC7DC,OAAO,CAACC,GAAG,CAACH,UAAU,CAAC;EAEvB,MAAMI,UAAU,GAAGpB,MAAM,CAACqB,OAAO,CAACL,UAAU,CAAC;EAC7CE,OAAO,CAACC,GAAG,CAACC,UAAU,CAAC;EACvB;EACA;EACA,MAAME,eAAe,GAAGxB,SAAS,CAACyB,KAAK,CAACP,UAAU,EAAEnB,aAAa,CAAC;EAClE,IAAI2B,MAAM,GAAG,IAAIC,UAAU,CAACH,eAAe,CAACI,CAAC,CAAC;EAC9C,IAAIC,MAAM,GAAG,IAAIF,UAAU,CAACH,eAAe,CAACM,CAAC,CAAC;EAE9C,IAAI3B,uBAAuB,CAACuB,MAAM,CAAC,EAAE;IACnCA,MAAM,GAAGA,MAAM,CAACX,KAAK,CAAC,CAAC,CAAC;EAC1B;EAEA,IAAIZ,uBAAuB,CAAC0B,MAAM,CAAC,EAAE;IACnCA,MAAM,GAAGA,MAAM,CAACd,KAAK,CAAC,CAAC,CAAC;EAC1B;;EAEA;EACA,MAAMgB,WAAW,GAAGlC,MAAM,CAACgB,MAAM,CAACG,aAAa,CAAC;EAChD;EACA,MAAMG,SAAS,GAAG,CAAC,IAAI,GAAGlB,MAAM,CAACW,IAAI,CAACc,MAAM,CAAC,CAACM,QAAQ,CAAC,KAAK,CAAC,EAAE,IAAI,GAAG/B,MAAM,CAACW,IAAI,CAACiB,MAAM,CAAC,CAACG,QAAQ,CAAC,KAAK,CAAC,CAAC;EAC1G;EACA,MAAMC,oBAAoB,GAAG,CAC3B,IAAI,GAAGnC,SAAS,CAACW,QAAQ,CAAC,CAAAH,yBAAyB,aAAzBA,yBAAyB,uBAAzBA,yBAAyB,CAAE4B,CAAC,KAAI,EAAE,CAAC,CAACF,QAAQ,CAAC,KAAK,CAAC,EAC7E,IAAI,GAAGlC,SAAS,CAACW,QAAQ,CAAC,CAAAH,yBAAyB,aAAzBA,yBAAyB,uBAAzBA,yBAAyB,CAAE6B,CAAC,KAAI,EAAE,CAAC,CAACH,QAAQ,CAAC,KAAK,CAAC,CAC9E;;EAED;EACA,OAAO;IACLD,WAAW;IACXZ,SAAS;IACTc;EACF,CAAC;AACH,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}